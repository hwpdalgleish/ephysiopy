

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ephysiopy.dacq2py.dacq2py_util &mdash; ephysiopy 1.5.55 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> ephysiopy
          

          
          </a>

          
            
            
              <div class="version">
                1.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../source/README.html">Synopsis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../source/README.html#installation">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../source/README.html#code-example">Code Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../source/README.html#motivation">Motivation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../source/README.html#contributors">Contributors</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">ephysiopy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>ephysiopy.dacq2py.dacq2py_util</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for ephysiopy.dacq2py.dacq2py_util</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="n">ndimage</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">glob</span> <span class="kn">import</span> <span class="n">glob</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib.cm</span> <span class="k">as</span> <span class="nn">cm</span>
<span class="kn">import</span> <span class="nn">matplotlib.colors</span> <span class="k">as</span> <span class="nn">colors</span>
<span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="kn">import</span> <span class="n">Rectangle</span>
<span class="kn">import</span> <span class="nn">matplotlib.transforms</span> <span class="k">as</span> <span class="nn">transforms</span>
<span class="kn">from</span> <span class="nn">matplotlib.collections</span> <span class="kn">import</span> <span class="n">LineCollection</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1</span> <span class="kn">import</span> <span class="n">make_axes_locatable</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">axonaIO</span>
<span class="kn">from</span> <span class="nn">.tetrode_dict</span> <span class="kn">import</span> <span class="n">TetrodeDict</span>
<span class="kn">from</span> <span class="nn">ephysiopy.ephys_generic</span> <span class="kn">import</span> <span class="n">binning</span>
<span class="kn">from</span> <span class="nn">ephysiopy.ephys_generic.ephys_generic</span> <span class="kn">import</span> <span class="n">FieldCalcs</span>
<span class="kn">from</span> <span class="nn">.spikecalcs</span> <span class="kn">import</span> <span class="n">SpikeCalcs</span>
<span class="kn">from</span> <span class="nn">.eegcalcs</span> <span class="kn">import</span> <span class="n">EEGCalcs</span>
<span class="kn">from</span> <span class="nn">.cluster</span> <span class="kn">import</span> <span class="n">Kluster</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">tintcolours</span> <span class="k">as</span> <span class="n">tcols</span>
<span class="kn">from</span> <span class="nn">ephysiopy.ephys_generic.gridcell</span> <span class="kn">import</span> <span class="n">SAC</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1</span> <span class="kn">import</span> <span class="n">ImageGrid</span>
<span class="kn">import</span> <span class="nn">skimage</span><span class="o">,</span> <span class="nn">skimage.morphology</span><span class="o">,</span> <span class="nn">skimage.feature</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>

<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span>
						<span class="n">message</span><span class="o">=</span><span class="s2">&quot;divide by zero encountered in int_scalars&quot;</span><span class="p">)</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span>
						<span class="n">message</span><span class="o">=</span><span class="s2">&quot;divide by zero encountered in divide&quot;</span><span class="p">)</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span>
						<span class="n">message</span><span class="o">=</span><span class="s2">&quot;invalid value encountered in divide&quot;</span><span class="p">)</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span>
						<span class="n">message</span><span class="o">=</span><span class="s2">&quot;Casting complex values to real discards the imaginary part&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Trial"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial">[docs]</a><span class="k">class</span> <span class="nc">Trial</span><span class="p">(</span><span class="n">axonaIO</span><span class="o">.</span><span class="n">IO</span><span class="p">,</span> <span class="n">SAC</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	Provides methods to plot electrophysiology data acquired using the Axona DACQ recording system</span>
<span class="sd">	and methods to extract some measures from that data</span>

<span class="sd">	The actual loading of the data is done lazily i.e. only when you ask for</span>
<span class="sd">	position data (say plotting the path the animal took in the trial) is the</span>
<span class="sd">	position data actually loaded. The class also uses as attibutes several</span>
<span class="sd">	instances of subpackages (binning.Ratemap for example) so that the code</span>
<span class="sd">	could be made more modular.</span>

<span class="sd">	Parameters</span>
<span class="sd">	----------</span>
<span class="sd">	filename_root : str</span>
<span class="sd">		Absolute location on the filesystem of the set of files without a suffix</span>

<span class="sd">	Attributes:</span>
<span class="sd">		filename_root : str</span>
<span class="sd">			Absolute location on the filesystem of the set of files without a suffix</span>
<span class="sd">		basename : str</span>
<span class="sd">			Basename of the set of files without a suffix (everything after the last trailing slash)</span>
<span class="sd">		EEG : dacq2py.axonaIO.EEG </span>
<span class="sd">			Containing data from .eeg file</span>
<span class="sd">		EGF : dacq2py.axonaIO.EEG </span>
<span class="sd">			Containing data from .egf file</span>
<span class="sd">		STM : dacq2py.axonaIO.Stim </span>
<span class="sd">			Contains stimulation data (timestamps mostly) and header + some additions work done below</span>
<span class="sd">		POS : dacq2py.axonaIO.Pos </span>
<span class="sd">			Contains raw and post-processed position data (xy, dir, speed etc) &amp; header</span>
<span class="sd">		TETRODE : extension of Pythons dict &quot;</span>
<span class="sd">			Each value is an instance of dacq2py.axonaIO.Tetrode. Contains</span>
<span class="sd">			methods to get cluster spike times, cluster indices etc</span>
<span class="sd">		posFilter : dict</span>
<span class="sd">			Keys are things like &#39;speed&#39;, &#39;time&#39;; values are n x 2 arrays of range of values *to keep*</span>
<span class="sd">		setheader : dict</span>
<span class="sd">			Corresponds to the .set file for the file set. Keys/ values are all strings</span>
<span class="sd">		_available_files : list</span>
<span class="sd">			All files matching the filename_root + any valid suffix</span>
<span class="sd">		metadata : OrderedDict</span>
<span class="sd">			Some basic info if the file is an *rh one (see _parseMetaData)</span>
<span class="sd">		ratemap : dacq2py.binning.Ratemap class instance</span>

<span class="sd">	See Also</span>
<span class="sd">	--------</span>
<span class="sd">	binning</span>
<span class="sd">		Basic binning of data, calculation of bin sizes etc</span>
<span class="sd">	eegcalcs</span>
<span class="sd">		Contains filters, eeg power spectra methods</span>
<span class="sd">	spikecalcs</span>
<span class="sd">		Temporal measures of spike trains (firing rates etc) and extracting</span>
<span class="sd">		parameters from the waveforms and clusters themselves</span>
<span class="sd">	fieldcalcs</span>
<span class="sd">		Methods for extracting information from 2D ratemaps mostly but also</span>
<span class="sd">		contains some statistical tools (information theoretic measures etc)</span>
<span class="sd">	gridcellTrial</span>
<span class="sd">		Trial inherits from this at the moment. Includes methods for obtaining</span>
<span class="sd">		the spatial autocorrelogram (SAC) (and cross-correlogram) and plotting of the</span>
<span class="sd">		SAC</span>

<span class="sd">	Examples</span>
<span class="sd">	--------</span>
<span class="sd">	&gt;&gt;&gt; from dacq2py.dacq2py_util import Trial</span>
<span class="sd">	&gt;&gt;&gt; T = Trial(r&#39;/media/robin/data/Dropbox/Science/Recordings/M851/M851_140908t1rh&#39;)</span>

<span class="sd">	&#39;&#39;&#39;</span>

	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename_root</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		filename_root: str</span>
<span class="sd">			The absolute filename without any suffix attached</span>
<span class="sd">			i.e. C:\\\Robin\\\mytrial</span>

<span class="sd">			Note that when RH is using this can be just the trial name as the getFullFile method</span>
<span class="sd">			tries to find the trial given the folder layout and the filename - see that method</span>
<span class="sd">			for details</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		T : object</span>
<span class="sd">			a dacq2py_util.Trial object</span>

<span class="sd">		Examples</span>
<span class="sd">		--------</span>
<span class="sd">		&gt;&gt;&gt; T = dacq2py_util.Trial(r&#39;/media/robin/data/Dropbox/Science/Recordings/M851/M851_140908t1rh&#39;)</span>
<span class="sd">		&quot;&quot;&quot;</span>

		<span class="c1"># try and intelligently get full filename from just the root</span>
		<span class="n">filename_root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFullFile</span><span class="p">(</span><span class="n">filename_root</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">basename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">filename_root</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span> <span class="o">=</span> <span class="n">filename_root</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_EEG</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_EGF</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_STM</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_POS</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="k">if</span> <span class="s1">&#39;volts&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
			<span class="n">useVolts</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;volts&#39;</span><span class="p">]</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span> <span class="o">=</span> <span class="n">TetrodeDict</span><span class="p">(</span><span class="n">filename_root</span><span class="p">,</span> <span class="n">volts</span><span class="o">=</span><span class="n">useVolts</span><span class="p">)</span>  <span class="c1"># see TETRODE class above</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span> <span class="o">=</span> <span class="n">TetrodeDict</span><span class="p">(</span><span class="n">filename_root</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_posFilter</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># a dict used to filter pos</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_setheader</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">ratemap</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1">#becomes binning.RateMap instance - see POS getter property below</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">spikecalcs</span> <span class="o">=</span> <span class="n">SpikeCalcs</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">fieldcalcs</span> <span class="o">=</span> <span class="n">FieldCalcs</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_isinteractive</span> <span class="o">=</span> <span class="mi">1</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_figNum</span> <span class="o">=</span> <span class="mi">1</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_min_spks</span> <span class="o">=</span> <span class="mi">1</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_available_files</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_getAvailableFiles</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">tetrodes</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">pos_weights</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="k">if</span> <span class="s1">&#39;cm&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">useCm</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;cm&#39;</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">useCm</span> <span class="o">=</span> <span class="kc">False</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_parseMetaData</span><span class="p">()</span>
		<span class="k">except</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Contents&#39;</span><span class="p">:</span> <span class="s1">&#39;Not an rhayman file&#39;</span><span class="p">}</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">getTsAndCs</span><span class="p">()</span>
		<span class="k">except</span><span class="p">:</span>
			<span class="k">pass</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">eeg_file</span> <span class="o">=</span> <span class="mi">1</span>

	<span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="s1">&#39;</span><span class="si">{self.__class__.__name__}</span><span class="s1">(</span><span class="si">{self.filename_root}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="Trial.hasFiles"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.hasFiles">[docs]</a>	<span class="k">def</span> <span class="nf">hasFiles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Checks for some automated yaml processing (see Dropbox/Science/Analysis/)</span>
<span class="sd">		&#39;&#39;&#39;</span>

		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axona_files</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span> <span class="o">+</span> <span class="n">i</span><span class="p">):</span>
				<span class="bp">self</span><span class="p">[</span><span class="s1">&#39;has_&#39;</span> <span class="o">+</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">=</span> <span class="kc">True</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="bp">self</span><span class="p">[</span><span class="s1">&#39;has_&#39;</span> <span class="o">+</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Trial.getFullFile"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.getFullFile">[docs]</a>	<span class="k">def</span> <span class="nf">getFullFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Used to constuct filename_root in __init__</span>

<span class="sd">		Parameters</span>
<span class="sd">		-------------</span>
<span class="sd">		filename : str</span>
<span class="sd">			The absolute path the files being analysed here without any suffix</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;/home/robin/Dropbox/Science/Recordings&#39;</span><span class="p">):</span>
			<span class="n">pname</span><span class="p">,</span> <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pname</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
				<span class="n">defaultDir</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;/home/robin/Dropbox/Science/Recordings&#39;</span>
				<span class="n">animal</span> <span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
				<span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">defaultDir</span><span class="p">,</span> <span class="n">animal</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">filename</span></div>

	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">setheader</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Returns</span>
<span class="sd">		----------</span>
<span class="sd">		self.dict: dict</span>
<span class="sd">			Matches contents of .set file with keys and values all mapped as strings</span>
<span class="sd">		&#39;&#39;&#39;</span>

		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setheader</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_setheader</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span> <span class="o">+</span> <span class="s1">&#39;.set&#39;</span><span class="p">)</span>
			<span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_setheader</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setheader</span>

	<span class="nd">@setheader</span><span class="o">.</span><span class="n">setter</span>
	<span class="k">def</span> <span class="nf">setheader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_setheader</span> <span class="o">=</span> <span class="n">value</span>

	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">ppm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ppm</span>

	<span class="nd">@ppm</span><span class="o">.</span><span class="n">setter</span>
	<span class="k">def</span> <span class="nf">ppm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__ppm</span> <span class="o">=</span> <span class="n">value</span>
		<span class="c1"># Update POS</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">ppm</span> <span class="o">=</span> <span class="n">value</span>
		<span class="c1"># Update Ratemap</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">ratemap</span> <span class="o">=</span> <span class="n">binning</span><span class="o">.</span><span class="n">RateMap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">xy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">speed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_weights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">ppm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">useCm</span><span class="p">)</span>

	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">POS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Returns</span>
<span class="sd">		-----------</span>
<span class="sd">		self.POS:</span>
<span class="sd">			Contains raw and post-processed position data</span>
<span class="sd">		&#39;&#39;&#39;</span>

		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_POS</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_POS</span> <span class="o">=</span> <span class="n">axonaIO</span><span class="o">.</span><span class="n">Pos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span><span class="p">,</span> <span class="n">cm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">useCm</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_POS</span><span class="o">.</span><span class="n">postprocesspos</span><span class="p">()</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_xlims</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">.</span><span class="n">min</span><span class="p">()),</span>
							   <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_ylims</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span><span class="o">.</span><span class="n">min</span><span class="p">()),</span>
							   <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">pos_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">npos</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">pos_sample_rate</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">ratemap</span> <span class="o">=</span> <span class="n">binning</span><span class="o">.</span><span class="n">RateMap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">xy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">speed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_weights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">ppm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">useCm</span><span class="p">)</span>
			<span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_POS</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_POS</span>

	<span class="nd">@POS</span><span class="o">.</span><span class="n">setter</span>
	<span class="k">def</span> <span class="nf">POS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_POS</span> <span class="o">=</span> <span class="n">value</span>

	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">EEG</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Returns</span>
<span class="sd">		------------</span>
<span class="sd">		self.EEG:</span>
<span class="sd">			eeg data and header</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_EEG</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_EEG</span> <span class="o">=</span> <span class="n">axonaIO</span><span class="o">.</span><span class="n">EEG</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span><span class="p">,</span> <span class="n">eeg_file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eeg_file</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">pos2eegScale</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">/</span>
										<span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">pos_sample_rate</span><span class="p">)</span>
			<span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_EEG</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_EEG</span>

	<span class="nd">@EEG</span><span class="o">.</span><span class="n">setter</span>
	<span class="k">def</span> <span class="nf">EEG</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_EEG</span> <span class="o">=</span> <span class="n">value</span>

	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">EGF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Returns</span>
<span class="sd">		------------</span>
<span class="sd">		self.EGF:</span>
<span class="sd">			eeg data and header from .egf file</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_EGF</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_EGF</span> <span class="o">=</span> <span class="n">axonaIO</span><span class="o">.</span><span class="n">EEG</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span><span class="p">,</span> <span class="n">eeg_file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eeg_file</span><span class="p">,</span> <span class="n">egf</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">pos2egfScale</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">EGF</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">/</span>
										<span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">pos_sample_rate</span><span class="p">)</span>
			<span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_EGF</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_EGF</span>

	<span class="nd">@EGF</span><span class="o">.</span><span class="n">setter</span>
	<span class="k">def</span> <span class="nf">EGF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_EGF</span> <span class="o">=</span> <span class="n">value</span>

	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">STM</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Returns</span>
<span class="sd">		------------</span>
<span class="sd">		self.Stim:</span>
<span class="sd">			Stimulation data and header + some extras parsed from pos, eeg and set files</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_STM</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_STM</span> <span class="o">=</span> <span class="n">axonaIO</span><span class="o">.</span><span class="n">Stim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span><span class="p">)</span>
				<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">				update the STM dict with some relevant values from the .set file and the headers</span>
<span class="sd">				of the eeg and pos files</span>
<span class="sd">				&#39;&#39;&#39;</span>
				<span class="n">posHdr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span> <span class="o">+</span> <span class="s1">&#39;.pos&#39;</span><span class="p">)</span>
				<span class="n">eegHdr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span> <span class="o">+</span> <span class="s1">&#39;.eeg&#39;</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_STM</span><span class="p">[</span><span class="s1">&#39;posSampRate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeaderVal</span><span class="p">(</span><span class="n">posHdr</span><span class="p">,</span> <span class="s1">&#39;sample_rate&#39;</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_STM</span><span class="p">[</span><span class="s1">&#39;eegSampRate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeaderVal</span><span class="p">(</span><span class="n">eegHdr</span><span class="p">,</span> <span class="s1">&#39;sample_rate&#39;</span><span class="p">)</span>
				<span class="k">try</span><span class="p">:</span>
					<span class="n">egfHdr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span> <span class="o">+</span> <span class="s1">&#39;.egf&#39;</span><span class="p">)</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_STM</span><span class="p">[</span><span class="s1">&#39;egfSampRate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeaderVal</span><span class="p">(</span><span class="n">egfHdr</span><span class="p">,</span> <span class="s1">&#39;sample_rate&#39;</span><span class="p">)</span>
				<span class="k">except</span><span class="p">:</span>
					<span class="k">pass</span>
				<span class="n">stim_pwidth</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">setheader</span><span class="p">[</span><span class="s1">&#39;stim_pwidth&#39;</span><span class="p">])</span> <span class="o">/</span> <span class="nb">int</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span> <span class="c1"># get into ms</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_STM</span><span class="p">[</span><span class="s1">&#39;off&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_STM</span><span class="p">[</span><span class="s1">&#39;on&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">stim_pwidth</span><span class="p">)</span>
				<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">				There are a set of key / value pairs in the set file that</span>
<span class="sd">				correspond to the patterns/ protocols specified in the</span>
<span class="sd">				Stimulator menu in DACQ. Extract those items now...</span>
<span class="sd">				There are five possibe &quot;patterns&quot; that can be used in a trial. Those patterns </span>
<span class="sd">				consist of either &quot;Pause (no stimulation)&quot; or some user-defined stimulation pattern.</span>
<span class="sd">				Whether or not one of the five was used is specified in &quot;stim_patternmask_n&quot; where n </span>
<span class="sd">				is 1-5. Confusingly in dacqUSB these 5 things are called &quot;Protocols&quot; accessed from</span>
<span class="sd">				the menu Stimulator/Protocols... within that window they are actually called &quot;Phase 1&quot;,</span>
<span class="sd">				&quot;Phase 2&quot; etc. To keep everything in order it&#39;s best to iterate through using a for loop</span>
<span class="sd">				as a dict is not guaranteed to be ordered and I cba to use an OrderedDict.</span>
<span class="sd">				In dacqUSB nomencalture the pattern is actually the stimulation you </span>
<span class="sd">				want to apply i.e. 10ms pulse every 150ms or whatever. The &quot;pattern&quot; is what is applied</span>
<span class="sd">				within every Phase.</span>
<span class="sd">				&quot;&quot;&quot;</span>
				<span class="c1"># phase_info : a dict for each phase that is active</span>
				<span class="n">phase_info</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;startTime&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;duration&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;pulseWidth&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;pulsePause&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>
				<span class="n">stim_dict</span> <span class="o">=</span> <span class="p">{}</span>
				<span class="n">stim_patt_dict</span> <span class="o">=</span> <span class="p">{}</span>
				<span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">setheader</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
					<span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;stim_patternmask_&quot;</span><span class="p">):</span>
						<span class="k">if</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
							<span class="c1"># get the number of the phase</span>
							<span class="n">phase_num</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
							<span class="n">stim_dict</span><span class="p">[</span><span class="s1">&#39;Phase_&#39;</span> <span class="o">+</span> <span class="n">phase_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">phase_info</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
					<span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;stim_patt_&quot;</span><span class="p">):</span>
						<span class="n">stim_patt_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">patt_dict</span> <span class="o">=</span> <span class="n">stim_patt_dict</span>
				<span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">stim_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
					<span class="n">phase_num</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
					<span class="n">stim_dict</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;duration&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">setheader</span><span class="p">[</span><span class="s1">&#39;stim_patterntimes_&#39;</span> <span class="o">+</span> <span class="n">phase_num</span><span class="p">])</span>
					<span class="n">phase_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setheader</span><span class="p">[</span><span class="s1">&#39;stim_patternnames_&#39;</span> <span class="o">+</span> <span class="n">phase_num</span><span class="p">]</span>
					<span class="n">stim_dict</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">phase_name</span>
					<span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">phase_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;Pause&quot;</span><span class="p">)):</span>
						<span class="c1"># find the matching string in the stim_patt_dict</span>
						<span class="k">for</span> <span class="n">kk</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="n">stim_patt_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
							<span class="n">split_str</span> <span class="o">=</span> <span class="n">vv</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">)</span>
							<span class="n">patt_name</span> <span class="o">=</span> <span class="n">split_str</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
							<span class="k">if</span> <span class="p">(</span><span class="n">patt_name</span> <span class="o">==</span> <span class="n">phase_name</span><span class="p">):</span>
								<span class="n">ss</span> <span class="o">=</span> <span class="n">split_str</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
								<span class="n">stim_dict</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;pulseWidth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ss</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
								<span class="n">stim_dict</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;pulsePause&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ss</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
				<span class="c1"># make the dict ordered by Phase number</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">STM</span><span class="p">[</span><span class="s1">&#39;stim_params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">stim_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
			<span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_STM</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_STM</span>

	<span class="nd">@STM</span><span class="o">.</span><span class="n">setter</span>
	<span class="k">def</span> <span class="nf">STM</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_STM</span> <span class="o">=</span> <span class="n">value</span>

	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">posFilter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		self.posFilter : dict</span>
<span class="sd">			Keys are strings such as &#39;speed&#39;, &#39;time&#39; etc. Values are n x 2 arrays of values *to keep*</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_posFilter</span>

	<span class="nd">@posFilter</span><span class="o">.</span><span class="n">setter</span>
	<span class="k">def</span> <span class="nf">posFilter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Filters data depending on the filter specified in the dictionary value</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		value : dict</span>
<span class="sd">			Filter dict. Legal keys include: &#39;time&#39;, &#39;dir&#39;, &#39;speed&#39;, &#39;xrange&#39;,</span>
<span class="sd">			&#39;yrange&#39;. If key is &#39;time&#39;, values must be a n x 2 numpy array that </span>
<span class="sd">			specifies the times to keep in SECONDS. If key is &#39;dir&#39; values must</span>
<span class="sd">			be a two element list/ array that specifies the directions to keep</span>
<span class="sd">			in DEGREES NB the values can be singular strings of either &#39;w&#39;, </span>
<span class="sd">			&#39;e&#39;, &#39;n&#39; or &#39;s&#39; which filters for a +/-45 degree range around that</span>
<span class="sd">			cardinal direction. If key is &#39;speed&#39; values are a 2 element list/ </span>
<span class="sd">			array to keep specified in m/s. If key is &#39;xrange&#39; or &#39;yrange&#39; </span>
<span class="sd">			values are a two element list/ array that specify the x or y values</span>
<span class="sd">			to keep in PIXELS.</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		modified dacq2py_util.Trial object: object</span>
<span class="sd">			The Trial object is modified in place and all the relevant </span>
<span class="sd">			variables are filtered and changed to numpy masked arrays</span>

<span class="sd">		Examples</span>
<span class="sd">		--------</span>
<span class="sd">		&gt;&gt;&gt; import numpy as np</span>
<span class="sd">		&gt;&gt;&gt; T = dacq2py_util.Trial(r&#39;D:\M851\M851_140908t1rh&#39;)</span>
<span class="sd">		&gt;&gt;&gt; T.posFilter = {&#39;time&#39;: np.array([600,1200])}</span>
<span class="sd">		&quot;&quot;&quot;</span>

		<span class="c1"># If masked, remove all masks on all aspects of data</span>
		<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">speed</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">speed</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">nomask</span>
		<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">dir</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">dir</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">nomask</span>
		<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">xy</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">xy</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">nomask</span>
		<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">eeg</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">eeg</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">nomask</span>
		<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">EGF</span><span class="o">.</span><span class="n">eeg</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">EGF</span><span class="o">.</span><span class="n">eeg</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">nomask</span>
		<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">EEGphase</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">EEGphase</span><span class="p">):</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">EEGphase</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">nomask</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">:</span><span class="c1">#true if TETRODE dict has entries</span>
			<span class="k">for</span> <span class="n">tet</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
				<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tet</span><span class="p">]</span><span class="o">.</span><span class="n">waveforms</span><span class="p">):</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tet</span><span class="p">]</span><span class="o">.</span><span class="n">waveforms</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">nomask</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tet</span><span class="p">]</span><span class="o">.</span><span class="n">spk_ts</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">nomask</span>

		<span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">return</span>

		<span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">filterPos</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">tet</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
				<span class="n">posSamps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tet</span><span class="p">]</span><span class="o">.</span><span class="n">getPosSamples</span><span class="p">()</span>
				<span class="n">common</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">posSamps</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">idx</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
				<span class="c1"># Mask timestamps first as this is a vector, then expand</span>
				<span class="c1"># out the mask array (common)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tet</span><span class="p">]</span><span class="o">.</span><span class="n">spk_ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tet</span><span class="p">]</span><span class="o">.</span><span class="n">spk_ts</span><span class="p">)</span>
				<span class="n">common</span> <span class="o">=</span> <span class="n">common</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
				<span class="n">common</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tet</span><span class="p">]</span><span class="o">.</span><span class="n">waveforms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">common</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tet</span><span class="p">]</span><span class="o">.</span><span class="n">waveforms</span><span class="p">)</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">speed</span><span class="p">,</span><span class="mi">0</span><span class="p">)))</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">dir</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">dir</span><span class="p">,</span><span class="mi">0</span><span class="p">)))</span>
		<span class="n">posMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
		<span class="n">posMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">posMask</span><span class="p">,</span> <span class="n">posMask</span><span class="p">))</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">posMask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">xy</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">eeg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span>	<span class="bp">self</span><span class="o">.</span><span class="n">pos2eegScale</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">eeg</span><span class="p">)</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">EGF</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">EGF</span><span class="o">.</span><span class="n">eeg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos2egfScale</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">EGF</span><span class="o">.</span><span class="n">eeg</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">EEGphase</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">EEGphase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos2eegScale</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">EEGphase</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_posFilter</span> <span class="o">=</span> <span class="n">value</span>

<div class="viewcode-block" id="Trial.print_stim_dict"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.print_stim_dict">[docs]</a>	<span class="k">def</span> <span class="nf">print_stim_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Prints out keys/ values of STM dict</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">STM</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
			<span class="nb">print</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span></div>

	<span class="k">def</span> <span class="nf">_filterForStm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">laser</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Cycles through the STM dict and fiters for laser on / off periods and</span>
<span class="sd">		applies the filter to the pos and eeg data NB tetrode data not dealt with</span>
<span class="sd">		yet</span>

<span class="sd">		Parameters</span>
<span class="sd">		-------------</span>
<span class="sd">		laser : bool</span>
<span class="sd">			Whether to filter for laser stimulation events</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="n">laser</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">times</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
			<span class="n">phaseType</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">STM</span><span class="p">[</span><span class="s1">&#39;stim_params&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
				<span class="k">for</span> <span class="n">kk</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
					<span class="k">if</span> <span class="s1">&#39;duration&#39;</span> <span class="ow">in</span> <span class="n">kk</span><span class="p">:</span>
						<span class="n">times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
					<span class="k">if</span> <span class="s1">&#39;name&#39;</span> <span class="ow">in</span> <span class="n">kk</span><span class="p">:</span>
						<span class="n">phaseType</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
			<span class="n">periods</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
			<span class="n">period_bounds</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">phaseType</span><span class="p">),</span> <span class="p">[])</span>
			<span class="k">for</span> <span class="n">pk</span> <span class="ow">in</span> <span class="n">period_bounds</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
				<span class="n">bounds</span> <span class="o">=</span> <span class="p">[]</span>
				<span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">STM</span><span class="p">[</span><span class="s1">&#39;stim_params&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
					<span class="k">if</span> <span class="n">pk</span> <span class="o">==</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]:</span>
						<span class="n">idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
						<span class="n">bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">periods</span><span class="p">[</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
				<span class="n">period_bounds</span><span class="p">[</span><span class="n">pk</span><span class="p">]</span> <span class="o">=</span> <span class="n">bounds</span>

			<span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">period_bounds</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
				<span class="k">if</span> <span class="n">laser</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
					<span class="k">if</span> <span class="s1">&#39;Pause&#39;</span> <span class="ow">in</span> <span class="n">k</span><span class="p">:</span>
						<span class="bp">self</span><span class="o">.</span><span class="n">posFilter</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)}</span>
				<span class="k">elif</span> <span class="n">laser</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
					<span class="k">if</span> <span class="s1">&#39;Pause&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">k</span><span class="p">:</span>
						<span class="bp">self</span><span class="o">.</span><span class="n">posFilter</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)}</span>

	<span class="k">def</span> <span class="nf">_getAvailableFiles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_available_files</span> <span class="o">=</span> <span class="n">glob</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span> <span class="o">+</span> <span class="s1">&#39;*&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">_getMap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tetrode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cluster</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">var2bin</span><span class="o">=</span><span class="s1">&#39;pos&#39;</span><span class="p">,</span> <span class="n">binsize</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
				<span class="n">smooth_sz</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>

<span class="sd">		Returns the ratemap (smoothed or unsmoothed) for a given tetrode and</span>
<span class="sd">		cluster</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		tetrode : int</span>
<span class="sd">				 the tetrode you want to look at</span>
<span class="sd">		cluster : int, 1xn array/ list</span>
<span class="sd">				 a single number or list (or 1xn array) of the clusters to plot</span>
<span class="sd">		binsize : int, optional</span>
<span class="sd">				 size of bins. Defaults to 3</span>
<span class="sd">		smooth_sz : int</span>
<span class="sd">			the width of the smoothing kernel (see **kwargs for more)</span>
<span class="sd">		var2bin : str</span>
<span class="sd">			(Optional) Defaults to &#39;pos&#39;. Which variable to bin. Can be either</span>
<span class="sd">			&#39;pos&#39;, &#39;dir&#39; or &#39;speed&#39;. Works with masked arrays</span>
<span class="sd">		smooth : bool, optional.</span>
<span class="sd">			Defaults to true. Whether to smooth the data or not</span>
<span class="sd">		**kwargs : extra arguments include:</span>
<span class="sd">					&#39;gaussian&#39; - the smoothing kernel used is gaussian in shape</span>
<span class="sd">					not the default boxcar</span>
<span class="sd">					&#39;after&#39; - smoothing of the pos and spike maps is done after</span>
<span class="sd">					spikes are divided by pos</span>
<span class="sd">					&#39;shuffle&#39; - the time in ms by how much to shift the spikes</span>
<span class="sd">					by. Used for generated distributions for null hypothesis</span>
<span class="sd">					testing</span>

<span class="sd">		Returns</span>
<span class="sd">		-------------</span>
<span class="sd">		rmap : np.array</span>
<span class="sd">			The data binned up as requested</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="s1">&#39;pos&#39;</span> <span class="ow">in</span> <span class="n">var2bin</span><span class="p">:</span>
			<span class="n">varType</span> <span class="o">=</span> <span class="s1">&#39;xy&#39;</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">varType</span> <span class="o">=</span> <span class="n">var2bin</span>
		<span class="k">if</span> <span class="n">tetrode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">npos</span><span class="p">)</span>
			<span class="n">mapType</span> <span class="o">=</span> <span class="s1">&#39;pos&#39;</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">getClustIdx</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
			<span class="n">mapType</span> <span class="o">=</span> <span class="s1">&#39;rate&#39;</span>
		<span class="n">spk_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">npos</span><span class="p">)</span>
		<span class="k">if</span> <span class="s1">&#39;shuffle&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">spk_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">spk_weights</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;shuffle&#39;</span><span class="p">])</span> <span class="o">*</span> <span class="mi">50</span><span class="p">)</span> <span class="c1"># * 50 to go from seconds into pos_samples</span>
		<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">xy</span><span class="p">):</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="n">pos_weights</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">ratemap</span><span class="o">.</span><span class="n">pos_weights</span> <span class="o">=</span> <span class="n">pos_weights</span>
			<span class="n">spk_weights</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="c1"># Update the ratemap instance with arguments fed into this method</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">ratemap</span><span class="o">.</span><span class="n">binsize</span> <span class="o">=</span> <span class="n">binsize</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">ratemap</span><span class="o">.</span><span class="n">smooth_sz</span> <span class="o">=</span> <span class="n">smooth_sz</span>
		<span class="k">if</span> <span class="s1">&#39;cmsPerBin&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">ratemap</span><span class="o">.</span><span class="n">cmsPerBin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;cmsPerBin&#39;</span><span class="p">]</span>
		<span class="k">if</span> <span class="s1">&#39;ppm&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">ratemap</span><span class="o">.</span><span class="n">ppm</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ppm&#39;</span><span class="p">]</span>
		<span class="n">rmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratemap</span><span class="o">.</span><span class="n">getMap</span><span class="p">(</span><span class="n">spk_weights</span><span class="p">,</span> <span class="n">varType</span><span class="p">,</span> <span class="n">mapType</span><span class="p">,</span> <span class="n">smooth</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rmap</span>

	<span class="k">def</span> <span class="nf">_getPath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Returns</span>
<span class="sd">		------------</span>
<span class="sd">		self.POS.xy : np.array</span>
<span class="sd">			The smoothed xy positions filtered appropriately </span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">xy</span><span class="p">):</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">xy</span><span class="p">[:,</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">xy</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]]</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">xy</span>

	<span class="k">def</span> <span class="nf">_getDir</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Returns</span>
<span class="sd">		------------</span>
<span class="sd">		self.POS.dir : np.array</span>
<span class="sd">			The smoothed directional data filtered appropriately</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">dir</span><span class="p">):</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">dir</span><span class="p">[:,</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">dir</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]]</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">dir</span>

	<span class="k">def</span> <span class="nf">_getFieldLims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">binsize</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Returns a labelled matrix of the ratemap for a given cluster on a given</span>
<span class="sd">		tetrode. Binsize can be fractional for smaller bins. Uses anything &gt;</span>
<span class="sd">		than the half peak rate to select as a field. Data is heavily smoothed</span>

<span class="sd">		Parameters</span>
<span class="sd">		---------------</span>
<span class="sd">		tetrode : int</span>
<span class="sd">			The tetrode to examine</span>
<span class="sd">		cluster : int</span>
<span class="sd">			The cluster identity</span>

<span class="sd">		Returns</span>
<span class="sd">		----------</span>
<span class="sd">		labelled ratemap and the x and y edges of the binned data as a 3-tuple </span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">rmap</span><span class="p">,</span> <span class="p">(</span><span class="n">ye</span><span class="p">,</span> <span class="n">xe</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getMap</span><span class="p">(</span><span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">binsize</span><span class="o">=</span><span class="n">binsize</span><span class="p">)</span>
		<span class="n">rmap</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">rmap</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.0</span>
		<span class="n">h</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">rmap</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">sm_rmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratemap</span><span class="o">.</span><span class="n">blurImage</span><span class="p">(</span><span class="n">rmap</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">ftype</span><span class="o">=</span><span class="s1">&#39;gaussian&#39;</span><span class="p">)</span>
		<span class="n">thresh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">sm_rmap</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span> <span class="o">*</span> <span class="mf">0.2</span>  <span class="c1"># select area &gt; 20% of peak</span>
		<span class="c1"># do some image processing magic to get region to keep as field</span>
		<span class="n">distance</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">distance_transform_edt</span><span class="p">(</span><span class="n">sm_rmap</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">peak_local_max</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
											  <span class="n">exclude_border</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
											  <span class="n">labels</span><span class="o">=</span><span class="n">sm_rmap</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">)</span>
		<span class="n">label</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">w</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">watershed</span><span class="p">(</span><span class="o">-</span><span class="n">distance</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span>
										 <span class="n">mask</span><span class="o">=</span><span class="n">sm_rmap</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">)</span>
		<span class="n">label</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">w</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
		<span class="k">return</span> <span class="n">label</span><span class="p">,</span> <span class="n">xe</span><span class="p">,</span> <span class="n">ye</span>

	<span class="k">def</span> <span class="nf">_getClusterPhaseVals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Returns the phases of the LFP theta a given cluster fired at</span>

<span class="sd">		Parameters</span>
<span class="sd">		---------------</span>
<span class="sd">		tetrode : int</span>
<span class="sd">			The tetrode to examine</span>
<span class="sd">		cluster : int</span>
<span class="sd">			The cluster identity</span>

<span class="sd">		Returns</span>
<span class="sd">		----------</span>
<span class="sd">		eegphase : np.array</span>
<span class="sd">			The phase of theta a cluster fired at</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">getSpkTS</span><span class="p">()</span>
		<span class="n">ts</span> <span class="o">=</span> <span class="n">ts</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">timebase</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">)</span>
		<span class="n">ts_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">cut</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">thetaAmpPhase</span><span class="p">()</span>
		<span class="n">EEGphase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">EEGphase</span><span class="p">[</span><span class="n">ts_idx</span><span class="p">]</span>
		<span class="k">return</span> <span class="n">EEGphase</span>

	<span class="k">def</span> <span class="nf">_getThetaCycles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Return a tuple of indices into the EEG record that denotes the peaks</span>
<span class="sd">		and troughs of theta cycles</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">sm_eeg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">eegfilter</span><span class="p">()</span>
		<span class="n">df_eeg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">sm_eeg</span><span class="p">)</span>
		<span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">((</span><span class="n">df_eeg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">pts</span> <span class="o">=</span> <span class="p">((</span><span class="n">pts</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
		<span class="n">peaks</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="n">sm_eeg</span><span class="p">[</span><span class="n">pts</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
		<span class="n">troughs</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="n">sm_eeg</span><span class="p">[</span><span class="n">pts</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span>
		<span class="k">return</span> <span class="n">peaks</span><span class="p">,</span> <span class="n">troughs</span>

	<span class="k">def</span> <span class="nf">_getSpikeInCycle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peakIdx</span><span class="p">,</span> <span class="n">spkIdx</span><span class="p">,</span> <span class="n">whichSpk</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		given an array of spike indices into eeg and indices of peaks in the</span>
<span class="sd">		smoothed, theta-filtered eeg signal this returns the first spike in the</span>
<span class="sd">		cycle</span>
<span class="sd">		whichSpk can be &#39;first&#39; or &#39;last&#39;</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="s1">&#39;first&#39;</span> <span class="ow">in</span> <span class="n">whichSpk</span><span class="p">:</span>
			<span class="n">side</span> <span class="o">=</span> <span class="s1">&#39;left&#39;</span>
		<span class="k">elif</span> <span class="s1">&#39;last&#39;</span> <span class="ow">in</span> <span class="n">whichSpk</span><span class="p">:</span>
			<span class="n">side</span> <span class="o">=</span> <span class="s1">&#39;right&#39;</span>
		<span class="n">peaks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getThetaCycles</span><span class="p">()</span>
		<span class="n">spk2eeg_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">spkIdx</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">timebase</span> <span class="o">/</span>
					   <span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span> <span class="n">spk2eeg_idx</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="n">side</span><span class="p">)</span>
		<span class="n">_</span><span class="p">,</span> <span class="n">unique_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">spk2eeg_idx</span><span class="p">[</span><span class="n">unique_indices</span><span class="p">]</span>

	<span class="k">def</span> <span class="nf">_parseMetaData</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Parses the filename (mine has a standard format) to populate some of</span>
<span class="sd">		the objects properties (self.animal_id, self.trial_num etc)</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">pname</span><span class="p">,</span> <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;Filename&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fname</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;Path&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pname</span>
		<span class="k">if</span> <span class="s1">&#39;R&#39;</span> <span class="ow">in</span> <span class="n">fname</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;Animal&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Rat&#39;</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;Animal&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Mouse&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;Experimenter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fname</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;Animal_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fname</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">trial_date</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setheader</span><span class="p">[</span><span class="s1">&#39;trial_date&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">setheader</span><span class="p">[</span><span class="s1">&#39;trial_time&#39;</span><span class="p">]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;Trial_date&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">trial_date</span><span class="p">,</span>
														<span class="s1">&#39;%A, </span><span class="si">%d</span><span class="s1"> %b %Y:%H:%M:%S&#39;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;Trial_num&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fname</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>

	<span class="k">def</span> <span class="nf">_set_figure_title</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">tet</span><span class="p">,</span> <span class="n">clust</span><span class="p">):</span>
		<span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">set_window_title</span><span class="p">(</span><span class="s1">&#39;Tetrode: </span><span class="si">{0}</span><span class="s1"> Cluster: </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tet</span><span class="p">,</span> <span class="n">clust</span><span class="p">))</span>

	<span class="k">def</span> <span class="nf">_set_ax_title</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">tet</span><span class="p">,</span> <span class="n">clust</span><span class="p">):</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Tetrode: </span><span class="si">{0}</span><span class="se">\n</span><span class="s1">Cluster: </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tet</span><span class="p">,</span> <span class="n">clust</span><span class="p">))</span>

<div class="viewcode-block" id="Trial.klustakwik"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.klustakwik">[docs]</a>	<span class="k">def</span> <span class="nf">klustakwik</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Calls two methods below (kluster and getPC) to run klustakwik on</span>
<span class="sd">		a given tetrode with nFet number of features (for the PCA)</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		d : dict</span>
<span class="sd">			Specifies the vector of features to be used in</span>
<span class="sd">			clustering. Each key is the identity of a tetrode (i.e. 1, 2 etc)</span>
<span class="sd">			 and the values are the features used to do the clustering for that tetrode (i.e.</span>
<span class="sd">			&#39;PC1&#39;, &#39;PC2&#39;, &#39;Amp&#39; (amplitude) etc</span>
<span class="sd">		&quot;&quot;&quot;</span>

		<span class="n">legal_values</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;PC1&#39;</span><span class="p">,</span> <span class="s1">&#39;PC2&#39;</span><span class="p">,</span> <span class="s1">&#39;PC3&#39;</span><span class="p">,</span> <span class="s1">&#39;PC4&#39;</span><span class="p">,</span> <span class="s1">&#39;Amp&#39;</span><span class="p">,</span>
						<span class="s1">&#39;Vt&#39;</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;tP&#39;</span><span class="p">,</span> <span class="s1">&#39;tT&#39;</span><span class="p">,</span> <span class="s1">&#39;En&#39;</span><span class="p">,</span> <span class="s1">&#39;Ar&#39;</span><span class="p">]</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;.*(PC).*&quot;</span><span class="p">)</span>  <span class="c1"># check for number of principal comps</span>
		<span class="c1"># check for any input errors in whole dictionary first</span>
		<span class="k">for</span> <span class="n">i_tetrode</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="n">i_tetrode</span><span class="p">]:</span>
				<span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">legal_values</span><span class="p">:</span>
					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Could not find </span><span class="si">%s</span><span class="s1"> in </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">legal_values</span><span class="p">))</span>
		<span class="c1"># iterate through features and see what the max principal component is</span>
		<span class="k">for</span> <span class="n">i_tetrode</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">pcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="n">i_tetrode</span><span class="p">]</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="p">[</span><span class="n">reg</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="k">if</span> <span class="n">m</span><span class="p">]</span>
			<span class="n">waves</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">i_tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">waveforms</span>
			<span class="n">princomp</span> <span class="o">=</span> <span class="kc">None</span>
			<span class="k">if</span> <span class="n">pcs</span><span class="p">:</span>
				<span class="n">max_pc</span> <span class="o">=</span> <span class="p">[]</span>
				<span class="k">for</span> <span class="n">pc</span> <span class="ow">in</span> <span class="n">pcs</span><span class="p">:</span>
					<span class="n">max_pc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">pc</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
				<span class="n">num_pcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">max_pc</span><span class="p">)</span>  <span class="c1"># get max number of prin comps</span>
				<span class="n">princomp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">i_tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">getParam</span><span class="p">(</span><span class="n">waves</span><span class="p">,</span>
										  <span class="n">param</span><span class="o">=</span><span class="s1">&#39;PCA&#39;</span><span class="p">,</span> <span class="n">fet</span><span class="o">=</span><span class="n">num_pcs</span><span class="p">)</span>
				<span class="c1"># Rearrange the output from PCA calc to match the </span>
				<span class="c1"># number of requested principal components</span>
				<span class="n">inds2keep</span> <span class="o">=</span> <span class="p">[]</span>
				<span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">max_pc</span><span class="p">:</span>
					<span class="n">inds2keep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">((</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">))</span>
				<span class="n">inds2keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">inds2keep</span><span class="p">)</span>
				<span class="n">princomp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">princomp</span><span class="p">,</span> <span class="n">inds2keep</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="n">i_tetrode</span><span class="p">]:</span>
				<span class="k">if</span> <span class="s1">&#39;PC&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
					<span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">i_tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">getParam</span><span class="p">(</span><span class="n">waves</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="n">value</span><span class="p">))</span>
			<span class="k">if</span> <span class="n">princomp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">princomp</span><span class="p">)</span>
			<span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

			<span class="n">c</span> <span class="o">=</span> <span class="n">Kluster</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span><span class="p">,</span> <span class="n">i_tetrode</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
			<span class="n">c</span><span class="o">.</span><span class="n">make_fet</span><span class="p">()</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">get_mask</span><span class="p">()</span>
			<span class="n">c</span><span class="o">.</span><span class="n">make_fmask</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
			<span class="n">c</span><span class="o">.</span><span class="n">kluster</span><span class="p">()</span></div>

<div class="viewcode-block" id="Trial.getcoherence"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.getcoherence">[docs]</a>	<span class="k">def</span> <span class="nf">getcoherence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">binsize</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Wrapper for fieldcalcs.coherence - see docs there</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">smthd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getMap</span><span class="p">(</span><span class="n">tetrode</span><span class="o">=</span><span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="o">=</span><span class="n">cluster</span><span class="p">,</span> <span class="n">var2bin</span><span class="o">=</span><span class="s1">&#39;pos&#39;</span><span class="p">,</span>
							<span class="n">binsize</span><span class="o">=</span><span class="n">binsize</span><span class="p">,</span> <span class="n">smooth_sz</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
							<span class="n">smooth</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

		<span class="n">unsmthd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getMap</span><span class="p">(</span><span class="n">tetrode</span><span class="o">=</span><span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="o">=</span><span class="n">cluster</span><span class="p">,</span> <span class="n">var2bin</span><span class="o">=</span><span class="s1">&#39;pos&#39;</span><span class="p">,</span>
							<span class="n">binsize</span><span class="o">=</span><span class="n">binsize</span><span class="p">,</span> <span class="n">smooth_sz</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
							<span class="n">smooth</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fieldcalcs</span><span class="o">.</span><span class="n">coherence</span><span class="p">(</span><span class="n">smthd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">unsmthd</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="Trial.getkldiv"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.getkldiv">[docs]</a>	<span class="k">def</span> <span class="nf">getkldiv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">binsize</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Wrapper for fieldcalcs.kldiv - see there for explanation</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">polarMap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getMap</span><span class="p">(</span><span class="n">tetrode</span><span class="o">=</span><span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="o">=</span><span class="n">cluster</span><span class="p">,</span> <span class="n">var2bin</span><span class="o">=</span><span class="s1">&#39;dir&#39;</span><span class="p">,</span>
							<span class="n">binsize</span><span class="o">=</span><span class="n">binsize</span><span class="p">,</span> <span class="n">smooth_sz</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
							<span class="n">smooth</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fieldcalcs</span><span class="o">.</span><span class="n">kldiv_dir</span><span class="p">(</span><span class="n">polarMap</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="Trial.getmrv"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.getmrv">[docs]</a>	<span class="k">def</span> <span class="nf">getmrv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Calculate the mean resultant vector length and direction for a given</span>
<span class="sd">		cluster/ cell</span>

<span class="sd">		A wrapper for statscalcs.Statscalcs.mean_resultant_vector (see</span>
<span class="sd">		statscalcs.py)</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		tetrode : int</span>
<span class="sd">			The tetrode to exmaine</span>
<span class="sd">		cluster : int</span>
<span class="sd">			The cluster to examine</span>

<span class="sd">		Returns</span>
<span class="sd">		----------</span>
<span class="sd">		r : float</span>
<span class="sd">			the mean resultant vector length (range = 0-1)</span>
<span class="sd">		th : float</span>
<span class="sd">			the mean resultant vector direction (in radians)</span>
<span class="sd">		&#39;&#39;&#39;</span>

		<span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">getClustIdx</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
		<span class="n">angsInRads</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">dir</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
		<span class="kn">from</span> <span class="nn">statscalcs</span> <span class="kn">import</span> <span class="n">StatsCalcs</span>
		<span class="n">S</span> <span class="o">=</span> <span class="n">StatsCalcs</span><span class="p">()</span>
		<span class="n">r</span><span class="p">,</span> <span class="n">th</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">mean_resultant_vector</span><span class="p">(</span><span class="n">angsInRads</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">,</span> <span class="n">th</span></div>

<div class="viewcode-block" id="Trial.getcircR"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.getcircR">[docs]</a>	<span class="k">def</span> <span class="nf">getcircR</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Calculate the mean resultant vector length of circular data</span>
<span class="sd">		Unlike getmrv (above) this only returns the vector length. This is</span>
<span class="sd">		calculated differently (using complex numbers) but is a) faster, b)</span>
<span class="sd">		works with binned data and, c) plays nicer/ easier with shuffles of</span>
<span class="sd">		the spike train</span>

<span class="sd">		Parameters</span>
<span class="sd">		---------------</span>
<span class="sd">		tetrode : int</span>
<span class="sd">			The tetrode to exmaine</span>
<span class="sd">		cluster : int</span>
<span class="sd">			The cluster to examine</span>
<span class="sd">		**kwargs:</span>
<span class="sd">			Legal values of interest:</span>
<span class="sd">			shuffle: int</span>
<span class="sd">			the number of seconds to shift the spike train</span>

<span class="sd">		Returns</span>
<span class="sd">		----------</span>
<span class="sd">		r : float</span>
<span class="sd">			the mean resultant vector length (range = 0-1)</span>
<span class="sd">		&#39;&#39;&#39;</span>

		<span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">getClustIdx</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
		<span class="n">spk_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">npos</span><span class="p">)</span>

		<span class="k">if</span> <span class="s1">&#39;shuffle&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">spk_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">spk_weights</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;shuffle&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">50</span><span class="p">))</span>
		<span class="n">inc</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">120.0</span>
		<span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratemap</span><span class="o">.</span><span class="n">_RateMap__binData</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">dir</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="n">inc</span><span class="p">,</span> <span class="n">inc</span><span class="p">),</span> <span class="n">spk_weights</span><span class="p">)</span>
		<span class="kn">from</span> <span class="nn">statscalcs</span> <span class="kn">import</span> <span class="n">StatsCalcs</span>
		<span class="n">S</span> <span class="o">=</span> <span class="n">StatsCalcs</span><span class="p">()</span>
		<span class="n">R</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">circ_r</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">R</span></div>

<div class="viewcode-block" id="Trial.getskaggsInfo"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.getskaggsInfo">[docs]</a>	<span class="k">def</span> <span class="nf">getskaggsInfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">binsize</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Wrapper for fieldcalcs.skaggsInfo see there for docs</span>

<span class="sd">		Parameters</span>
<span class="sd">		---------------</span>
<span class="sd">		tetrode : int</span>
<span class="sd">			The tetrode to exmaine</span>
<span class="sd">		cluster : int</span>
<span class="sd">			The cluster to examine</span>
<span class="sd">		binsize : int</span>
<span class="sd">			Size of bins in cms</span>
<span class="sd">		Returns</span>
<span class="sd">		--------------</span>
<span class="sd">		bits per spike : float</span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">		binning could be over any single spatial variable (e.g. location, direction, speed).</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">ratemap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getMap</span><span class="p">(</span><span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">binsize</span><span class="o">=</span><span class="n">binsize</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">dwelltimes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getMap</span><span class="p">(</span><span class="n">binsize</span><span class="o">=</span><span class="n">binsize</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">ratemap</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">dwelltimes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratemap</span><span class="o">.</span><span class="n">_RateMap__adaptiveMap</span><span class="p">(</span><span class="n">ratemap</span><span class="p">,</span> <span class="n">dwelltimes</span><span class="p">)</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fieldcalcs</span><span class="o">.</span><span class="n">skaggsInfo</span><span class="p">(</span><span class="n">ratemap</span><span class="p">,</span> <span class="n">dwelltimes</span><span class="p">)</span></div>

<div class="viewcode-block" id="Trial.getTsAndCs"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.getTsAndCs">[docs]</a>	<span class="k">def</span> <span class="nf">getTsAndCs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Prints out the available tetrodes and clusters</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">cut_files</span> <span class="o">=</span> <span class="p">[(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">glob</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span> <span class="o">+</span> <span class="s1">&#39;*&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="s1">&#39;cut&#39;</span> <span class="ow">in</span> <span class="n">f</span><span class="p">]</span>
		<span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;(.*)_(.*).cut&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">M</span><span class="o">|</span><span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="p">)</span>
		<span class="n">tAndCdict</span> <span class="o">=</span> <span class="p">{}</span>
		<span class="k">if</span> <span class="n">cut_files</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">cut_files</span><span class="p">:</span>
				<span class="n">tet</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
				<span class="k">try</span><span class="p">:</span>
					<span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getCut</span><span class="p">(</span><span class="n">tet</span><span class="p">)</span>
					<span class="n">clusters</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
					<span class="k">if</span> <span class="n">clusters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
						<span class="n">clusters</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
						<span class="k">if</span> <span class="n">clusters</span><span class="p">:</span>
							<span class="n">tAndCdict</span><span class="p">[</span><span class="n">tet</span><span class="p">]</span> <span class="o">=</span> <span class="n">clusters</span>
					<span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
						<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Tetrode </span><span class="si">{0}</span><span class="s1"> contains clusters: </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tet</span><span class="p">,</span> <span class="n">clusters</span><span class="p">))</span>
				<span class="k">except</span><span class="p">:</span>
					<span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
						<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Tetrode</span><span class="si">{0}</span><span class="s1"> has no cut&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tet</span><span class="p">))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">pass</span>
		<span class="k">if</span> <span class="n">tAndCdict</span><span class="p">:</span>
			<span class="n">tets</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="n">clusts</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="k">for</span> <span class="n">t</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="n">tAndCdict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
				<span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
					<span class="n">tets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
					<span class="n">clusts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">cc</span><span class="p">))</span>
			<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			The two fucking stupid lines below are so yaml can</span>
<span class="sd">			serialize the object correctly</span>
<span class="sd">			&#39;&#39;&#39;</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">tetrodes</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="n">tets</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="n">clusts</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">tAndCdict</span></div>

<div class="viewcode-block" id="Trial.plotMap"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotMap">[docs]</a>	<span class="k">def</span> <span class="nf">plotMap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">var2bin</span><span class="o">=</span><span class="s1">&#39;pos&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Plots a ratemap for a given tetrode and cluster</span>
<span class="sd">		Wrapper for _plotMap() so multiple clusters can be plotted</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		tetrode : int</span>
<span class="sd">				 the tetrode you want to look at</span>
<span class="sd">		cluster : int, 1xn array/ list</span>
<span class="sd">				 a single number or list (or 1xn array) of the clusters to plot</span>
<span class="sd">		ax : optional, defaults to None. Which axis to add the plot to; if None</span>
<span class="sd">					then a new figure window is produced</span>
<span class="sd">		**kwargs :</span>
<span class="sd">			extra arguments include:</span>
<span class="sd">			&#39;bar&#39; - for use with directional data to produce a polar</span>
<span class="sd">			histogram plot</span>
<span class="sd">			&#39;add_peak_rate&#39; - bool</span>
<span class="sd">			adds the peak rate (to 2 decimal places) to the figure</span>
<span class="sd">			binsize : int, optional</span>
<span class="sd">				size of bins. Defaults to 3</span>
<span class="sd">			smooth_sz : the width of the smoothing kernel (see **kwargs for more)</span>
<span class="sd">				var2bin: optional, defaults to &#39;pos&#39;. Which variable to bin.</span>
<span class="sd">				Can be either &#39;pos&#39;, &#39;dir&#39; or &#39;speed&#39;. Works with masked</span>
<span class="sd">				arrays</span>
<span class="sd">			smooth : bool, optional. Defaults to true. Whether to smooth the data or</span>
<span class="sd">				not</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		ratemap : numpy.ndarray</span>
<span class="sd">			depending on whether a directional (1d) or positional (2d) map was</span>
<span class="sd">			asked for an ndarray is returned</span>

<span class="sd">		Examples</span>
<span class="sd">		--------</span>
<span class="sd">		&gt;&gt;&gt; T = dacq2py_util.Trial(&#39;M845_141003t1rh&#39;)</span>
<span class="sd">		&gt;&gt;&gt; # Plot the ratemap for cluster 1 on tetrode 1</span>
<span class="sd">		&gt;&gt;&gt; T.plotMap(1,1)</span>
<span class="sd">		&gt;&gt;&gt; # Add the peak rate to the figure window</span>
<span class="sd">		&gt;&gt;&gt; T.plotMap(1,1,add_peak_rate=True)</span>
<span class="sd">		&gt;&gt;&gt; # Plot the polar map for same cluster</span>
<span class="sd">		&gt;&gt;&gt; T.plotMap(1,1,var2bin=&#39;dir&#39;)</span>
<span class="sd">		&gt;&gt;&gt; # Plot the unsmoothed dwell map for the trial</span>
<span class="sd">		&gt;&gt;&gt; T.plotMap(None,None,smooth=False)</span>
<span class="sd">		&quot;&quot;&quot;</span>

		<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;var2bin&#39;</span><span class="p">,</span> <span class="s1">&#39;ax&#39;</span><span class="p">,</span> <span class="s1">&#39;binsize&#39;</span><span class="p">,</span><span class="s1">&#39;smooth_sz&#39;</span><span class="p">,</span> <span class="s1">&#39;smooth&#39;</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
				<span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
			<span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;clusters&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">clusters</span><span class="p">])</span>
		<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
			<span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;clusters&#39;</span><span class="p">,</span> <span class="n">clusters</span><span class="p">)</span>
		<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
			<span class="k">if</span> <span class="s1">&#39;all&#39;</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
				<span class="n">tetDict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getTsAndCs</span><span class="p">()</span>
				<span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;clusters&#39;</span><span class="p">,</span> <span class="n">tetDict</span><span class="p">[</span><span class="n">tetrode</span><span class="p">])</span>
		<span class="n">clusters</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;clusters&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="c1">#		var2bin = getattr(self, &#39;var2bin&#39;, &#39;pos&#39;)</span>
		<span class="n">ax</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ax&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
		<span class="n">binsize</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;binsize&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">smooth_sz</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ratemap</span><span class="p">,</span> <span class="s1">&#39;smooth_sz&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
		<span class="n">smooth</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;smooth&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">ncols</span> <span class="o">=</span> <span class="mi">1</span>
			<span class="n">nrows</span> <span class="o">=</span> <span class="mi">1</span>
		<span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">):</span>
			<span class="n">ncols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span>
			<span class="n">nrows</span> <span class="o">=</span> <span class="mi">1</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">ncols</span> <span class="o">=</span> <span class="mi">5</span>
			<span class="n">nrows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span> <span class="o">/</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
			<span class="k">if</span> <span class="s1">&#39;dir&#39;</span> <span class="ow">in</span> <span class="n">var2bin</span><span class="p">:</span>
				<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="n">ncols</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;polar&#39;</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="n">ncols</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">axes_out</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">if</span> <span class="n">clusters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">axes</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">ax</span><span class="p">,</span> <span class="n">ratemap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plotMap</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">var2bin</span><span class="o">=</span><span class="n">var2bin</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
						  <span class="n">binsize</span><span class="o">=</span><span class="n">binsize</span><span class="p">,</span> <span class="n">smooth_sz</span><span class="o">=</span><span class="n">smooth_sz</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="n">smooth</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_set_ax_title</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">,</span> <span class="n">clusters</span><span class="p">)</span>
			<span class="n">axes_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">cluster</span> <span class="o">=</span> <span class="n">clusters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

			<span class="n">ax</span><span class="p">,</span> <span class="n">ratemap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plotMap</span><span class="p">(</span><span class="n">tetrode</span><span class="o">=</span><span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="o">=</span><span class="n">cluster</span><span class="p">,</span> <span class="n">var2bin</span><span class="o">=</span><span class="n">var2bin</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
					  <span class="n">binsize</span><span class="o">=</span><span class="n">binsize</span><span class="p">,</span> <span class="n">smooth_sz</span><span class="o">=</span><span class="n">smooth_sz</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="n">smooth</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
			<span class="n">axes</span> <span class="o">=</span> <span class="n">ax</span>
<span class="c1">#			# check kwargs to see if we want to add peak rate to axes</span>
			<span class="k">if</span> <span class="s2">&quot;add_peak_rate&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;add_peak_rate&#39;</span><span class="p">]:</span>
					<span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ratemap</span><span class="p">)),</span> <span class="p">(</span><span class="mf">0.9</span><span class="p">,</span><span class="mf">0.15</span><span class="p">),</span> \
							<span class="n">xycoords</span><span class="o">=</span><span class="s1">&#39;figure fraction&#39;</span><span class="p">,</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;figure fraction&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>


			<span class="bp">self</span><span class="o">.</span><span class="n">_set_ax_title</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">)</span>
			<span class="n">axes_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">fig</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
			<span class="n">fig</span><span class="o">.</span><span class="n">set_frameon</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
			<span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">(),</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
			<span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yticklabels</span><span class="p">(),</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
			<span class="k">for</span> <span class="n">iax</span><span class="p">,</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">clusters</span><span class="p">):</span>
				<span class="n">inax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="n">ncols</span><span class="p">,</span> <span class="n">iax</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
				<span class="n">ax</span><span class="p">,</span> <span class="n">ratemap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plotMap</span><span class="p">(</span><span class="n">tetrode</span><span class="o">=</span><span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="o">=</span><span class="n">cluster</span><span class="p">,</span> <span class="n">var2bin</span><span class="o">=</span><span class="n">var2bin</span><span class="p">,</span>
							  <span class="n">binsize</span><span class="o">=</span><span class="n">binsize</span><span class="p">,</span> <span class="n">smooth_sz</span><span class="o">=</span><span class="n">smooth_sz</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="n">smooth</span><span class="p">,</span>
							  <span class="n">ax</span><span class="o">=</span><span class="n">inax</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_set_ax_title</span><span class="p">(</span><span class="n">inax</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">)</span>
				<span class="n">axes_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">axes_out</span></div>

	<span class="k">def</span> <span class="nf">_plotMap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tetrode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cluster</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">var2bin</span><span class="o">=</span><span class="s1">&#39;pos&#39;</span><span class="p">,</span> 
				<span class="n">binsize</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">smooth_sz</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Plots a ratemap for a given tetrode and cluster</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		tetrode : int</span>
<span class="sd">			the tetrode you want to look at</span>
<span class="sd">		cluster : int, 1xn array/ list</span>
<span class="sd">			a single number or list (or 1xn array) of the clusters to plot</span>
<span class="sd">		binsize : int, optional</span>
<span class="sd">			size of bins. Defaults to 3</span>
<span class="sd">		smooth_sz : int</span>
<span class="sd">			the width of the smoothing kernel (see **kwargs for more)</span>
<span class="sd">		var2bin : optional, defaults to &#39;pos&#39;. Which variable to bin.</span>
<span class="sd">			Can be either &#39;pos&#39;, &#39;dir&#39; or &#39;speed&#39;. Works with masked arrays</span>
<span class="sd">		smooth : bool</span>
<span class="sd">			Defaults to true. Whether to smooth the data or not</span>
<span class="sd">		ax : matplotlib.axes</span>
<span class="sd">			Defaults to None. Which axis to add the plot to; if None</span>
<span class="sd">			then a new figure window is produced</span>
<span class="sd">		**kwargs : various</span>
<span class="sd">			&#39;bar&#39; - for use with directional data to produce a polar</span>
<span class="sd">			histogram plot</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		ratemap: ndarray (1d or 2d)</span>
<span class="sd">			depending on whether a directional (1d) or positional (2d) map was</span>
<span class="sd">			asked for an ndarray is returned</span>
<span class="sd">		&quot;&quot;&quot;</span>

		<span class="n">rmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getMap</span><span class="p">(</span><span class="n">tetrode</span><span class="o">=</span><span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="o">=</span><span class="n">cluster</span><span class="p">,</span> <span class="n">var2bin</span><span class="o">=</span><span class="n">var2bin</span><span class="p">,</span>
							<span class="n">binsize</span><span class="o">=</span><span class="n">binsize</span><span class="p">,</span> <span class="n">smooth_sz</span><span class="o">=</span><span class="n">smooth_sz</span><span class="p">,</span>
							<span class="n">smooth</span><span class="o">=</span><span class="n">smooth</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">rmap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="c1"># polar plot</span>
			<span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_set_figure_title</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">)</span>
				<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;polar&#39;</span><span class="p">)</span>
			<span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">rmap</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:])</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">rmap</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="s1">&#39;off&#39;</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="s1">&#39;off&#39;</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="s1">&#39;off&#39;</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="s1">&#39;off&#39;</span><span class="p">,</span> <span class="n">labelbottom</span><span class="o">=</span><span class="s1">&#39;off&#39;</span><span class="p">,</span> <span class="n">labelleft</span><span class="o">=</span><span class="s1">&#39;off&#39;</span><span class="p">,</span> <span class="n">labeltop</span><span class="o">=</span><span class="s1">&#39;off&#39;</span><span class="p">,</span> <span class="n">labelright</span><span class="o">=</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">set_rticks</span><span class="p">([])</span>
			<span class="c1"># deal with vmin/ vmax in kwargs</span>
			<span class="k">if</span> <span class="s1">&#39;vmax&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
				<span class="n">ax</span><span class="o">.</span><span class="n">set_rmax</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;vmax&#39;</span><span class="p">])</span>
			<span class="c1"># See if we should add the mean resultant vector (mrv)</span>
			<span class="k">if</span> <span class="s1">&#39;add_mrv&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
				<span class="kn">from</span> <span class="nn">statscalcs</span> <span class="kn">import</span> <span class="n">StatsCalcs</span>
				<span class="n">S</span> <span class="o">=</span> <span class="n">StatsCalcs</span><span class="p">()</span>
				<span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">getClustIdx</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
				<span class="n">angles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">dir</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
				<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;len angles: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)))</span>
				<span class="n">r</span><span class="p">,</span> <span class="n">th</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">mean_resultant_vector</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">angles</span><span class="p">))</span>
				<span class="n">ax</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
				<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;r: </span><span class="si">{}</span><span class="se">\n</span><span class="s1">th: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">th</span><span class="p">))</span>
				<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">th</span><span class="p">,</span> <span class="n">th</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">rmap</span><span class="p">[</span><span class="mi">0</span><span class="p">])],</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">set_thetagrids</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">270</span><span class="p">])</span>
			<span class="n">ratemap</span> <span class="o">=</span> <span class="n">rmap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

		<span class="k">elif</span> <span class="n">rmap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
				<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_set_figure_title</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">)</span>
			<span class="c1"># mask the ratemap where NaNs occur for plotting purposes</span>
			<span class="n">ratemap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">rmap</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">rmap</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
			<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">rmap</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">rmap</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
			<span class="c1"># deal with vmin/ vmax in kwargs</span>
			<span class="k">if</span> <span class="s1">&#39;vmax&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
				<span class="n">vmax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;vmax&#39;</span><span class="p">]</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">vmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">ratemap</span><span class="p">))</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ratemap</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">jet</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;face&#39;</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">max</span><span class="p">()])</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
			<span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">(),</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
			<span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yticklabels</span><span class="p">(),</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">get_xaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ax</span><span class="p">,</span> <span class="n">ratemap</span>

<div class="viewcode-block" id="Trial.plotPath"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotPath">[docs]</a>	<span class="k">def</span> <span class="nf">plotPath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clamp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">applyStm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Plots the animals path during a trial. Default is to limit plot range</span>
<span class="sd">		to the min/ max of x/y extent of path</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		ax : matplotlib.Axes</span>
<span class="sd">			The axes to plot into. If none a new figure window is created</span>
<span class="sd">		clamp : bool</span>
<span class="sd">			whether the axes are clamped to self._xlims and self._ylims or not</span>
<span class="sd">		applyStm : bool</span>
<span class="sd">			Whether to overlay r crosses on the path where the laser events occurred</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
			<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>
		<span class="n">fig</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
		<span class="n">xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getPath</span><span class="p">()</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mf">0.8627</span><span class="p">,</span> <span class="mf">0.8627</span><span class="p">,</span> <span class="mf">0.8627</span><span class="p">],</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">applyStm</span><span class="p">:</span>
			<span class="n">stmTS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">STM</span><span class="o">.</span><span class="n">getPosTS</span><span class="p">()</span>
			<span class="n">stmXY</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[:,</span> <span class="n">stmTS</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">stmXY</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">stmXY</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;rx&#39;</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">clamp</span><span class="p">:</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xlims</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ylims</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">label</span><span class="p">:</span>
			<span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">(),</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
			<span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yticklabels</span><span class="p">(),</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="Trial.plotSpikesOnPath"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotSpikesOnPath">[docs]</a>	<span class="k">def</span> <span class="nf">plotSpikesOnPath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clamp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Plots the spikes on the path during a trial for a particular tetrode/</span>
<span class="sd">		cluster(s)</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		tetrode: int</span>
<span class="sd">				the tetrode you want to look at</span>
<span class="sd">		cluster : int, 1xn array/ list</span>
<span class="sd">				a single number or list (or 1xn array) of the clusters to plot</span>
<span class="sd">		clamp : bool, optional</span>
<span class="sd">				whether to restrict the plot to the self._xlims and self_ylims</span>
<span class="sd">				property</span>
<span class="sd">		ax : matplotlib.Axes</span>
<span class="sd">			defaults to None. Which axis to add the plot to.</span>
<span class="sd">			If None a new figure window is produced</span>

<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
				<span class="n">clusters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">availableClusters</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">clusters</span> <span class="o">=</span> <span class="p">[</span><span class="n">clusters</span><span class="p">]</span>
		<span class="n">xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">xy</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">clust</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">clusters</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
				<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">tcols</span><span class="o">.</span><span class="n">colours</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">getClustIdx</span><span class="p">(</span><span class="n">clust</span><span class="p">)</span>
			<span class="c1"># useful to override default colour scheme for publication figures</span>
			<span class="k">if</span> <span class="s1">&#39;mec&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
				<span class="n">mec</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;mec&#39;</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">mec</span> <span class="o">=</span> <span class="n">tcols</span><span class="o">.</span><span class="n">colours</span><span class="p">[</span><span class="n">clust</span><span class="p">]</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">],</span> <span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">idx</span><span class="p">],</span> <span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">mec</span><span class="p">,</span> <span class="n">mec</span><span class="o">=</span><span class="n">mec</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">clamp</span><span class="p">:</span>
				<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xlims</span><span class="p">)</span>
				<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ylims</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>
			<span class="n">plt</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="s1">&#39;off&#39;</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="s1">&#39;off&#39;</span><span class="p">,</span>
							<span class="n">bottom</span><span class="o">=</span><span class="s1">&#39;off&#39;</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
			<span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">()</span> <span class="o">+</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_yticklabels</span><span class="p">(),</span>
					 <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="Trial.plotRaster"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotRaster">[docs]</a>	<span class="k">def</span> <span class="nf">plotRaster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">prc_max</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">ms_per_bin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">histtype</span><span class="o">=</span><span class="s1">&#39;count&#39;</span><span class="p">,</span> <span class="n">hist</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Wrapper for _plotRaster allowing multiple clusters to be plotted in</span>
<span class="sd">		separate figure windows</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		tetrode : int</span>
<span class="sd">		cluster : int</span>
<span class="sd">		dt : 2-tuple</span>
<span class="sd">			the window of time in ms to examine zeroed on the event of interest</span>
<span class="sd">			i.e. the first value will probably be negative as in the default example</span>
<span class="sd">		prc_max : float</span>
<span class="sd">			the proportion of firing the cell has to &#39;lose&#39; to count as</span>
<span class="sd">			silent; a float between 0 and 1</span>
<span class="sd">		ax - matplotlib.Axes</span>
<span class="sd">			the axes to plot into. If not provided a new figure is created</span>
<span class="sd">		ms_per_bin : int</span>
<span class="sd">			The number of milliseconds in each bin of the raster plot</span>
<span class="sd">		histtype : str</span>
<span class="sd">			either &#39;count&#39; or &#39;rate&#39; - the resulting histogram plotted above the raster plot will</span>
<span class="sd">			consist of either the counts of spikes in ms_per_bin or the mean rate</span>
<span class="sd">			in ms_per_bin</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
			<span class="n">clusters</span> <span class="o">=</span> <span class="p">[</span><span class="n">clusters</span><span class="p">]</span>
		<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
			<span class="k">if</span> <span class="s1">&#39;all&#39;</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
				<span class="n">tetDict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getTsAndCs</span><span class="p">()</span>
				<span class="n">clusters</span> <span class="o">=</span> <span class="n">tetDict</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span>
		<span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
			<span class="c1"># Calculate the stimulation ratio</span>
			<span class="n">stim_histo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRasterHist</span><span class="p">(</span><span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">hist</span><span class="o">=</span><span class="n">hist</span><span class="p">)</span>
			<span class="n">mean_stim_spikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">stim_histo</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">pre_stim_spks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mean_stim_spikes</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">50</span><span class="p">])</span>
			<span class="n">post_stim_spks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mean_stim_spikes</span><span class="p">[</span><span class="mi">50</span><span class="p">:</span><span class="mi">60</span><span class="p">])</span>
			<span class="n">ratio</span> <span class="o">=</span> <span class="p">(</span><span class="n">post_stim_spks</span><span class="o">-</span><span class="n">pre_stim_spks</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">post_stim_spks</span><span class="o">+</span><span class="n">pre_stim_spks</span><span class="p">)</span>
			<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Stimulation ratio = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ratio</span><span class="p">))</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_plotRaster</span><span class="p">(</span><span class="n">tetrode</span><span class="o">=</span><span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="o">=</span><span class="n">cluster</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span><span class="n">prc_max</span><span class="o">=</span><span class="n">prc_max</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">ms_per_bin</span><span class="o">=</span><span class="n">ms_per_bin</span><span class="p">,</span><span class="n">histtype</span><span class="o">=</span><span class="n">histtype</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ratio</span></div>

	<span class="k">def</span> <span class="nf">_plotRaster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">prc_max</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ms_per_bin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">histtype</span><span class="o">=</span><span class="s1">&#39;count&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Plots a raster plot for a specified tetrode/ cluster</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		tetrode : int</span>
<span class="sd">		cluster : int</span>
<span class="sd">		dt : 2-tuple</span>
<span class="sd">			the window of time in ms to examine zeroed on the event of interest</span>
<span class="sd">			i.e. the first value will probably be negative as in the default example</span>
<span class="sd">		prc_max : float</span>
<span class="sd">			the proportion of firing the cell has to &#39;lose&#39; to count as</span>
<span class="sd">			silent; a float between 0 and 1</span>
<span class="sd">		ax - matplotlib.Axes</span>
<span class="sd">			the axes to plot into. If not provided a new figure is created</span>
<span class="sd">		ms_per_bin : int</span>
<span class="sd">			The number of milliseconds in each bin of the raster plot</span>
<span class="sd">		histtype : str</span>
<span class="sd">			either &#39;count&#39; or &#39;rate&#39; - the resulting histogram plotted above the raster plot will</span>
<span class="sd">			consist of either the counts of spikes in ms_per_bin or the mean rate</span>
<span class="sd">			in ms_per_bin</span>
<span class="sd">		&quot;&quot;&quot;</span>

		<span class="k">if</span> <span class="s1">&#39;x1&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">x1</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;x1&#39;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">getClustTS</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
			<span class="n">x1</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">/</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">timebase</span> <span class="o">/</span> <span class="mf">1000.</span><span class="p">)</span> <span class="c1">#in ms</span>
		<span class="n">x1</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
		<span class="n">on_good</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">STM</span><span class="o">.</span><span class="n">getTS</span><span class="p">()</span>
		<span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
		<span class="n">irange</span> <span class="o">=</span> <span class="n">on_good</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
		<span class="n">dts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">irange</span><span class="p">)</span>
		<span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dts</span><span class="p">):</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">on_good</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
			<span class="n">x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
			<span class="n">y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp</span><span class="p">)))</span>
		<span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">7.0</span><span class="p">))</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_set_figure_title</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">)</span>
			<span class="n">axScatter</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">axScatter</span> <span class="o">=</span> <span class="n">ax</span>
		<span class="n">axScatter</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">rasterized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
		<span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">axScatter</span><span class="p">)</span>
		<span class="n">axScatter</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">((</span><span class="n">dt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dt</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
		<span class="n">axScatter</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">dt</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">dt</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
		<span class="n">axHistx</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;top&quot;</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="n">axScatter</span><span class="p">,</span>
									  <span class="n">transform</span><span class="o">=</span><span class="n">axScatter</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>
		<span class="n">scattTrans</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">blended_transform_factory</span><span class="p">(</span><span class="n">axScatter</span><span class="o">.</span><span class="n">transData</span><span class="p">,</span>
														  <span class="n">axScatter</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>
		<span class="n">stim_pwidth</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">setheader</span><span class="p">[</span><span class="s1">&#39;stim_pwidth&#39;</span><span class="p">])</span>
		<span class="n">axScatter</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">Rectangle</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">width</span><span class="o">=</span><span class="n">stim_pwidth</span><span class="o">/</span><span class="mf">1000.</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
							<span class="n">transform</span><span class="o">=</span><span class="n">scattTrans</span><span class="p">,</span>
							<span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">))</span>
		<span class="n">histTrans</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">blended_transform_factory</span><span class="p">(</span><span class="n">axHistx</span><span class="o">.</span><span class="n">transData</span><span class="p">,</span>
														 <span class="n">axHistx</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>
		<span class="n">axHistx</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">Rectangle</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">width</span><span class="o">=</span><span class="n">stim_pwidth</span><span class="o">/</span><span class="mf">1000.</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
						  <span class="n">transform</span><span class="o">=</span><span class="n">histTrans</span><span class="p">,</span>
						  <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">))</span>
		<span class="n">axScatter</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Laser stimulation events&#39;</span><span class="p">,</span> <span class="n">labelpad</span><span class="o">=-</span><span class="mf">18.5</span><span class="p">)</span>
		<span class="n">axScatter</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time to stimulus onset(ms)&#39;</span><span class="p">)</span>
		<span class="n">nStms</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">STM</span><span class="p">[</span><span class="s1">&#39;num_stm_samples&#39;</span><span class="p">])</span>
		<span class="n">axScatter</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nStms</span><span class="p">)</span>
		<span class="c1"># Label only the min and max of the y-axis</span>
		<span class="n">ylabels</span> <span class="o">=</span> <span class="n">axScatter</span><span class="o">.</span><span class="n">get_yticklabels</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ylabels</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
			<span class="n">ylabels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
		<span class="n">yticks</span> <span class="o">=</span> <span class="n">axScatter</span><span class="o">.</span><span class="n">get_yticklines</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">yticks</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
			<span class="n">yticks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

		<span class="n">histColor</span> <span class="o">=</span> <span class="p">[</span><span class="mi">192</span><span class="o">/</span><span class="mf">255.0</span><span class="p">,</span><span class="mi">192</span><span class="o">/</span><span class="mf">255.0</span><span class="p">,</span><span class="mi">192</span><span class="o">/</span><span class="mf">255.0</span><span class="p">]</span>
		<span class="n">histX</span> <span class="o">=</span> <span class="n">axHistx</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ms_per_bin</span><span class="p">,</span> <span class="n">ms_per_bin</span><span class="p">),</span>
							 <span class="n">color</span><span class="o">=</span><span class="n">histColor</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">rasterized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">histtype</span><span class="o">=</span><span class="s1">&#39;stepfilled&#39;</span><span class="p">)</span>
		<span class="n">vals</span> <span class="o">=</span> <span class="n">histX</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">bins</span> <span class="o">=</span> <span class="n">histX</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
		<span class="k">if</span> <span class="s1">&#39;rate&#39;</span> <span class="ow">in</span> <span class="n">histtype</span><span class="p">:</span>
			<span class="n">axHistx</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Rate&#39;</span><span class="p">)</span>
			<span class="n">mn_rate_pre_stim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">])</span>
			<span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
			<span class="n">mn_rate_post_stim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
			<span class="n">above_half_idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[(</span><span class="n">vals</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">mn_rate_pre_stim</span> <span class="o">*</span> <span class="n">prc_max</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]]</span>
			<span class="n">half_pre_rate_ms</span> <span class="o">=</span> <span class="n">bins</span><span class="p">[</span><span class="n">above_half_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">time to </span><span class="si">{0}% o</span><span class="s1">f pre-stimulus rate = </span><span class="si">{1}</span><span class="s1">ms&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">prc_max</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span> <span class="n">half_pre_rate_ms</span><span class="p">)))</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;mean pre-laser rate = </span><span class="si">{0}</span><span class="s1">Hz&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mn_rate_pre_stim</span><span class="p">))</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;mean 10ms post-laser rate = </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mn_rate_post_stim</span><span class="p">))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">axHistx</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Spike count&#39;</span><span class="p">,</span> <span class="n">labelpad</span><span class="o">=-</span><span class="mf">2.5</span><span class="p">)</span>
		<span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">axHistx</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">(),</span>
				 <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="c1"># Label only the min and max of the y-axis</span>
		<span class="n">ylabels</span> <span class="o">=</span> <span class="n">axHistx</span><span class="o">.</span><span class="n">get_yticklabels</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ylabels</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
			<span class="n">ylabels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
		<span class="n">yticks</span> <span class="o">=</span> <span class="n">axHistx</span><span class="o">.</span><span class="n">get_yticklines</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">yticks</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
			<span class="n">yticks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
		<span class="n">axHistx</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
		<span class="n">axScatter</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>

		<span class="k">return</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span>

<div class="viewcode-block" id="Trial.getRasterHist"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.getRasterHist">[docs]</a>	<span class="k">def</span> <span class="nf">getRasterHist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">hist</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Calculates the histogram of the raster of spikes during a series of events</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		tetrode : int</span>
<span class="sd">		cluster : int</span>
<span class="sd">		dt : tuple</span>
<span class="sd">			the window of time in ms to examine zeroed on the event of interest</span>
<span class="sd">			i.e. the first value will probably be negative as in the default example</span>
<span class="sd">		hist : bool</span>
<span class="sd">			not sure</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">getClustTS</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
		<span class="n">x1</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">/</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">timebase</span> <span class="o">/</span> <span class="mf">1000.</span><span class="p">)</span> <span class="c1">#in ms</span>
		<span class="n">x1</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
		<span class="n">on_good</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">STM</span><span class="o">.</span><span class="n">getTS</span><span class="p">()</span>
		<span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
		<span class="n">irange</span> <span class="o">=</span> <span class="n">on_good</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
		<span class="n">dts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">irange</span><span class="p">)</span>
		<span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dts</span><span class="p">):</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">on_good</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
			<span class="n">x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
			<span class="n">y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp</span><span class="p">)))</span>

		<span class="k">if</span> <span class="n">hist</span><span class="p">:</span>
			<span class="n">nEvents</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">STM</span><span class="p">[</span><span class="s2">&quot;num_stm_samples&quot;</span><span class="p">])</span>
			<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">dt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nEvents</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])[</span><span class="mi">0</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">dt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="nb">range</span><span class="o">=</span><span class="n">dt</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Trial.plot_event_EEG"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.plot_event_EEG">[docs]</a>	<span class="k">def</span> <span class="nf">plot_event_EEG</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eeg_type</span><span class="o">=</span><span class="s1">&#39;egf&#39;</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
					   <span class="n">evenOnsets</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Plots out the eeg record following an &#39;on&#39; event in the log file</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		eeg_type : str</span>
<span class="sd">			either &#39;eeg&#39; or &#39;egf&#39;</span>
<span class="sd">		dt : tuple</span>
<span class="sd">			time to look before and after an onset event</span>
<span class="sd">		plot : bool</span>
<span class="sd">			whether to plot the stimulus-triggered-eeg</span>
<span class="sd">		ax : matplotlib.axis</span>
<span class="sd">			will plot into this axis if supplied</span>
<span class="sd">			(new figure produced if plot is None and ax is None)</span>
<span class="sd">		evenOnsets: bool</span>
<span class="sd">			if True assume there is supposed to be an even </span>
<span class="sd">			difference between the events in the .stm file. If events are </span>
<span class="sd">			found that have an uneven difference they are thrown out.</span>
<span class="sd">			NB The difference is calculated from information gleaned from </span>
<span class="sd">			the trial.STM field. If False this is ignored.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">on_good</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">STM</span><span class="o">.</span><span class="n">getTS</span><span class="p">()</span><span class="c1">#timestamps in ms</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Check for inter-stimulus time differences to make sure that the large</span>
<span class="sd">		majority (99%) of on pulses are regularly spaced - otherwise issue a warning</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">on_good</span><span class="p">))</span>
		<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">df</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">on_good</span><span class="p">))</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;More than 1</span><span class="si">% o</span><span class="s1">f on events differ in size&#39;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
		<span class="c1">#check for abnormally large number of stim events and abort</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">on_good</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">100000</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Very large number of stimulation events. Aborting plot_event_EEG&#39;</span><span class="p">)</span>
		<span class="c1">#get the eeg data and indices to use</span>
		<span class="k">if</span> <span class="s1">&#39;egf&#39;</span> <span class="ow">in</span> <span class="n">eeg_type</span><span class="p">:</span>
			<span class="n">eeg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EGF</span><span class="o">.</span><span class="n">eeg</span>
			<span class="n">on_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">STM</span><span class="o">.</span><span class="n">getEGFIdx</span><span class="p">()</span>
			<span class="n">eeg_samps_per_ms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EGF</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">/</span> <span class="mf">1000.0</span>
		<span class="k">elif</span> <span class="s1">&#39;eeg&#39;</span> <span class="ow">in</span> <span class="n">eeg_type</span><span class="p">:</span>
			<span class="n">eeg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">eeg</span>
			<span class="n">on_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">STM</span><span class="o">.</span><span class="n">getEEGIdx</span><span class="p">()</span>
			<span class="n">eeg_samps_per_ms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">/</span> <span class="mf">1000.0</span>

		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		NB the following conditional assumes there is only one phase of the </span>
<span class="sd">		stimulation that actually contains stim events. If there is more than </span>
<span class="sd">		one then the last one will be the one used</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">on_good</span><span class="p">)</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		keep pulsePause here as used lower down to plot multiple Rectangle</span>
<span class="sd">		patches in case the dt tuple specifies a range of values higher than</span>
<span class="sd">		the pause between stimulation events</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">pulsePause</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">if</span> <span class="n">evenOnsets</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">STM</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
				<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">):</span>
					<span class="k">for</span> <span class="n">kk</span><span class="p">,</span> <span class="n">vv</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
						<span class="k">for</span> <span class="n">kkk</span><span class="p">,</span> <span class="n">vvv</span> <span class="ow">in</span> <span class="n">vv</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
							<span class="k">if</span> <span class="s1">&#39;Pause&#39;</span> <span class="ow">in</span> <span class="n">kkk</span><span class="p">:</span>
								<span class="k">if</span> <span class="n">vvv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
									<span class="n">pulsePause</span> <span class="o">=</span> <span class="n">vvv</span>
			<span class="n">pulsePause_ms</span> <span class="o">=</span> <span class="n">pulsePause</span> <span class="o">/</span> <span class="mi">1000</span><span class="c1">#this is the desired</span>
			<span class="n">unequalPausesIdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">df</span><span class="o">!=</span><span class="n">pulsePause_ms</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
			<span class="n">on_good</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">on_good</span><span class="p">,</span> <span class="n">unequalPausesIdx</span><span class="p">)</span>
			<span class="n">on_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">on_idx</span><span class="p">,</span> <span class="n">unequalPausesIdx</span><span class="p">)</span>
		<span class="n">eeg</span> <span class="o">=</span> <span class="n">eeg</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">eeg</span><span class="p">)</span>
		<span class="n">dt_eeg</span> <span class="o">=</span> <span class="n">eeg_samps_per_ms</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
		<span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dt_eeg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dt_eeg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">on_idx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">rng</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">rng</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">on_good</span><span class="p">)))</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">eeg</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">plot</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">idx</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">mn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">se</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">on_good</span><span class="p">))</span>
			<span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
				<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">dt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">mn</span><span class="p">)),</span> <span class="n">mn</span> <span class="o">*</span> <span class="mf">1e6</span><span class="p">,</span>
						<span class="n">yerr</span><span class="o">=</span><span class="n">se</span><span class="o">*</span><span class="mf">1e6</span><span class="p">,</span> <span class="n">rasterized</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
			<span class="n">axTrans</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">blended_transform_factory</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">transData</span><span class="p">,</span>
														   <span class="n">ax</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>
			<span class="n">stim_pwidth</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">setheader</span><span class="p">[</span><span class="s1">&#39;stim_pwidth&#39;</span><span class="p">])</span>
			<span class="k">if</span> <span class="n">pulsePause</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
				<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pulsePause_ms</span><span class="p">)</span>
				<span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">pulsePause_ms</span><span class="p">)</span>
				<span class="n">patchStarts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)))</span>
			<span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">patchStarts</span><span class="p">:</span>
				<span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">Rectangle</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">width</span><span class="o">=</span><span class="n">stim_pwidth</span><span class="o">/</span><span class="mf">1000.</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
							 <span class="n">transform</span><span class="o">=</span><span class="n">axTrans</span><span class="p">,</span>
							 <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">))</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;LFP ($\mu$V)&#39;</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time(ms)&#39;</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="Trial.plotEventEEGRange"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotEventEEGRange">[docs]</a>	<span class="k">def</span> <span class="nf">plotEventEEGRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eeg_type</span><span class="o">=</span><span class="s1">&#39;egf&#39;</span><span class="p">,</span> <span class="n">stimTrials</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Calls plot_event_eeg with defaults and no plotting and then plots out</span>
<span class="sd">		a time period in seconds from x1 to x2 and overlays the correct time in</span>
<span class="sd">		seconds on the x-axis - meant for manual inspection of the effect of</span>
<span class="sd">		stimulation events on the eeg</span>

<span class="sd">		Parameters</span>
<span class="sd">		------------</span>
<span class="sd">		eeg_type : str</span>
<span class="sd">			either &#39;egf&#39; or &#39;eeg&#39; although probably no point</span>
<span class="sd">			using &#39;eeg&#39; as sample rate too low</span>
<span class="sd">		stimTrials : list</span>
<span class="sd">			the stimulation &#39;trial&#39; to plot, starting at 0</span>
<span class="sd">			NB stimulating every 150ms for 10ms for 20 minutes gets</span>
<span class="sd">			you 8000 trials</span>
<span class="sd">		ax : matplotlib.axis</span>
<span class="sd">			the axis to plot into. A new figure is</span>
<span class="sd">			produced if this is None</span>
<span class="sd">		&quot;&quot;&quot;</span>

		<span class="n">result</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_event_EEG</span><span class="p">(</span><span class="n">eeg_type</span><span class="o">=</span><span class="n">eeg_type</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="n">eeg_samp_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">STM</span><span class="p">[</span><span class="n">eeg_type</span> <span class="o">+</span> <span class="s1">&#39;SampRate&#39;</span><span class="p">]</span>
		<span class="n">time_ms</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">eeg_samp_rate</span> <span class="o">/</span> <span class="mf">1000.</span><span class="p">)</span>
		<span class="n">eeg_blocks</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">time_blocks</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">stimTrials</span><span class="p">:</span>
			<span class="n">eeg_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">[:,</span> <span class="n">t</span><span class="p">])</span>
			<span class="n">time_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time_ms</span><span class="p">[:,</span> <span class="n">t</span><span class="p">])</span>

		<span class="n">speed_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span> <span class="o">/</span> <span class="p">(</span><span class="n">eeg_samp_rate</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">pos_sample_rate</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
		<span class="n">speed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">speed</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">speed_idx</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">)]</span>
		<span class="n">max_speed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">speed</span><span class="p">)</span>
		<span class="n">speed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">speed</span><span class="p">,</span> <span class="n">idx</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">)</span>
		<span class="c1"># filter the eeg data in the theta and gamma bands</span>
		<span class="n">E</span> <span class="o">=</span> <span class="n">EEGCalcs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span><span class="p">)</span>
		<span class="n">eeg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EGF</span><span class="o">.</span><span class="n">eeg</span>
		<span class="n">eeg</span> <span class="o">=</span> <span class="n">eeg</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">eeg</span><span class="p">)</span>
		<span class="n">sampRate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EGF</span><span class="o">.</span><span class="n">sample_rate</span>
		<span class="n">theta_eeg</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">filterWithButter</span><span class="p">(</span><span class="n">eeg</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">sampRate</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">gamma_eeg</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">filterWithButter</span><span class="p">(</span><span class="n">eeg</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="n">sampRate</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

		<span class="n">theta</span> <span class="o">=</span> <span class="n">theta_eeg</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">)]</span>
		<span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">idx</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">)</span>
		<span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma_eeg</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">)]</span>
		<span class="n">gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">idx</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">)</span>
		<span class="c1">#dt is (-50, 150)</span>
		<span class="n">rectStart</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">eeg_samp_rate</span> <span class="o">/</span> <span class="mf">1000.</span><span class="p">)</span> <span class="o">*</span> <span class="mi">50</span><span class="p">)</span>
		<span class="n">rectEnd</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">eeg_samp_rate</span> <span class="o">/</span> <span class="mf">1000.</span><span class="p">)</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
			<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span>
		<span class="n">ax1</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">twinx</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">time_blocks</span><span class="p">,</span> <span class="n">eeg_blocks</span><span class="p">,</span> <span class="n">stimTrials</span><span class="p">):</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mf">0.8627</span><span class="p">,</span> <span class="mf">0.8627</span><span class="p">,</span> <span class="mf">0.8627</span><span class="p">])</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">theta</span><span class="p">[:,</span> <span class="n">block</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gamma</span><span class="p">[:,</span> <span class="n">block</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="s1">&#39;g&#39;</span><span class="p">)</span>
			<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">speed</span><span class="p">[:,</span> <span class="n">block</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
			<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">max_speed</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span>
			<span class="n">axTrans</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">blended_transform_factory</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">transData</span><span class="p">,</span>
														   <span class="n">ax</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">rectStart</span><span class="p">]</span>
			<span class="n">j</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">rectEnd</span><span class="p">]</span> <span class="o">-</span> <span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">rectStart</span><span class="p">]</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">Rectangle</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">width</span><span class="o">=</span><span class="n">j</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
							 <span class="n">transform</span><span class="o">=</span><span class="n">axTrans</span><span class="p">,</span>
							 <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mf">41.</span><span class="o">/</span><span class="mi">256</span><span class="p">,</span> <span class="mf">161.</span><span class="o">/</span><span class="mi">256</span><span class="p">,</span> <span class="mf">230.</span><span class="o">/</span><span class="mi">256</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">))</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">time_blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
		<span class="n">ylabels</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">get_majorticklabels</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">xxx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ylabels</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
				<span class="n">xxx</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">xxx</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
		<span class="n">yticks</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">get_major_ticks</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">xxx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">yticks</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
				<span class="n">xxx</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="Trial.adjust_median_speed"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.adjust_median_speed">[docs]</a>	<span class="k">def</span> <span class="nf">adjust_median_speed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_speed</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		min_speed : float</span>
<span class="sd">		plot : bool</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">grandMedian</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">speed</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">sortedSpIdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">speed</span><span class="p">)</span>
		<span class="n">sortedSp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">speed</span><span class="p">)</span>
		<span class="n">indMedian</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">sortedSp</span> <span class="o">&gt;=</span> <span class="n">grandMedian</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">indFirstOverThresh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">sortedSp</span> <span class="o">&gt;=</span> <span class="n">min_speed</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">indLastNotNan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">sortedSp</span><span class="p">))[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">halfWidth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">indMedian</span><span class="o">-</span><span class="n">indFirstOverThresh</span><span class="p">,</span> <span class="n">indLastNotNan</span><span class="o">-</span><span class="n">indMedian</span><span class="p">])</span>
		<span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
			<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
			<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
			<span class="n">maxSp</span> <span class="o">=</span> <span class="n">sortedSp</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">indLastNotNan</span><span class="p">]</span>
			<span class="n">L</span> <span class="o">=</span> <span class="n">sortedSp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
			<span class="n">rect</span> <span class="o">=</span> <span class="n">Rectangle</span><span class="p">(</span><span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">indMedian</span><span class="o">-</span><span class="n">halfWidth</span><span class="p">),</span> <span class="n">width</span><span class="o">=</span><span class="n">maxSp</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">indMedian</span><span class="o">+</span><span class="n">halfWidth</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">rect</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sortedSp</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">indLastNotNan</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">indLastNotNan</span><span class="p">),</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Speed (cm/s)&#39;</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Cumulative number of samples&#39;</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">indLastNotNan</span> <span class="o">!=</span> <span class="n">L</span><span class="p">:</span>
				<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">maxSp</span><span class="p">),</span> <span class="p">(</span><span class="n">indLastNotNan</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">indLastNotNan</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;r-&#39;</span><span class="p">)</span>
				<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">maxSp</span><span class="p">),</span> <span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">L</span><span class="p">),</span> <span class="s1">&#39;r-&#39;</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">maxSp</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">maxSp</span><span class="p">),</span> <span class="p">(</span><span class="n">indMedian</span><span class="p">,</span> <span class="n">indMedian</span><span class="p">),</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">((</span><span class="n">grandMedian</span><span class="p">,</span> <span class="n">grandMedian</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">indMedian</span><span class="p">),</span> <span class="s1">&#39;b-&#39;</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">grandMedian</span><span class="p">,</span> <span class="n">indMedian</span><span class="p">,</span> <span class="s1">&#39;bo&#39;</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">maxSp</span><span class="p">),</span> <span class="p">(</span><span class="n">indFirstOverThresh</span><span class="p">,</span> <span class="n">indFirstOverThresh</span><span class="p">),</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">((</span><span class="n">min_speed</span><span class="p">,</span> <span class="n">min_speed</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">indFirstOverThresh</span><span class="p">),</span> <span class="s1">&#39;b--&#39;</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">min_speed</span><span class="p">,</span> <span class="n">indFirstOverThresh</span><span class="p">,</span> <span class="s1">&#39;bo&#39;</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sortedSpIdx</span><span class="p">[</span><span class="n">indMedian</span><span class="o">-</span><span class="n">halfWidth</span><span class="p">:</span><span class="n">indMedian</span><span class="o">+</span><span class="n">halfWidth</span><span class="p">]</span></div>

<div class="viewcode-block" id="Trial.plotRateVSpeed"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotRateVSpeed">[docs]</a>	<span class="k">def</span> <span class="nf">plotRateVSpeed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">minSpeed</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">maxSpeed</span> <span class="o">=</span> <span class="mf">40.0</span><span class="p">,</span> 
					   <span class="n">sigma</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nShuffles</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
					   <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">getShuffledData</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">getData</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Plots the instantaneous firing rate of a cell against running speed</span>
<span class="sd">		Also outputs a couple of measures as with Kropff et al., 2015; the</span>
<span class="sd">		Pearsons correlation and the depth of modulation (dom) - see below for</span>
<span class="sd">		details</span>

<span class="sd">		Parameters</span>
<span class="sd">		-------------------</span>
<span class="sd">		tetrode : int</span>
<span class="sd">			the tetrode to use</span>
<span class="sd">		cluster : int</span>
<span class="sd">			the cluster to use</span>
<span class="sd">		minSpeed : float</span>
<span class="sd">			speeds below this value are masked and not used</span>
<span class="sd">		maxSpeed : float</span>
<span class="sd">			speeds above this value are masked and not used</span>
<span class="sd">		sigma : float</span>
<span class="sd">			the standard deviation of the gaussian used to smooth the spike</span>
<span class="sd">			train</span>
<span class="sd">		shuffle : bool, default False</span>
<span class="sd">			Whether to calculate the significance of the speed score or not</span>
<span class="sd">			This is done by calculating the correlation between speed and</span>
<span class="sd">			the shuffled spike train for nShuffles where the shuffles are only allowed with the</span>
<span class="sd">			window (trial_start + minTime) : (trial_end - minTime). Default is</span>
<span class="sd">			30 seconds as with Kropff et al., 2015. Default False</span>
<span class="sd">		nShuffles : int</span>
<span class="sd">			How many times to perform the shuffle. Defaults to 100 as with</span>
<span class="sd">			Kropff et al., 2015</span>
<span class="sd">		plot : bool</span>
<span class="sd">			Whether to plot output or not. Defaults to False</span>
<span class="sd">		&#39;&#39;&#39;</span>

		<span class="n">speed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">speed</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
		<span class="c1"># Calculate histogram to see how much is accounted for in each bin</span>
		<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">speed</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">maxSpeed</span><span class="p">:</span>
			<span class="n">maxSpeed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">speed</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
				<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Capping speed to max in data: </span><span class="si">{:.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">maxSpeed</span><span class="p">))</span>
		<span class="n">spd_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">minSpeed</span><span class="p">,</span> <span class="n">maxSpeed</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
		<span class="c1"># Construct the mask</span>
		<span class="n">speed_filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">speed</span><span class="p">)</span>
		<span class="n">speed_filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">speed_filt</span> <span class="o">&lt;</span> <span class="n">minSpeed</span><span class="p">,</span> <span class="n">speed_filt</span><span class="p">)</span>
		<span class="n">speed_filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">speed_filt</span> <span class="o">&gt;</span> <span class="n">maxSpeed</span><span class="p">,</span> <span class="n">speed_filt</span><span class="p">)</span>
		<span class="n">spk_sm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getTimeSmoothedSpikes</span><span class="p">(</span><span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
		<span class="n">spk_sm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">spk_sm</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmask</span><span class="p">(</span><span class="n">speed_filt</span><span class="p">))</span>

		<span class="c1"># res is the basic correlation between running speed and instantaneous</span>
		<span class="c1"># firing rate</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">mstats</span><span class="o">.</span><span class="n">pearsonr</span><span class="p">(</span><span class="n">spk_sm</span><span class="p">,</span> <span class="n">speed_filt</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">shuffle</span><span class="p">:</span>
			<span class="n">duration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">npos</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">pos_sample_rate</span>
			<span class="n">shuffles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="n">duration</span><span class="o">-</span><span class="mi">30</span><span class="p">,</span> <span class="n">nShuffles</span><span class="p">)</span>
			<span class="n">shuffled_rs</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">shuffles</span><span class="p">:</span>
				<span class="n">shuffled_spks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getTimeSmoothedSpikes</span><span class="p">(</span><span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>
				<span class="n">shuffled_rs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">mstats</span><span class="o">.</span><span class="n">pearsonr</span><span class="p">(</span><span class="n">shuffled_spks</span><span class="p">,</span> <span class="n">speed_filt</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
			<span class="n">prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">.</span><span class="mi">90</span><span class="p">,</span> <span class="o">.</span><span class="mi">95</span><span class="p">,</span> <span class="o">.</span><span class="mi">99</span><span class="p">])</span>
			<span class="n">qtiles</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">mstats</span><span class="o">.</span><span class="n">mquantiles</span><span class="p">(</span><span class="n">shuffled_rs</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
				<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Running speed vs firing rate correlation (PPMC): </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
				<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The </span><span class="si">{0}</span><span class="s2"> percentiles are </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prob</span><span class="o">*</span><span class="mi">100</span><span class="p">,</span> <span class="n">qtiles</span><span class="p">))</span>
		<span class="n">spd_dig</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">speed_filt</span><span class="p">,</span> <span class="n">spd_bins</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
		<span class="n">mn_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">spk_sm</span><span class="p">[</span><span class="n">spd_dig</span><span class="o">==</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">spd_bins</span><span class="p">))])</span>
		<span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
				<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">spd_bins</span><span class="p">,</span> <span class="n">mn_rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">pos_sample_rate</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">spd_bins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">spd_bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Firing rate(Hz)&quot;</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Speed(cm/s)&quot;</span><span class="p">)</span>
			<span class="n">ylabels</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_yticklabels</span><span class="p">()</span>
			<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ylabels</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
				<span class="n">ylabels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
			<span class="n">yticks</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_yticklines</span><span class="p">()</span>
			<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">yticks</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
				<span class="n">yticks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
			<span class="n">xlabels</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">()</span>
			<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">xlabels</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
				<span class="n">xlabels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
			<span class="n">xticks</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_xticklines</span><span class="p">()</span>
			<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">xticks</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
				<span class="n">xticks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
			<span class="k">if</span> <span class="s2">&quot;add_peak_rate&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;add_peak_rate&#39;</span><span class="p">]:</span>
					<span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="p">(</span><span class="mf">0.15</span><span class="p">,</span><span class="mf">0.9</span><span class="p">),</span> \
							<span class="n">xycoords</span><span class="o">=</span><span class="s1">&#39;axes fraction&#39;</span><span class="p">,</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;axes fraction&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">getData</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">spd_bins</span><span class="p">,</span> <span class="n">mn_rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">pos_sample_rate</span>
		<span class="k">if</span> <span class="n">getShuffledData</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shuffled_rs</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Trial.plotRollingCorrRateVSpeed"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotRollingCorrRateVSpeed">[docs]</a>	<span class="k">def</span> <span class="nf">plotRollingCorrRateVSpeed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">minSpeed</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>
								  <span class="n">sigma</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Plots the rolling correlation of instantaneous firing rate of a given</span>
<span class="sd">		cell against running speed</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		tetrode : int</span>
<span class="sd">		cluster : int</span>
<span class="sd">		minSpeed : float</span>
<span class="sd">		sigma : float</span>
<span class="sd">			The width of the smoothing kernel applied to the spike train to smooth it</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">speed_filt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">speed</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
		<span class="c1">#filter for low speeds</span>
		<span class="n">lowSpeedIdx</span> <span class="o">=</span> <span class="n">speed_filt</span> <span class="o">&lt;</span> <span class="n">minSpeed</span>
		<span class="n">spk_sm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getTimeSmoothedSpikes</span><span class="p">(</span><span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
		<span class="n">windowSize</span> <span class="o">=</span> <span class="mi">50</span>
		<span class="n">runningCorr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">spk_sm</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spk_sm</span><span class="p">)):</span>
			<span class="n">runningCorr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">pearsonr</span><span class="p">(</span><span class="n">spk_sm</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">windowSize</span><span class="p">],</span>
											  <span class="n">speed_filt</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">windowSize</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">speed_filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">speed_filt</span><span class="p">,</span> <span class="n">lowSpeedIdx</span><span class="p">)</span>
		<span class="n">spk_sm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">spk_sm</span><span class="p">,</span> <span class="n">lowSpeedIdx</span><span class="p">)</span>
		<span class="c1"># mask the running correlation where there is no rate (ie the cell fails</span>
		<span class="c1"># to fire)</span>
		<span class="n">new_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">mask_or</span><span class="p">(</span><span class="n">lowSpeedIdx</span><span class="p">,</span> <span class="n">spk_sm</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
		<span class="n">runningCorr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">runningCorr</span><span class="p">,</span> <span class="n">new_mask</span><span class="p">)</span>
		<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
		<span class="n">fig</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">right</span><span class="o">=</span><span class="mf">0.75</span><span class="p">)</span>
		<span class="n">ax2</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">twinx</span><span class="p">()</span>
		<span class="n">ax3</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">twinx</span><span class="p">()</span>
		<span class="n">ax2</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">set_position</span><span class="p">((</span><span class="s2">&quot;axes&quot;</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">))</span>
		<span class="n">ax3</span><span class="o">.</span><span class="n">set_frame_on</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
		<span class="n">ax3</span><span class="o">.</span><span class="n">patch</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
			<span class="n">sp</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
		<span class="n">ax3</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

		<span class="n">p1</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">speed_filt</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
		<span class="n">p2</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">spk_sm</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
		<span class="n">p3</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax3</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">runningCorr</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">)</span>

		<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">speed_filt</span><span class="p">))</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">speed_filt</span><span class="p">))</span>
		<span class="n">ax2</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">spk_sm</span><span class="p">))</span>
		<span class="n">ax3</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

		<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Speed(cm/s)&#39;</span><span class="p">)</span>
		<span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Instantaneous firing rate(Hz)&#39;</span><span class="p">)</span>
		<span class="n">ax3</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Running correlation&#39;</span><span class="p">)</span>

		<span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">get_color</span><span class="p">())</span>
		<span class="n">ax2</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="n">p2</span><span class="o">.</span><span class="n">get_color</span><span class="p">())</span>
		<span class="n">ax3</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="n">p3</span><span class="o">.</span><span class="n">get_color</span><span class="p">())</span>

		<span class="n">tkw</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">p1</span><span class="o">.</span><span class="n">get_color</span><span class="p">(),</span> <span class="o">**</span><span class="n">tkw</span><span class="p">)</span>
		<span class="n">ax2</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">p2</span><span class="o">.</span><span class="n">get_color</span><span class="p">(),</span> <span class="o">**</span><span class="n">tkw</span><span class="p">)</span>
		<span class="n">ax3</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">p3</span><span class="o">.</span><span class="n">get_color</span><span class="p">(),</span> <span class="o">**</span><span class="n">tkw</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">tkw</span><span class="p">)</span></div>


	<span class="k">def</span> <span class="nf">_getTimeSmoothedSpikes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Returns a spike train the same length as num pos samples that has been</span>
<span class="sd">		smoothed in time with a gaussian kernel M in width and standard deviation</span>
<span class="sd">		equal to sigma</span>

<span class="sd">		Parameters</span>
<span class="sd">		--------------</span>
<span class="sd">		tetrode : int</span>
<span class="sd">			the tetrode to use</span>
<span class="sd">		cluster : int</span>
<span class="sd">			the cluster to use</span>
<span class="sd">		sigma : float</span>
<span class="sd">			the standard deviation of the gaussian used to smooth the spike</span>
<span class="sd">			train</span>
<span class="sd">		&#39;&#39;&#39;</span>

		<span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">getClustIdx</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
		<span class="n">spk_sm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spikecalcs</span><span class="o">.</span><span class="n">smoothSpikePosCount</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">npos</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">shuffle</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">spk_sm</span>

<div class="viewcode-block" id="Trial.plotFreqVSpeed"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotFreqVSpeed">[docs]</a>	<span class="k">def</span> <span class="nf">plotFreqVSpeed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">minSp</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">maxSp</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">spStep</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">laserFilter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Plots running speed vs eeg frequencies and does linear regression. Also adds position sample histogram</span>
<span class="sd">		TODO: filter out negative frequencies - do this as default in EEG class</span>
<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		minSp : int</span>
<span class="sd">			speeds below this are ignored</span>
<span class="sd">		maxSp : int</span>
<span class="sd">			speeds above this are ignored</span>
<span class="sd">		spStep : int</span>
<span class="sd">			the bin width for speed</span>
<span class="sd">		ax : matplotlib.axes</span>
<span class="sd">			the axes in which to plot</span>
<span class="sd">		laser : int or None</span>
<span class="sd">			whether to filter for laser on/ off events</span>
<span class="sd">			None means no filtering at all</span>
<span class="sd">			1 means laser is on and data is filtered for on periods</span>
<span class="sd">			0 means filter for laser off periods</span>

<span class="sd">		&#39;&#39;&#39;</span>

		<span class="n">sp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">compressed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">speed</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">laserFilter</span><span class="p">:</span>
			<span class="n">eeg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">eeg</span>
			<span class="n">EE</span> <span class="o">=</span> <span class="n">EEGCalcs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span><span class="p">,</span> <span class="n">thetaRange</span><span class="o">=</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">12</span><span class="p">])</span>
			<span class="k">if</span> <span class="s1">&#39;dip&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
				<span class="n">d</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dip&#39;</span><span class="p">]</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">d</span> <span class="o">=</span> <span class="mf">15.0</span>
			<span class="k">if</span> <span class="s1">&#39;width&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
				<span class="n">w</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">w</span> <span class="o">=</span> <span class="mf">0.125</span>
			<span class="k">if</span> <span class="s1">&#39;stimFreq&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
				<span class="n">sf</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;stimFreq&#39;</span><span class="p">]</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">sf</span> <span class="o">=</span> <span class="mf">6.66</span>
			<span class="n">fx</span> <span class="o">=</span> <span class="n">EE</span><span class="o">.</span><span class="n">filterForLaser</span><span class="p">(</span><span class="n">E</span><span class="o">=</span><span class="n">eeg</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">dip</span><span class="o">=</span><span class="n">d</span><span class="p">,</span> <span class="n">stimFreq</span><span class="o">=</span><span class="n">sf</span><span class="p">)</span><span class="c1">#filters out laser stimulation artifact</span>
			<span class="n">fxx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">eegfilter</span><span class="p">(</span><span class="n">fx</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">thetaAmpPhase</span><span class="p">(</span><span class="n">fxx</span><span class="p">)</span><span class="c1">#filters for theta</span>
			<span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">EEGinstfreq</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">EEGinstfreq</span>
			<span class="k">except</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">thetaAmpPhase</span><span class="p">()</span>
				<span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">EEGinstfreq</span>
		<span class="n">freq</span><span class="p">[</span><span class="n">freq</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
		<span class="n">sp_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">minSp</span><span class="p">,</span> <span class="n">maxSp</span><span class="p">,</span> <span class="n">spStep</span><span class="p">)</span>
		<span class="n">sp_dig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">sp_bins</span><span class="p">)</span>
		<span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">npos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">sample_rate</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">pos_sample_rate</span><span class="p">))</span>
		<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">speed</span><span class="p">):</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">speed</span><span class="p">)</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">sample_rate</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">pos_sample_rate</span><span class="p">)</span>
			<span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
		<span class="n">mn_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">mn_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">compressed</span><span class="p">(</span><span class="n">mn_freq</span><span class="p">)</span>
		<span class="n">X</span> <span class="o">=</span> <span class="p">[</span><span class="n">mn_freq</span><span class="p">[</span><span class="n">sp_dig</span><span class="o">==</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sp_bins</span><span class="p">))]</span>
		<span class="c1"># remove any nans which will screw plt.boxplots ability to calculate means</span>
		<span class="c1"># and do the boxplot correctly</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
			<span class="n">idx</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
			<span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
		<span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
			<span class="n">fig</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
			<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>
			<span class="n">fig</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
		<span class="c1"># set up some properties for the elements in the box plot</span>
		<span class="n">bprops</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.8627</span><span class="p">,</span> <span class="mf">0.8627</span><span class="p">,</span> <span class="mf">0.8627</span><span class="p">]}</span>
		<span class="n">wprops</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.8627</span><span class="p">,</span> <span class="mf">0.8627</span><span class="p">,</span> <span class="mf">0.8627</span><span class="p">]}</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">boxplot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="n">sp_bins</span><span class="p">,</span> <span class="n">boxprops</span><span class="o">=</span><span class="n">bprops</span><span class="p">,</span> <span class="n">whiskerprops</span><span class="o">=</span><span class="n">wprops</span><span class="p">)</span>
		<span class="n">medians</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">stats</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">X</span><span class="p">])</span>
		<span class="n">nan_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">medians</span><span class="p">)</span>
		<span class="n">slope</span><span class="p">,</span> <span class="n">intercept</span><span class="p">,</span> <span class="n">r_value</span><span class="p">,</span> <span class="n">p_value</span><span class="p">,</span> <span class="n">std_err</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">linregress</span><span class="p">(</span><span class="n">sp_bins</span><span class="p">[</span><span class="o">~</span><span class="n">nan_idx</span><span class="p">],</span> <span class="n">medians</span><span class="p">[</span><span class="o">~</span><span class="n">nan_idx</span><span class="p">])</span>
		<span class="n">minFreq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">medians</span><span class="p">[</span><span class="o">~</span><span class="n">nan_idx</span><span class="p">])</span> <span class="o">-</span> <span class="mf">1.0</span>
		<span class="n">maxFreq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">medians</span><span class="p">[</span><span class="o">~</span><span class="n">nan_idx</span><span class="p">])</span> <span class="o">+</span> <span class="mf">1.0</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">minFreq</span><span class="p">,</span> <span class="n">maxFreq</span><span class="p">)</span>
<span class="c1">#        ax.set_xlim(0, sp_bins[-1])</span>
<span class="c1">#		ylims = np.array(ax.get_ylim())</span>
		<span class="n">xlims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">get_xlim</span><span class="p">())</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">theilslopes</span><span class="p">(</span><span class="n">medians</span><span class="p">[</span><span class="o">~</span><span class="n">nan_idx</span><span class="p">],</span> <span class="n">sp_bins</span><span class="p">[</span><span class="o">~</span><span class="n">nan_idx</span><span class="p">],</span> <span class="mf">0.90</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="n">xlims</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">sp_bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])),</span> <span class="s1">&#39;r-&#39;</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="n">xlims</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">sp_bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])),</span> <span class="s1">&#39;r--&#39;</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="n">xlims</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">sp_bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])),</span> <span class="s1">&#39;r--&#39;</span><span class="p">)</span>
<span class="c1">#        ax.plot([0,xlims[1]], (intercept, intercept + (sp_bins[-1] * slope)), &#39;k--&#39;, lw=2)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Frequency(Hz)&#39;</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Speed (cm/s)&#39;</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Intercept: </span><span class="si">{0:.3f}</span><span class="s1">    Slope: </span><span class="si">{1:.5f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">intercept</span><span class="p">,</span> <span class="n">slope</span><span class="p">))</span>
		<span class="c1"># add the right-hand y-axis and format</span>
		<span class="n">ax1</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">twinx</span><span class="p">()</span>
		<span class="c1"># get a histogram of speed to be plotted against the right-hand y-axis</span>
		<span class="n">h</span><span class="p">,</span><span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">compressed</span><span class="p">(</span><span class="n">sp</span><span class="p">),</span> <span class="n">bins</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">sp_bins</span><span class="p">)</span><span class="o">*</span><span class="mi">10</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sp_bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
		<span class="n">ax1</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">h</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mf">0.6667</span><span class="p">,</span> <span class="mf">0.6667</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">)</span>
		<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="c1"># reduce the &#39;height&#39; of the secondary plot</span>
<span class="c1">#        ax1.set_xlim(0, sp_bins[-1]+spStep)</span>
		<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Position samples&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mf">0.6667</span><span class="p">,</span> <span class="mf">0.6667</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
		<span class="n">ax1</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_label_coords</span><span class="p">(</span><span class="mf">1.1</span><span class="p">,</span><span class="o">.</span><span class="mi">15</span><span class="p">)</span>
		<span class="n">ylabels</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">get_majorticklabels</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">xxx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ylabels</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
				<span class="n">xxx</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">xxx</span><span class="o">.</span><span class="n">set_color</span><span class="p">([</span><span class="mf">0.6667</span><span class="p">,</span> <span class="mf">0.6667</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
		<span class="n">yticks</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">get_major_ticks</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">xxx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">yticks</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
				<span class="n">xxx</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ax</span><span class="p">,</span> <span class="n">intercept</span><span class="p">,</span> <span class="n">slope</span></div>

<div class="viewcode-block" id="Trial.plotPhaseOfFiring"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotPhaseOfFiring">[docs]</a>	<span class="k">def</span> <span class="nf">plotPhaseOfFiring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Plots the phase of firing of a given cluster as a histogram</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		tetrode : int</span>
<span class="sd">		cluster : int</span>
<span class="sd">		ax : matplotlib.Axes</span>
<span class="sd">		&quot;&quot;&quot;</span>

		<span class="n">phase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getClusterPhaseVals</span><span class="p">(</span><span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
			<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">211</span><span class="p">)</span>
			<span class="n">ax2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">212</span><span class="p">)</span>
		<span class="c1"># make the plot like the Somogyi figures!</span>
		<span class="n">fig</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s1">&#39;#203C8A&#39;</span><span class="p">)</span>
		<span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">phase</span><span class="p">,</span> <span class="n">phase</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)))</span>
		<span class="n">ax2</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">phase</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">120</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">histtype</span><span class="o">=</span><span class="s1">&#39;stepfilled&#39;</span><span class="p">)</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s1">&#39;180&#39;</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">xycoords</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span>
					<span class="n">color</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">set_axis_bgcolor</span><span class="p">(</span><span class="s1">&#39;#203C8A&#39;</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
		<span class="n">ax2</span><span class="o">.</span><span class="n">set_axis_bgcolor</span><span class="p">(</span><span class="s1">&#39;#203C8A&#39;</span><span class="p">)</span>
		<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Trial.plotPhaseInField"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotPhaseInField">[docs]</a>	<span class="k">def</span> <span class="nf">plotPhaseInField</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Plots theta phase of spikes in a place field (found using _getFieldLims)</span>
<span class="sd">		as individual colours for each run through the field</span>
<span class="sd">		TODO: broken</span>
<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		tetrode : int</span>
<span class="sd">		cluster : int</span>
<span class="sd">		ax : matplotlib.Axes</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">EEG</span> <span class="o">=</span> <span class="n">EEG</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">thetaAmpPhase</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">EEGphase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">EEGphase</span><span class="p">)</span>
		<span class="n">runs_to_keep</span><span class="p">,</span> <span class="n">spk_in_run</span><span class="p">,</span> <span class="n">run_duration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFieldRuns</span><span class="p">(</span><span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span>
		<span class="k">for</span> <span class="n">spks</span> <span class="ow">in</span> <span class="n">spk_in_run</span><span class="p">:</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">spks</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">EEGphase</span><span class="p">[</span><span class="n">spks</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos2eegScale</span><span class="p">]</span><span class="o">+</span><span class="mi">180</span><span class="p">,</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39; cluster &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; on tetrode &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">tetrode</span><span class="p">))</span>
		<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

<div class="viewcode-block" id="Trial.plotSpectrogram"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotSpectrogram">[docs]</a>	<span class="k">def</span> <span class="nf">plotSpectrogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eegType</span><span class="o">=</span><span class="s1">&#39;eeg&#39;</span><span class="p">,</span> <span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">secsPerBin</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
						<span class="n">laser</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.125</span><span class="p">,</span> <span class="n">dip</span><span class="o">=</span><span class="mf">15.0</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Plots a spectrogram of the LFP of the whole trial</span>

<span class="sd">		Parameters</span>
<span class="sd">		--------------</span>
<span class="sd">		eegType : str</span>
<span class="sd">			Whether to do use .eeg file or .egf file. Defaults to eeg</span>
<span class="sd">		ymin / ymax : int</span>
<span class="sd">			Minimum/ maximum frequency (y-axis) to plot</span>
<span class="sd">		ax : matplotlib.pyplot.axis]</span>
<span class="sd">			Which axis to add the plot to. If None a new figure window is produced</span>
<span class="sd">		secsPerBin : int</span>
<span class="sd">			Size of the x-axis bins</span>
<span class="sd">		laser : bool</span>
<span class="sd">			Whether to filter the eeg for laser stimulation events</span>
<span class="sd">		width/ dip : float</span>
<span class="sd">			Parameters for Kaisser filter in eegcalcs.EEGCalcs - see there</span>
<span class="sd">			for definition</span>

<span class="sd">		Returns</span>
<span class="sd">		------------</span>
<span class="sd">		Plots the spectrogram</span>
<span class="sd">		&#39;&#39;&#39;</span>

		<span class="k">if</span> <span class="s1">&#39;eeg&#39;</span> <span class="ow">in</span> <span class="n">eegType</span><span class="p">:</span>
			<span class="n">E</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">eeg</span>
			<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">E</span><span class="p">):</span>
				<span class="n">E</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span>
			<span class="n">Fs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">sample_rate</span>
		<span class="k">elif</span> <span class="s1">&#39;egf&#39;</span> <span class="ow">in</span> <span class="n">eegType</span><span class="p">:</span>
			<span class="n">E</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EGF</span><span class="o">.</span><span class="n">eeg</span>
			<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">E</span><span class="p">):</span>
				<span class="n">E</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span>
			<span class="n">Fs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EGF</span><span class="o">.</span><span class="n">sample_rate</span>

		<span class="n">EE</span> <span class="o">=</span> <span class="n">EEGCalcs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename_root</span><span class="p">,</span><span class="n">thetaRange</span><span class="o">=</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">12</span><span class="p">])</span>
		<span class="k">if</span> <span class="n">laser</span><span class="p">:</span>
			<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">			Split the eeg into the parts where the laser is on and off</span>
<span class="sd">			and then reassemble for the spectrogram</span>
<span class="sd">			NB this assumes the laser comes on at 600s for 20 minutes</span>
<span class="sd">			and then goes off</span>
<span class="sd">			&#39;&#39;&#39;</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>

			<span class="n">mask</span><span class="p">[</span><span class="mi">600</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="n">Fs</span><span class="p">):</span><span class="mi">1800</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="n">Fs</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span>
			<span class="c1"># filter</span>
<span class="c1">#			import pdb</span>
<span class="c1">#			pdb.set_trace()</span>
			<span class="n">fx</span> <span class="o">=</span> <span class="n">EE</span><span class="o">.</span><span class="n">filterForLaser</span><span class="p">(</span><span class="n">E</span><span class="o">=</span><span class="n">E</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">],</span> <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span> <span class="n">dip</span><span class="o">=</span><span class="n">dip</span><span class="p">)</span>
			<span class="c1"># reassemble</span>
			<span class="n">Etmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
			<span class="n">Etmp</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">fx</span>
			<span class="n">Etmp</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
			<span class="n">fx</span> <span class="o">=</span> <span class="n">Etmp</span>

		<span class="k">else</span><span class="p">:</span>
			<span class="n">fx</span> <span class="o">=</span> <span class="n">E</span>
		<span class="n">nperseg</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">Fs</span> <span class="o">*</span> <span class="n">secsPerBin</span><span class="p">)</span>
		<span class="n">freqs</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">Sxx</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">spectrogram</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">Fs</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="n">nperseg</span><span class="p">)</span>
<span class="c1">#		Sxx_sm = self.ratemap.blurImage(Sxx, (secsPerBin*2)+1)</span>
		<span class="n">Sxx_sm</span> <span class="o">=</span> <span class="n">Sxx</span>
		<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">freqs</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
			<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
			<span class="n">im</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">Sxx_sm</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;face&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;RdBu&#39;</span><span class="p">,</span><span class="n">norm</span><span class="o">=</span><span class="n">colors</span><span class="o">.</span><span class="n">LogNorm</span><span class="p">())</span>
		<span class="n">im</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">Sxx_sm</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;face&#39;</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">colors</span><span class="o">.</span><span class="n">LogNorm</span><span class="p">())</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time(s)&#39;</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Frequency(Hz)&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">laser</span><span class="p">:</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="mi">600</span><span class="p">,</span><span class="n">ymin</span><span class="p">,</span><span class="n">ymax</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="mi">1800</span><span class="p">,</span><span class="n">ymin</span><span class="p">,</span><span class="n">ymax</span><span class="p">)</span>

			<span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="mi">1800</span><span class="p">,</span> <span class="mi">2400</span><span class="p">))</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="mi">600</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="mi">1800</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="mi">2400</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">Sxx</span><span class="p">,</span> <span class="n">im</span></div>

<div class="viewcode-block" id="Trial.plotEEGPower"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotEEGPower">[docs]</a>	<span class="k">def</span> <span class="nf">plotEEGPower</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">eegType</span><span class="o">=</span><span class="s1">&#39;eeg&#39;</span><span class="p">,</span> <span class="n">smthKernelSigma</span><span class="o">=</span><span class="mf">0.1875</span><span class="p">,</span>
					<span class="n">freqBand</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">12</span><span class="p">),</span> <span class="n">outsideBand</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">125</span><span class="p">),</span> <span class="n">s2nWdth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="mi">125</span><span class="p">,</span> 
					<span class="n">ymax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Plots the eeg power spectrum. Annotates graph around theta frequency band.</span>

<span class="sd">		Parameters</span>
<span class="sd">		-------------</span>
<span class="sd">		E : numpy.array</span>
<span class="sd">			(Optional) numEEGSamples sized numpy array of raw eeg signal amplitude.</span>
<span class="sd">		eegType : str</span>
<span class="sd">			(Optional) Either &#39;eeg&#39; or &#39;egf&#39;. The .eeg file type to use. Defaults to &#39;eeg&#39;</span>
<span class="sd">		smthKernelSigma : float</span>
<span class="sd">			(Optional) number of points in the output window for gaussian filtering of eeg. This</span>
<span class="sd">			value is multipled by the binsPerHz which comes from the length of the fft (derived from nextpow2 for speed).</span>
<span class="sd">		freqBand : two-tuple</span>
<span class="sd">			(Optional) the theta-band to examine.</span>
<span class="sd">		outsideBand : two-tuple</span>
<span class="sd">			(Optional): frequencies outside these values are ignored. NOT IMPLEMENTED.</span>
<span class="sd">		s2nWdth : int</span>
<span class="sd">			(Optional) Determines the width of the window to calculate the signal-to-noise ratio.</span>
<span class="sd">		xmax : int</span>
<span class="sd">			(Optional) Maximum x-value (frequency) to plot to. Defaults to 125</span>
<span class="sd">		ymax : int</span>
<span class="sd">			(Optional) Maximum y-value to plot to. Defaults to None so plots full range</span>
<span class="sd">		plot : bool</span>
<span class="sd">			(Optional) Whether to produce a plot</span>
<span class="sd">		ax : matplotlib.pyplot.axis instance</span>
<span class="sd">			(Optional) The axis to plot in to.</span>

<span class="sd">		Returns</span>
<span class="sd">		-------------</span>
<span class="sd">		ax : matplotlib.pyplot.axis instance</span>
<span class="sd">			The axis containing the plot.</span>
<span class="sd">		&#39;&#39;&#39;</span>

		<span class="k">if</span> <span class="n">E</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">if</span> <span class="s1">&#39;eeg&#39;</span> <span class="ow">in</span> <span class="n">eegType</span><span class="p">:</span>
				<span class="n">E</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">eeg</span>
				<span class="n">freqBand</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">x2</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">E</span><span class="p">):</span>
					<span class="n">E</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span>
				<span class="n">sample_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">sample_rate</span>
			<span class="k">elif</span> <span class="s1">&#39;egf&#39;</span> <span class="ow">in</span> <span class="n">eegType</span><span class="p">:</span>
				<span class="n">E</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EGF</span><span class="o">.</span><span class="n">eeg</span>
				<span class="n">freqBand</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">x2</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">E</span><span class="p">):</span>
					<span class="n">E</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span>
				<span class="n">sample_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EGF</span><span class="o">.</span><span class="n">sample_rate</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">E</span><span class="p">):</span>
				<span class="n">E</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span>
			<span class="n">sample_rate</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sample_rate&#39;</span><span class="p">]</span>
		<span class="n">nqLim</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="n">nqLim</span> <span class="o">=</span> <span class="n">sample_rate</span> <span class="o">/</span> <span class="mi">2</span>
		<span class="n">origLength</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
		<span class="n">fftLength</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">EEG</span><span class="o">.</span><span class="n">nextpow2</span><span class="p">(</span><span class="n">origLength</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
		<span class="n">freqs</span><span class="p">,</span> <span class="n">power</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">periodogram</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span> <span class="n">return_onesided</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nfft</span><span class="o">=</span><span class="n">fftLength</span><span class="p">)</span>
		<span class="n">fftHalfLength</span> <span class="o">=</span> <span class="n">fftLength</span> <span class="o">/</span> <span class="mi">2</span><span class="o">+</span><span class="mi">1</span>
		<span class="c1"># calculate the number of points in the gaussian window - gleaned from gaussian_filter1d</span>
		<span class="c1"># which lives in scipy/ndimage/filters.py</span>
		<span class="n">binsPerHz</span> <span class="o">=</span> <span class="p">(</span><span class="n">fftHalfLength</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">nqLim</span>
		<span class="n">kernelSigma</span> <span class="o">=</span> <span class="n">smthKernelSigma</span> <span class="o">*</span> <span class="n">binsPerHz</span>
		<span class="n">smthKernelWidth</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="n">kernelSigma</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
		<span class="n">gaussWin</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">smthKernelWidth</span><span class="p">,</span> <span class="n">kernelSigma</span><span class="p">)</span>
		<span class="c1"># smooth the power</span>
		<span class="n">sm_power</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">fftconvolve</span><span class="p">(</span><span class="n">power</span><span class="p">,</span> <span class="n">gaussWin</span><span class="p">,</span> <span class="s1">&#39;same&#39;</span><span class="p">)</span>
		<span class="c1"># normalize the smoothed power by the length of the fft</span>
		<span class="n">sm_power</span> <span class="o">=</span> <span class="n">sm_power</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sm_power</span><span class="p">))</span>
		<span class="c1"># calculate some metrics</span>
		<span class="n">spectrumMaskBand</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">freqs</span><span class="o">&gt;</span><span class="n">freqBand</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freqs</span><span class="o">&lt;</span><span class="n">freqBand</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="n">bandMaxPower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">sm_power</span><span class="p">[</span><span class="n">spectrumMaskBand</span><span class="p">])</span>
		<span class="n">maxBinInBand</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">sm_power</span><span class="p">[</span><span class="n">spectrumMaskBand</span><span class="p">])</span>
		<span class="n">bandFreqs</span> <span class="o">=</span> <span class="n">freqs</span><span class="p">[</span><span class="n">spectrumMaskBand</span><span class="p">]</span>
		<span class="n">freqAtBandMaxPower</span> <span class="o">=</span> <span class="n">bandFreqs</span><span class="p">[</span><span class="n">maxBinInBand</span><span class="p">]</span>
		<span class="c1"># find power in windows around peak, divide by power in rest of spectrum</span>
		<span class="c1"># to get SNR</span>
		<span class="n">spectrumMaskPeak</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">freqs</span><span class="o">&gt;</span><span class="n">freqAtBandMaxPower</span><span class="o">-</span><span class="n">s2nWdth</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">&lt;</span> <span class="n">freqAtBandMaxPower</span> <span class="o">+</span> <span class="n">s2nWdth</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
		<span class="n">snr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">sm_power</span><span class="p">[</span><span class="n">spectrumMaskPeak</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">sm_power</span><span class="p">[</span><span class="o">~</span><span class="n">spectrumMaskPeak</span><span class="p">])</span>
		<span class="c1"># collect all the following keywords into a dict for output</span>
		<span class="n">dictKeys</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;sm_power&#39;</span><span class="p">,</span><span class="s1">&#39;freqs&#39;</span><span class="p">,</span> <span class="s1">&#39;spectrumMaskPeak&#39;</span><span class="p">,</span> <span class="s1">&#39;power&#39;</span><span class="p">,</span><span class="s1">&#39;freqBand&#39;</span><span class="p">,</span>
		<span class="s1">&#39;freqAtBandMaxPower&#39;</span><span class="p">,</span> <span class="s1">&#39;bandMaxPower&#39;</span><span class="p">,</span> <span class="s1">&#39;xmax&#39;</span><span class="p">,</span> <span class="s1">&#39;ymax&#39;</span><span class="p">,</span> <span class="s1">&#39;snr&#39;</span><span class="p">,</span> <span class="s1">&#39;kernelSigma&#39;</span><span class="p">,</span> <span class="s1">&#39;binsPerHz&#39;</span><span class="p">)</span>
		<span class="n">outDict</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">dictKeys</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">thiskey</span> <span class="ow">in</span> <span class="n">outDict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">outDict</span><span class="p">[</span><span class="n">thiskey</span><span class="p">]</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()[</span><span class="n">thiskey</span><span class="p">]</span><span class="c1"># neat trick: locals is a dict that holds all locally scoped variables</span>
		<span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
				<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mf">0.8627</span><span class="p">,</span> <span class="mf">0.8627</span><span class="p">,</span> <span class="mf">0.8627</span><span class="p">])</span>
			<span class="c1"># ax.hold(1)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">sm_power</span><span class="p">)</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">Rectangle</span><span class="p">((</span><span class="n">freqBand</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">),</span> <span class="n">width</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">freqBand</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">height</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">())[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">ec</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">xmax</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">bandMaxPower</span> <span class="o">/</span> <span class="mf">0.8</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency&#39;</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Power&#39;</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="n">freqBand</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mf">0.9</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">bandMaxPower</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">freqAtBandMaxPower</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="Trial.plotClusterSpace"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotClusterSpace">[docs]</a>	<span class="k">def</span> <span class="nf">plotClusterSpace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">,</span> <span class="n">clusters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Plots the cluster space for the given tetrode</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		tetrode : int</span>
<span class="sd">			the tetrode cluster space to plot</span>
<span class="sd">		clusters : int or list or np.array</span>
<span class="sd">			the clusters to colour in</span>
<span class="sd">		ax : matplotlib.pyplot.axis</span>
<span class="sd">			the axis to plot into</span>
<span class="sd">		bins : int</span>
<span class="sd">			the number of bins to use in the histogram</span>
<span class="sd">		**kwargs :</span>
<span class="sd">			can include a param keyword for the parameter to construct the</span>
<span class="sd">			histogram from - this defaults to amplitude (&#39;Amp&#39;) but can be any</span>
<span class="sd">			valid key in the getParam method of the Tetrode class</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		fig: handle to figure window</span>
<span class="sd">		&#39;&#39;&#39;</span>

		<span class="k">if</span> <span class="n">clusters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
			<span class="n">clusters</span> <span class="o">=</span> <span class="p">[</span><span class="n">clusters</span><span class="p">]</span>  <span class="c1"># ie needs to be iterable</span>
		<span class="n">waves</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">waveforms</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">volts</span><span class="p">:</span>
			<span class="n">waves</span> <span class="o">=</span> <span class="p">(</span><span class="n">waves</span> <span class="o">*</span> <span class="mi">128</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">scaling</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
			<span class="n">waves</span> <span class="o">=</span> <span class="n">waves</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
		<span class="n">cutfile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">cut</span>

		<span class="k">if</span> <span class="n">cutfile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">cutfile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cutfile</span><span class="p">)</span>
		<span class="k">if</span> <span class="s1">&#39;param&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">param</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;param&#39;</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">param</span> <span class="o">=</span> <span class="s1">&#39;Amp&#39;</span>
		<span class="n">amps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">getParam</span><span class="p">(</span><span class="n">waves</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="n">param</span><span class="p">)</span>
		<span class="n">bad_electrodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">amps</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">cmap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">tcols</span><span class="o">.</span><span class="n">colours</span><span class="p">[</span><span class="mi">0</span><span class="p">],(</span><span class="n">bins</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
		<span class="n">cmap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">cmap</span> <span class="o">=</span> <span class="n">colors</span><span class="o">.</span><span class="n">ListedColormap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
		<span class="n">cmap</span><span class="o">.</span><span class="n">_init</span><span class="p">()</span>
		<span class="n">alpha_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cmap</span><span class="o">.</span><span class="n">N</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span>
		<span class="n">alpha_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="n">cmap</span><span class="o">.</span><span class="n">_lut</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha_vals</span>
		<span class="n">cmb</span> <span class="o">=</span> <span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span>
		<span class="k">if</span> <span class="s1">&#39;figure&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">fig</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;figure&#39;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="c1">#        fig = plt.gcf()</span>
		<span class="n">rect</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_position</span><span class="p">()</span><span class="o">.</span><span class="n">bounds</span>
		<span class="n">grid</span> <span class="o">=</span> <span class="n">ImageGrid</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">rect</span><span class="p">,</span> <span class="n">nrows_ncols</span><span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">axes_pad</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
		<span class="k">if</span> <span class="s1">&#39;Amp&#39;</span> <span class="ow">in</span> <span class="n">param</span><span class="p">:</span>
			<span class="n">myRange</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">256</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">256</span><span class="p">]]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">myRange</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cmb</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bad_electrodes</span><span class="p">:</span>
				<span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">(</span><span class="n">amps</span><span class="p">[:,</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">amps</span><span class="p">[:,</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="nb">range</span> <span class="o">=</span> <span class="n">myRange</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">)</span>
				<span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">clusters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
					<span class="k">for</span> <span class="n">thisclust</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
						<span class="k">if</span> <span class="s1">&#39;clustColour&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
							<span class="n">clustColour</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;clustColour&#39;</span><span class="p">]</span>
						<span class="k">else</span><span class="p">:</span>
							<span class="n">clustColour</span> <span class="o">=</span> <span class="n">tcols</span><span class="o">.</span><span class="n">colours</span><span class="p">[</span><span class="n">thisclust</span><span class="p">]</span>
						<span class="n">clustidx</span> <span class="o">=</span> <span class="p">(</span><span class="n">cutfile</span><span class="o">==</span><span class="n">thisclust</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
						<span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">(</span><span class="n">amps</span><span class="p">[</span><span class="n">clustidx</span><span class="p">,</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="n">amps</span><span class="p">[</span><span class="n">clustidx</span><span class="p">,</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="nb">range</span><span class="o">=</span><span class="n">myRange</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">)</span>
						<span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
						<span class="n">H</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">convolve2d</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>
						<span class="n">clustCMap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">clustColour</span><span class="p">,(</span><span class="n">bins</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
						<span class="n">clustCMap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
						<span class="n">clustCMap</span> <span class="o">=</span> <span class="n">colors</span><span class="o">.</span><span class="n">ListedColormap</span><span class="p">(</span><span class="n">clustCMap</span><span class="p">)</span>
						<span class="n">clustCMap</span><span class="o">.</span><span class="n">_init</span><span class="p">()</span>
						<span class="n">clustCMap</span><span class="o">.</span><span class="n">_lut</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha_vals</span>
						<span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">clustCMap</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
			<span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; v &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s1">&#39;small&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>
			<span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="n">bins</span><span class="p">])</span>
			<span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="n">bins</span><span class="p">])</span>
			<span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="s1">&#39;off&#39;</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="s1">&#39;off&#39;</span><span class="p">,</span>
							<span class="n">bottom</span><span class="o">=</span><span class="s1">&#39;off&#39;</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
		<span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">],</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">get_yticklabels</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">],</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">fig</span></div>

<div class="viewcode-block" id="Trial.plotXCorr"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotXCorr">[docs]</a>	<span class="k">def</span> <span class="nf">plotXCorr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Trange</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">500</span><span class="p">,</span><span class="mi">500</span><span class="p">),</span> <span class="n">bins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">annotate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Plots the temporal autocorrelogram (defaults to +/- 500ms)</span>
<span class="sd">		TODO: needs to be able to take in two tetrodes &amp; make sure Trange in ms</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		tetrode : int</span>
<span class="sd">		clusters : int or list</span>
<span class="sd">		ax : matplotlib.Axes</span>
<span class="sd">			The axes to plot into. If None a new figure window is created</span>
<span class="sd">		TRange : two-tuple</span>
<span class="sd">			The range over which to examine the events. Zero time is the occurance of the event</span>
<span class="sd">		bins : int</span>
<span class="sd">			The number of bins to assign the data to</span>
<span class="sd">		annotate : bool</span>
<span class="sd">			Whether to add the cluster identities to the figure axis</span>
<span class="sd">		**kwargs</span>
<span class="sd">			if &#39;add_peak_rate&#39; is in the kwargs then that is also added to the axes</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
			<span class="n">clusters</span> <span class="o">=</span> <span class="p">[</span><span class="n">clusters</span><span class="p">]</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tetrode</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
			<span class="n">tetrode</span> <span class="o">=</span> <span class="p">[</span><span class="n">tetrode</span><span class="p">]</span>
		<span class="n">duration</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">Trange</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">bins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">bins</span> <span class="o">=</span> <span class="mi">201</span>
		<span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
			<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">cluster_a</span> <span class="o">=</span> <span class="n">cluster_b</span> <span class="o">=</span> <span class="n">clusters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
			<span class="n">cluster_a</span> <span class="o">=</span> <span class="n">clusters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
			<span class="n">cluster_b</span> <span class="o">=</span> <span class="n">clusters</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tetrode</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">tetrode_a</span> <span class="o">=</span> <span class="n">tetrode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
			<span class="n">tetrode_b</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tetrode</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
			<span class="n">tetrode_a</span> <span class="o">=</span> <span class="n">tetrode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
			<span class="n">tetrode_b</span> <span class="o">=</span> <span class="n">tetrode</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">Trange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Trange</span><span class="p">)</span>
		<span class="n">timebase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode_a</span><span class="p">]</span><span class="o">.</span><span class="n">timebase</span>
		<span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode_a</span><span class="p">]</span><span class="o">.</span><span class="n">getClustTS</span><span class="p">(</span><span class="n">cluster_a</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">timebase</span><span class="o">/</span><span class="mi">1000</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">tetrode_b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">cluster_b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">x2</span> <span class="o">=</span> <span class="n">x1</span>
				<span class="n">cluster_b</span> <span class="o">=</span> <span class="n">cluster_a</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">x2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode_a</span><span class="p">]</span><span class="o">.</span><span class="n">getClustTS</span><span class="p">(</span><span class="n">cluster_b</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">timebase</span><span class="o">/</span><span class="mi">1000</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">x2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode_b</span><span class="p">]</span><span class="o">.</span><span class="n">getClustTS</span><span class="p">(</span><span class="n">cluster_b</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">timebase</span><span class="o">/</span><span class="mi">1000</span><span class="p">)</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">posFilter</span><span class="p">:</span>
			<span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">xy</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># indices to keep</span>
			<span class="n">x1PosSamp</span> <span class="o">=</span> <span class="p">(</span><span class="n">x1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1000</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">pos_sample_rate</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
			<span class="n">x1</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">x1PosSamp</span><span class="p">,</span> <span class="n">idx</span><span class="p">)]</span>
			<span class="k">if</span> <span class="n">cluster_b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">x2PosSamp</span> <span class="o">=</span> <span class="p">(</span><span class="n">x2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1000</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">pos_sample_rate</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
				<span class="n">x2</span> <span class="o">=</span> <span class="n">x2</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">x2PosSamp</span><span class="p">,</span> <span class="n">idx</span><span class="p">)]</span>
		<span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spikecalcs</span><span class="o">.</span><span class="n">xcorr</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">Trange</span><span class="o">=</span><span class="n">Trange</span><span class="p">)</span>
		<span class="n">h</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">Trange</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">histtype</span><span class="o">=</span><span class="s1">&#39;stepfilled&#39;</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">Trange</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">annotate</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">cluster_b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">cond_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span>
				<span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.55</span><span class="p">,</span> <span class="o">.</span><span class="mi">9</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{0:.4}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">cond_rate</span><span class="p">)),</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span>
						<span class="n">transform</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">((</span><span class="n">tetrode_a</span> <span class="o">==</span> <span class="n">tetrode_b</span><span class="p">),</span> <span class="n">tetrode_b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">cluster_a</span> <span class="o">==</span> <span class="n">cluster_b</span><span class="p">):</span>
						<span class="c1">#autocorr being done so get theta modulation</span>
						<span class="n">modIdx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spikecalcs</span><span class="o">.</span><span class="n">thetaModIdx</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
						<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Cluster </span><span class="si">{0}</span><span class="s1"> vs Cluster </span><span class="si">{1}</span><span class="se">\n</span><span class="s1">theta modulation: </span><span class="si">{2:.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cluster_a</span><span class="p">,</span> <span class="n">cluster_b</span><span class="p">,</span> <span class="n">modIdx</span><span class="p">))</span>
						<span class="k">if</span> <span class="s2">&quot;add_peak_rate&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
							<span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;add_peak_rate&#39;</span><span class="p">]:</span>
								<span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">modIdx</span><span class="p">)),</span> <span class="p">(</span><span class="mf">0.15</span><span class="p">,</span><span class="mf">0.9</span><span class="p">),</span> \
										<span class="n">xycoords</span><span class="o">=</span><span class="s1">&#39;axes fraction&#39;</span><span class="p">,</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;axes fraction&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>

	<span class="c1">#                    ax.set_title(&#39;Cluster &#39; + str(cluster_a) + &#39; vs Cluster &#39; + str(cluster_b) +&#39;\ntheta modulation=&#39; + str(modIdx))</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Cluster &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">cluster_a</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; vs Cluster &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">cluster_b</span><span class="p">))</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time(ms)&#39;</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">((</span><span class="n">Trange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Trange</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">Trange</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">Trange</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="s1">&#39;off&#39;</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="s1">&#39;off&#39;</span><span class="p">,</span>
							<span class="n">bottom</span><span class="o">=</span><span class="s1">&#39;off&#39;</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ax</span><span class="p">,</span> <span class="n">h</span></div>

<div class="viewcode-block" id="Trial.getThetaModIdx"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.getThetaModIdx">[docs]</a>	<span class="k">def</span> <span class="nf">getThetaModIdx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Calculates the theta modulation index of a clusters autocorrelogram</span>
<span class="sd">		as the difference between the first trough and second peak of the</span>
<span class="sd">		autocorrelogram (actually the difference over their sum)</span>

<span class="sd">		Parameters</span>
<span class="sd">		--------------</span>
<span class="sd">		tetrode : int</span>
<span class="sd">			The tetrode the cluster is on</span>
<span class="sd">		cluster : int</span>
<span class="sd">			The cluster identity</span>
<span class="sd">		Returns</span>
<span class="sd">		-------------</span>
<span class="sd">		thetaModulation : int</span>
<span class="sd">			The depth of theta modulation</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">getClustTS</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">timebase</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">posFilter</span><span class="p">:</span>
			<span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">xy</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># indices to keep</span>
			<span class="n">x1PosSamp</span> <span class="o">=</span> <span class="p">(</span><span class="n">x1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1000</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">pos_sample_rate</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
			<span class="n">x1</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">x1PosSamp</span><span class="p">,</span> <span class="n">idx</span><span class="p">)]</span>
		<span class="n">thetaMod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spikecalcs</span><span class="o">.</span><span class="n">thetaModIdx</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">thetaMod</span></div>

<div class="viewcode-block" id="Trial.getThetaModIdx2"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.getThetaModIdx2">[docs]</a>	<span class="k">def</span> <span class="nf">getThetaModIdx2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Wrapper for thetaModIdxV2 in spikecalcs.py</span>

<span class="sd">		Parameters</span>
<span class="sd">		--------------</span>
<span class="sd">		tetrode : int</span>
<span class="sd">			The tetrode the cluster is on</span>
<span class="sd">		cluster : int</span>
<span class="sd">			The cluster identity</span>
<span class="sd">		Returns</span>
<span class="sd">		-------------</span>
<span class="sd">		thetaModulation : int</span>
<span class="sd">			The depth of theta modulation</span>
<span class="sd">		&#39;&#39;&#39;</span>

		<span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">getClustTS</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">timebase</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">posFilter</span><span class="p">:</span>
			<span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">xy</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># indices to keep</span>
			<span class="n">x1PosSamp</span> <span class="o">=</span> <span class="p">(</span><span class="n">x1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1000</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">pos_sample_rate</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
			<span class="n">x1</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">x1PosSamp</span><span class="p">,</span> <span class="n">idx</span><span class="p">)]</span>
		<span class="n">thetaMod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spikecalcs</span><span class="o">.</span><span class="n">thetaModIdxV2</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">thetaMod</span></div>

<div class="viewcode-block" id="Trial.plotWaveforms"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotWaveforms">[docs]</a>	<span class="k">def</span> <span class="nf">plotWaveforms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Plots spike waveforms on all four wires for a given tetrode/ cluster</span>
<span class="sd">		The units for the plots are *real* in the sense that the x-axis is in</span>
<span class="sd">		ms and the y-axis is in micro-volts. The axes limits are set up so the </span>
<span class="sd">		ratio between the x and y axes is 100</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		tetrode : int</span>
<span class="sd">		clusters : int or list</span>
<span class="sd">		ax : matplotlib.Axes</span>
<span class="sd">			the axes to plot into. If None a new figure window is created.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">waves</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">waveforms</span>
		<span class="n">clust_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">cut</span> <span class="o">==</span> <span class="n">clusters</span>
		<span class="n">clust_waves</span> <span class="o">=</span> <span class="n">waves</span><span class="p">[</span><span class="n">clust_idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
		<span class="n">gains</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">gains</span>
		<span class="n">samps_per_spike</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;samples_per_spike&#39;</span><span class="p">])</span>
		<span class="n">clust_waves</span> <span class="o">=</span> <span class="n">clust_waves</span> <span class="o">*</span> <span class="mf">1e6</span> <span class="c1"># now in uv</span>
		<span class="n">ADC_scale</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">setheader</span><span class="p">[</span><span class="s1">&#39;ADC_fullscale_mv&#39;</span><span class="p">])</span>
		<span class="n">axes_scales</span> <span class="o">=</span> <span class="p">(</span><span class="n">ADC_scale</span> <span class="o">/</span> <span class="n">gains</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">))</span> <span class="o">*</span> <span class="mi">1000</span> <span class="c1"># axes limits in uv</span>
		<span class="k">if</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">clust_idx</span><span class="p">):</span>
			<span class="k">return</span>
		<span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
			<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">fig</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;figure&#39;</span><span class="p">]</span>
			<span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
		<span class="n">rect</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_position</span><span class="p">()</span><span class="o">.</span><span class="n">bounds</span>
		<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">,</span> <span class="n">samps_per_spike</span><span class="p">)</span>
		<span class="k">if</span> <span class="s1">&#39;clustColour&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">clustColour</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;clustColour&#39;</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">clusters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">clustColour</span> <span class="o">=</span> <span class="n">tcols</span><span class="o">.</span><span class="n">colours</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">clustColour</span> <span class="o">=</span> <span class="n">tcols</span><span class="o">.</span><span class="n">colours</span><span class="p">[</span><span class="n">clusters</span><span class="p">]</span>
		<span class="n">grid</span> <span class="o">=</span> <span class="n">ImageGrid</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">rect</span><span class="p">,</span> <span class="n">nrows_ncols</span><span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">axes_pad</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">add_all</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">share_all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
			<span class="n">lc</span> <span class="o">=</span> <span class="n">LineCollection</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">clust_waves</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="p">:])))</span>
			<span class="n">lc</span><span class="o">.</span><span class="n">set_rasterized</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
			<span class="n">lc</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="n">clustColour</span><span class="p">)</span>
			<span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>
			<span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">clust_waves</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="mi">0</span><span class="p">)),</span> <span class="s1">&#39;w-&#39;</span><span class="p">)</span>
			<span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="mf">2.5e-6</span><span class="o">*</span><span class="p">(</span><span class="n">ADC_scale</span><span class="o">/</span><span class="mf">1000.</span><span class="p">))</span>
			<span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">)</span>
			<span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="n">axes_scales</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">axes_scales</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_rasterized</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
			<span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="s1">&#39;off&#39;</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="s1">&#39;off&#39;</span><span class="p">,</span>
							<span class="n">bottom</span><span class="o">=</span><span class="s1">&#39;off&#39;</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
			<span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.9</span><span class="p">,</span><span class="mf">0.95</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s1">&#39;small&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>

		<span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">],</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">get_yticklabels</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">],</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="Trial.plotSAC"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotSAC">[docs]</a>	<span class="k">def</span> <span class="nf">plotSAC</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">binsize</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Plots the spatial autocorrelogram of the given tetrode/ cluster</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		tetrode : int</span>
<span class="sd">		cluster : int</span>
<span class="sd">		ax : matplotlib.pyplot.axis</span>
<span class="sd">			plots into this axis</span>
<span class="sd">		binsize : int</span>
<span class="sd">			size of bins (cms)</span>

<span class="sd">		See Also</span>
<span class="sd">		--------</span>
<span class="sd">			plotFullSAC</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
			<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
		<span class="n">rmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getMap</span><span class="p">(</span><span class="n">tetrode</span><span class="o">=</span><span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="o">=</span><span class="n">clusters</span><span class="p">,</span> <span class="n">binsize</span><span class="o">=</span><span class="n">binsize</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">nodwell</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">rmap</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">autoCorr2D</span><span class="p">(</span><span class="n">rmap</span><span class="p">,</span> <span class="n">nodwell</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
		<span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">(),</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yticklabels</span><span class="p">(),</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="Trial.plotFullSAC"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotFullSAC">[docs]</a>	<span class="k">def</span> <span class="nf">plotFullSAC</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">binsize</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">limit2mask</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Plots the full SAC ie including the edges and colours the central area in colour</span>
<span class="sd">		and the outlying bits (outside the mask area used to calculate gridness) in black and white</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		tetrode : int</span>
<span class="sd">		cluster : int</span>
<span class="sd">		ax : matplotlib.pyplot.axis</span>
<span class="sd">			plots into this axis</span>
<span class="sd">		binsize : int</span>
<span class="sd">			size of bins (cms)</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
				<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
		<span class="k">if</span> <span class="s1">&#39;step&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">step</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;step&#39;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">step</span> <span class="o">=</span> <span class="mi">30</span>
		<span class="n">rmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getMap</span><span class="p">(</span><span class="n">tetrode</span><span class="o">=</span><span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="o">=</span><span class="n">clusters</span><span class="p">,</span> <span class="n">binsize</span><span class="o">=</span><span class="n">binsize</span><span class="p">,</span> <span class="n">limit2mask</span><span class="o">=</span><span class="n">limit2mask</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">nodwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">rmap</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">autoCorr2D</span><span class="p">(</span><span class="n">rmap</span><span class="p">,</span> <span class="n">nodwell</span><span class="p">)</span>
		<span class="n">dct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMeasures</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">)</span>
		<span class="k">if</span> <span class="s1">&#39;gaussian&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;gaussian&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Gridness: </span><span class="si">{0}</span><span class="se">\n</span><span class="s1">Orientation: </span><span class="si">{1}</span><span class="se">\n</span><span class="s1">Scale: </span><span class="si">{2}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dct</span><span class="p">[</span><span class="s1">&#39;gridness&#39;</span><span class="p">],</span> <span class="n">dct</span><span class="p">[</span><span class="s1">&#39;orientation&#39;</span><span class="p">],</span> <span class="n">dct</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">]))</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">dct</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dct</span></div>

<div class="viewcode-block" id="Trial.getFieldRuns"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.getFieldRuns">[docs]</a>	<span class="k">def</span> <span class="nf">getFieldRuns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">binsize</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Extracts the runs through a place field of a given cluster on a given</span>
<span class="sd">		tetrode and returns the indices of the runs that are kept (defaults to</span>
<span class="sd">		at least 5 spikes needing to be fired) and the indices of the spikes in</span>
<span class="sd">		the run and the duration of each run</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		tetrode : int</span>
<span class="sd">		cluster : int</span>
<span class="sd">		binsize : int</span>
<span class="sd">			size of bins (cms)</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		data : tuple</span>
<span class="sd">			The runs retained, the spikes in the run and the run duration</span>
<span class="sd">		&#39;&#39;&#39;</span>

		<span class="c1"># label is a mask of the place field - this could be hijacked to cover the whole track</span>
		<span class="n">label</span><span class="p">,</span> <span class="n">xe</span><span class="p">,</span> <span class="n">ye</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getFieldLims</span><span class="p">(</span><span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">binsize</span><span class="p">)</span>
		<span class="n">S</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">regionprops</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
		<span class="n">areas</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;area&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">S</span><span class="p">]</span><span class="c1"># get the biggest field</span>
		<span class="n">bigFieldIdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">areas</span><span class="p">)</span>
		<span class="n">bigFieldProps</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">bigFieldIdx</span><span class="p">]</span>
		<span class="n">binCoords</span> <span class="o">=</span> <span class="n">bigFieldProps</span><span class="o">.</span><span class="n">coords</span>
		<span class="n">min_field_edge</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">binCoords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
		<span class="n">max_field_edge</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">binCoords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
		<span class="n">x_coord_field_min</span> <span class="o">=</span> <span class="n">xe</span><span class="p">[</span><span class="n">min_field_edge</span><span class="p">]</span>
		<span class="n">x_coord_field_max</span> <span class="o">=</span> <span class="n">xe</span><span class="p">[</span><span class="n">max_field_edge</span><span class="p">]</span>
		<span class="n">xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getPath</span><span class="p">()</span>
		<span class="n">x_field_bool</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">x_coord_field_min</span><span class="p">,</span>
								  <span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x_coord_field_max</span><span class="p">)</span>
		<span class="c1"># find the runs with spikes</span>
		<span class="n">run_indices</span> <span class="o">=</span> <span class="n">x_field_bool</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
		<span class="c1"># get a list of runs</span>
		<span class="n">runs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">run_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">run_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">10</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
		<span class="c1"># there might be short runs through the field so calculate the min distance</span>
		<span class="c1"># across the largest part of the field - done so this method can hopefully</span>
		<span class="c1"># account for runs in open fields as well as linear tracks</span>
		<span class="n">ppb</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;pixels_per_metre&#39;</span><span class="p">])</span> <span class="o">/</span> <span class="mf">100.</span> <span class="c1"># pixels per bin</span>
		<span class="n">dist2CrossField</span> <span class="o">=</span> <span class="n">bigFieldProps</span><span class="p">[</span><span class="s1">&#39;major_axis_length&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">ppb</span>
		<span class="c1"># get the spike indices into position data</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">getClustIdx</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
		<span class="n">runs_to_keep</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">spks_in_run</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">run_duration</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">run</span> <span class="ow">in</span> <span class="n">runs</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">run</span><span class="p">]),</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">run</span><span class="p">])))</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">dist2CrossField</span> <span class="o">/</span> <span class="mi">2</span><span class="p">):</span> <span class="c1"># be conservative and take 1/2 dist</span>
				<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">run</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
					<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">run</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_spks</span><span class="p">:</span><span class="c1"># if there are &gt;5 spikes keep run</span>
						<span class="n">runs_to_keep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">run</span><span class="p">)</span>
						<span class="n">spks_in_run</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">run</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span>
						<span class="n">run_duration</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">run</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">run</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">pos_sample_rate</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">runs_to_keep</span><span class="p">,</span> <span class="n">spks_in_run</span><span class="p">,</span> <span class="n">run_duration</span></div>

<div class="viewcode-block" id="Trial.tortuosity"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.tortuosity">[docs]</a>	<span class="k">def</span> <span class="nf">tortuosity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Parameters</span>
<span class="sd">		-----------</span>
<span class="sd">		xy - numpy.array</span>
<span class="sd">			2xm matrix of xy positions. Default is None so will use this</span>
<span class="sd">			instances xy array in POS</span>

<span class="sd">		Returns</span>
<span class="sd">		--------</span>
<span class="sd">		tortuosity : float</span>
<span class="sd">			tortuosity index calculated as follows:</span>
<span class="sd">			T = sum(path_segment / segment_straight_line) / n_segments</span>
<span class="sd">			n_segments is the number of one second segments per trial</span>
<span class="sd">		&#39;&#39;&#39;</span>

		<span class="k">if</span> <span class="n">xy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getPath</span><span class="p">()</span>
		<span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">xy</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">50</span><span class="p">))</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">):</span>
			<span class="n">straight_line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">50</span><span class="p">],</span> <span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">50</span><span class="p">])</span>
			<span class="n">path_segment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">50</span><span class="p">]),</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">50</span><span class="p">])))</span>
			<span class="n">T</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">path_segment</span> <span class="o">/</span> <span class="n">straight_line</span>
			<span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
		<span class="n">toobigbool</span> <span class="o">=</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="mi">100</span>
		<span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">toobigbool</span><span class="o">.</span><span class="n">nonzero</span><span class="p">())</span>
		<span class="n">zerobool</span> <span class="o">=</span> <span class="n">T</span><span class="o">==</span><span class="mi">0</span>
		<span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">zerobool</span><span class="o">.</span><span class="n">nonzero</span><span class="p">())</span>
		<span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">())</span>
		<span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">())</span>
		<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">T</span><span class="p">)</span></div>

<div class="viewcode-block" id="Trial.getThigmotaxisIndex"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.getThigmotaxisIndex">[docs]</a>	<span class="k">def</span> <span class="nf">getThigmotaxisIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Currently fucked</span>
<span class="sd">		Calculates the ratio of time spent in the middle of the environment</span>
<span class="sd">		to the amount of time spent in the central part</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">dwellmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getMap</span><span class="p">(</span><span class="n">smooth</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># unsmoothed dwell map</span>
		<span class="c1"># simply calculate the sums in the corners and see if this </span>
		<span class="c1"># goes above some threshold</span>
		<span class="n">corner_sz</span> <span class="o">=</span> <span class="mi">3</span>
		<span class="n">tl</span> <span class="o">=</span> <span class="n">dwellmap</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">corner_sz</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">corner_sz</span><span class="p">]</span>
		<span class="n">tr</span> <span class="o">=</span> <span class="n">dwellmap</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">corner_sz</span><span class="p">,</span> <span class="o">-</span><span class="n">corner_sz</span><span class="p">:]</span>
		<span class="n">bl</span> <span class="o">=</span> <span class="n">dwellmap</span><span class="p">[</span><span class="o">-</span><span class="n">corner_sz</span><span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">corner_sz</span><span class="p">]</span>
		<span class="n">br</span> <span class="o">=</span> <span class="n">dwellmap</span><span class="p">[</span><span class="o">-</span><span class="n">corner_sz</span><span class="p">:,</span> <span class="o">-</span><span class="n">corner_sz</span><span class="p">:]</span>
		<span class="n">corner_dwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">tl</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">bl</span><span class="p">,</span> <span class="n">br</span><span class="p">])</span>

		<span class="k">if</span> <span class="n">corner_dwell</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">:</span>
			<span class="n">shape</span> <span class="o">=</span> <span class="s1">&#39;square&#39;</span>

		<span class="k">else</span><span class="p">:</span>
			<span class="n">shape</span> <span class="o">=</span> <span class="s1">&#39;circle&#39;</span></div>

<div class="viewcode-block" id="Trial.getBorderScore"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.getBorderScore">[docs]</a>	<span class="k">def</span> <span class="nf">getBorderScore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Calculates the border score in a similar way to how the Moser group did</span>
<span class="sd">		but can also deal with circular environments as well as square ones</span>

<span class="sd">		Wrapper for fieldcalcs getBorderScore - see there for docs</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		tetrode : int</span>
<span class="sd">		cluster : int</span>
<span class="sd">		debug : bool</span>

<span class="sd">		See Also</span>
<span class="sd">		--------</span>
<span class="sd">		fieldcalcs.FieldCalcs.getBorderScore</span>
<span class="sd">		&#39;&#39;&#39;</span>

		<span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getMap</span><span class="p">(</span><span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">dwellmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getMap</span><span class="p">(</span><span class="n">smooth</span><span class="o">=</span><span class="kc">None</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
		<span class="c1"># simply calculate the sums in the corners and see if this</span>
		<span class="c1"># goes above some threshold</span>
		<span class="n">corner_sz</span> <span class="o">=</span> <span class="mi">3</span>
		<span class="n">tl</span> <span class="o">=</span> <span class="n">dwellmap</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">corner_sz</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">corner_sz</span><span class="p">]</span>
		<span class="n">tr</span> <span class="o">=</span> <span class="n">dwellmap</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">corner_sz</span><span class="p">,</span> <span class="o">-</span><span class="n">corner_sz</span><span class="p">:]</span>
		<span class="n">bl</span> <span class="o">=</span> <span class="n">dwellmap</span><span class="p">[</span><span class="o">-</span><span class="n">corner_sz</span><span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">corner_sz</span><span class="p">]</span>
		<span class="n">br</span> <span class="o">=</span> <span class="n">dwellmap</span><span class="p">[</span><span class="o">-</span><span class="n">corner_sz</span><span class="p">:,</span> <span class="o">-</span><span class="n">corner_sz</span><span class="p">:]</span>
		<span class="n">corner_dwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">tl</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">bl</span><span class="p">,</span> <span class="n">br</span><span class="p">])</span>

		<span class="n">A_rows</span><span class="p">,</span> <span class="n">A_cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">corner_dwell</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">:</span>
			<span class="n">shape</span> <span class="o">=</span> <span class="s1">&#39;square&#39;</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">shape</span> <span class="o">=</span> <span class="s1">&#39;circle&#39;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fieldcalcs</span><span class="o">.</span><span class="n">getBorderScore</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">)</span></div>

<div class="viewcode-block" id="Trial.plotDirFilteredRmaps"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotDirFilteredRmaps">[docs]</a>	<span class="k">def</span> <span class="nf">plotDirFilteredRmaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">maptype</span><span class="o">=</span><span class="s1">&#39;rmap&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Plots out directionally filtered ratemaps for the tetrode/ cluster</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		tetrode : int</span>
<span class="sd">		cluster : int</span>
<span class="sd">		maptype : str</span>
<span class="sd">			Valid values include &#39;rmap&#39;, &#39;polar&#39;, &#39;xcorr&#39;</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">inc</span> <span class="o">=</span> <span class="mf">8.0</span>
		<span class="n">step</span> <span class="o">=</span> <span class="mi">360</span><span class="o">/</span><span class="n">inc</span>
		<span class="n">dirs_st</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">360</span><span class="o">-</span><span class="p">(</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">step</span><span class="p">)</span>
		<span class="n">dirs_en</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
		<span class="n">dirs_st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dirs_en</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

		<span class="k">if</span> <span class="s1">&#39;polar&#39;</span> <span class="ow">in</span> <span class="n">maptype</span><span class="p">:</span>
			<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">subplot_kw</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;projection&#39;</span><span class="p">:</span> <span class="s1">&#39;polar&#39;</span><span class="p">})</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
		<span class="n">ax0</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># top-left</span>
		<span class="n">ax1</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># top-middle</span>
		<span class="n">ax2</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># top-right</span>
		<span class="n">ax3</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># middle-left</span>
		<span class="n">ax4</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># middle</span>
		<span class="n">ax5</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># middle-right</span>
		<span class="n">ax6</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># bottom-left</span>
		<span class="n">ax7</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># bottom-middle</span>
		<span class="n">ax8</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># bottom-right</span>

		<span class="n">max_rate</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dirs_st</span><span class="p">,</span> <span class="n">dirs_en</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">posFilter</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;dir&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">])}</span>
			<span class="k">if</span> <span class="s1">&#39;polar&#39;</span> <span class="ow">in</span> <span class="n">maptype</span><span class="p">:</span>
				<span class="n">rmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getMap</span><span class="p">(</span><span class="n">tetrode</span><span class="o">=</span><span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="o">=</span><span class="n">cluster</span><span class="p">,</span> <span class="n">var2bin</span><span class="o">=</span><span class="s1">&#39;dir&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
			<span class="k">elif</span> <span class="s1">&#39;xcorr&#39;</span> <span class="ow">in</span> <span class="n">maptype</span><span class="p">:</span>
				<span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">getClustTS</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">96000</span><span class="o">/</span><span class="mi">1000</span><span class="p">)</span>
				<span class="n">rmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spikecalcs</span><span class="o">.</span><span class="n">xcorr</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">Trange</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">500</span><span class="p">,</span> <span class="mi">500</span><span class="p">]))</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">rmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getMap</span><span class="p">(</span><span class="n">tetrode</span><span class="o">=</span><span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="o">=</span><span class="n">cluster</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
			<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">rmap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_rate</span><span class="p">:</span>
				<span class="n">max_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">rmap</span><span class="p">)</span>

		<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
		<span class="n">dir_rates</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">dirs_st</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

		<span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dirs_st</span><span class="p">,</span> <span class="n">dirs_en</span><span class="p">,</span> <span class="p">[</span><span class="n">ax5</span><span class="p">,</span><span class="n">ax2</span><span class="p">,</span><span class="n">ax1</span><span class="p">,</span><span class="n">ax0</span><span class="p">,</span><span class="n">ax3</span><span class="p">,</span><span class="n">ax6</span><span class="p">,</span><span class="n">ax7</span><span class="p">,</span><span class="n">ax8</span><span class="p">]):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">posFilter</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;dir&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">])}</span>
			<span class="n">npos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">compressed</span><span class="p">(</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">POS</span><span class="o">.</span><span class="n">dir</span><span class="o">.</span><span class="n">mask</span><span class="p">))</span>
			<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;npos = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">npos</span><span class="p">))</span>
			<span class="n">nspikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">compressed</span><span class="p">(</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">getClustSpks</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span><span class="o">.</span><span class="n">mask</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span>
			<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;nspikes = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nspikes</span><span class="p">))</span>
			<span class="n">dir_rates</span><span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">nspikes</span><span class="c1"># / (npos/50.0)</span>
			<span class="k">if</span> <span class="s1">&#39;spikes&#39;</span> <span class="ow">in</span> <span class="n">maptype</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">plotSpikesOnPath</span><span class="p">(</span><span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
			<span class="k">elif</span> <span class="s1">&#39;rmap&#39;</span> <span class="ow">in</span> <span class="n">maptype</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_plotMap</span><span class="p">(</span><span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">vmax</span><span class="o">=</span><span class="n">max_rate</span><span class="p">)</span>
			<span class="k">elif</span> <span class="s1">&#39;polar&#39;</span> <span class="ow">in</span> <span class="n">maptype</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_plotMap</span><span class="p">(</span><span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">var2bin</span><span class="o">=</span><span class="s1">&#39;dir&#39;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">vmax</span><span class="o">=</span><span class="n">max_rate</span><span class="p">)</span>
			<span class="k">elif</span> <span class="s1">&#39;xcorr&#39;</span> <span class="ow">in</span> <span class="n">maptype</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">plotXCorr</span><span class="p">(</span><span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
				<span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TETRODE</span><span class="p">[</span><span class="n">tetrode</span><span class="p">]</span><span class="o">.</span><span class="n">getClustTS</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">96000</span><span class="o">/</span><span class="mi">1000</span><span class="p">)</span>
				<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;x1 len = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">)))</span>
				<span class="n">dir_rates</span><span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spikecalcs</span><span class="o">.</span><span class="n">thetaBandMaxFreq</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
				<span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
				<span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
				<span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
			<span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;nspikes = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nspikes</span><span class="p">))</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">posFilter</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="k">if</span> <span class="s1">&#39;spikes&#39;</span> <span class="ow">in</span> <span class="n">maptype</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">plotSpikesOnPath</span><span class="p">(</span><span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax4</span><span class="p">)</span>
		<span class="k">elif</span> <span class="s1">&#39;rmap&#39;</span> <span class="ow">in</span> <span class="n">maptype</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_plotMap</span><span class="p">(</span><span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax4</span><span class="p">)</span>
		<span class="k">elif</span> <span class="s1">&#39;polar&#39;</span> <span class="ow">in</span> <span class="n">maptype</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_plotMap</span><span class="p">(</span><span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">var2bin</span><span class="o">=</span><span class="s1">&#39;dir&#39;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax4</span><span class="p">)</span>
		<span class="k">elif</span> <span class="s1">&#39;xcorr&#39;</span> <span class="ow">in</span> <span class="n">maptype</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">plotXCorr</span><span class="p">(</span><span class="n">tetrode</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax4</span><span class="p">)</span>
			<span class="n">ax4</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
			<span class="n">ax4</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
			<span class="n">ax4</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dir_rates</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Robin Hayman

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>