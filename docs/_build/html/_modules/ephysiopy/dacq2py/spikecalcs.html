

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ephysiopy.dacq2py.spikecalcs &mdash; ephysiopy 1.5.55 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> ephysiopy
          

          
          </a>

          
            
            
              <div class="version">
                1.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"></div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">ephysiopy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>ephysiopy.dacq2py.spikecalcs</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for ephysiopy.dacq2py.spikecalcs</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A lot of the functionality here has been more generically implemented</span>
<span class="sd">in the ephys_generic.ephys_generic.SpikeCalcsGeneric class</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>		
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">colors</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">blur_image</span>

<div class="viewcode-block" id="SpikeCalcs"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.spikecalcs.SpikeCalcs">[docs]</a><span class="k">class</span> <span class="nc">SpikeCalcs</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Mix-in class for use with Tetrode class below.</span>
<span class="sd">	</span>
<span class="sd">	Extends Tetrodes functionality by adding methods for analysis of spikes/</span>
<span class="sd">	spike trains</span>
<span class="sd">				</span>
<span class="sd">	Note lots of the methods here are native to dacq2py.axonaIO.Tetrode</span>
<span class="sd">	</span>
<span class="sd">	Note that units are in milliseconds</span>
<span class="sd">	&quot;&quot;&quot;</span>
	
	
<div class="viewcode-block" id="SpikeCalcs.getNSpikes"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.spikecalcs.SpikeCalcs.getNSpikes">[docs]</a>	<span class="k">def</span> <span class="nf">getNSpikes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">cluster</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">:</span>
			<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Cluster not available. Try again!&#39;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">)</span></div>

<div class="viewcode-block" id="SpikeCalcs.trial_av_firing_rate"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.spikecalcs.SpikeCalcs.trial_av_firing_rate">[docs]</a>	<span class="k">def</span> <span class="nf">trial_av_firing_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		returns the trial average firing rate of a cluster in Hz</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNSpikes</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;duration&#39;</span><span class="p">])</span></div>
	
<div class="viewcode-block" id="SpikeCalcs.mean_autoCorr"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.spikecalcs.SpikeCalcs.mean_autoCorr">[docs]</a>	<span class="k">def</span> <span class="nf">mean_autoCorr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">40</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Returns the autocorrelation function mean from 0 to n ms (default=40)</span>
<span class="sd">		Used to help classify units as principal or interneuron</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="n">cluster</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">:</span>
			<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Cluster not available. Try again!&#39;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">bins</span> <span class="o">=</span> <span class="mi">201</span>
			<span class="n">Trange</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">500</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
			<span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xcorr</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">Trange</span><span class="o">=</span><span class="n">Trange</span><span class="p">)</span>
			<span class="n">counts</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">Trange</span><span class="p">)</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">bins</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">bins</span><span class="o">&lt;</span><span class="n">n</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span></div>
		
<div class="viewcode-block" id="SpikeCalcs.ifr_sp_corr"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.spikecalcs.SpikeCalcs.ifr_sp_corr">[docs]</a>	<span class="k">def</span> <span class="nf">ifr_sp_corr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clusterA</span><span class="p">,</span> <span class="n">speed</span><span class="p">,</span> <span class="n">minSpeed</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">maxSpeed</span><span class="o">=</span><span class="mf">40.0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> 
					<span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nShuffles</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">minTime</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		clusterA: int</span>
<span class="sd">			the cluster to do the correlation with speed</span>
<span class="sd">		speed: np.array (1 x nSamples)</span>
<span class="sd">			instantaneous speed </span>
<span class="sd">		minSpeed: int</span>
<span class="sd">			speeds below this value are ignored - defaults to 2cm/s as with</span>
<span class="sd">			Kropff et al., 2015</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">clusterA</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">:</span>
			<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Cluster not available. Try again!&#39;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">speed</span> <span class="o">=</span> <span class="n">speed</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
			<span class="n">posSampRate</span> <span class="o">=</span> <span class="mi">50</span>
			<span class="n">nSamples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">speed</span><span class="p">)</span>
			<span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getClustIdx</span><span class="p">(</span><span class="n">clusterA</span><span class="p">)</span>
			<span class="c1"># position is sampled at 50Hz and so is &#39;automatically&#39; binned into</span>
			<span class="c1"># 20ms bins</span>
			<span class="n">spk_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="n">nSamples</span><span class="p">)</span>
			<span class="c1"># smooth the spk_hist (which is a temporal histogram) with a 250ms</span>
			<span class="c1"># gaussian as with Kropff et al., 2015</span>
			<span class="n">h</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
			<span class="n">h</span> <span class="o">=</span> <span class="n">h</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>
			<span class="c1">#filter for low speeds</span>
			<span class="n">lowSpeedIdx</span> <span class="o">=</span> <span class="n">speed</span> <span class="o">&lt;</span> <span class="n">minSpeed</span>
			<span class="n">highSpeedIdx</span> <span class="o">=</span> <span class="n">speed</span> <span class="o">&gt;</span> <span class="n">maxSpeed</span>
			<span class="n">speed_filt</span> <span class="o">=</span> <span class="n">speed</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">lowSpeedIdx</span><span class="p">,</span> <span class="n">highSpeedIdx</span><span class="p">)]</span>
			<span class="n">spk_hist_filt</span> <span class="o">=</span> <span class="n">spk_hist</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">lowSpeedIdx</span><span class="p">,</span> <span class="n">highSpeedIdx</span><span class="p">)]</span>
			<span class="n">spk_sm</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">spk_hist_filt</span><span class="p">)</span>
			<span class="n">sm_spk_rate</span> <span class="o">=</span> <span class="n">spk_sm</span> <span class="o">*</span> <span class="n">posSampRate</span>
			
			<span class="n">res</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">pearsonr</span><span class="p">(</span><span class="n">sm_spk_rate</span><span class="p">,</span> <span class="n">speed_filt</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">plot</span><span class="p">:</span>            
				<span class="c1"># do some fancy plotting stuff</span>
				<span class="n">speed_binned</span><span class="p">,</span> <span class="n">sp_bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">speed_filt</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
				<span class="n">sp_dig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">speed_filt</span><span class="p">,</span> <span class="n">sp_bin_edges</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
				<span class="n">spks_per_sp_bin</span> <span class="o">=</span> <span class="p">[</span><span class="n">spk_hist_filt</span><span class="p">[</span><span class="n">sp_dig</span><span class="o">==</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sp_bin_edges</span><span class="p">))]</span> 
				<span class="n">rate_per_sp_bin</span> <span class="o">=</span> <span class="p">[]</span>
				<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">spks_per_sp_bin</span><span class="p">:</span>
					<span class="n">rate_per_sp_bin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">posSampRate</span><span class="p">)</span>
				<span class="n">rate_filter</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
				<span class="n">rate_filter</span> <span class="o">=</span> <span class="n">rate_filter</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rate_filter</span><span class="p">)</span>
				<span class="n">binned_spk_rate</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">rate_filter</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">rate_per_sp_bin</span><span class="p">)</span>
				<span class="c1"># instead of plotting a scatter plot of the firing rate at each </span>
				<span class="c1"># speed bin, plot a log normalised heatmap and overlay results on it</span>
				
				<span class="n">spk_binning_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">sm_spk_rate</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">sm_spk_rate</span><span class="p">),</span>
												<span class="nb">len</span><span class="p">(</span><span class="n">sp_bin_edges</span><span class="p">))</span>
				<span class="n">speed_mesh</span><span class="p">,</span> <span class="n">spk_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">sp_bin_edges</span><span class="p">,</span> <span class="n">spk_binning_edges</span><span class="p">)</span>
				<span class="n">binned_rate</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">(</span><span class="n">speed_filt</span><span class="p">,</span> <span class="n">sm_spk_rate</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="p">[</span><span class="n">sp_bin_edges</span><span class="p">,</span>
												   <span class="n">spk_binning_edges</span><span class="p">])</span>
				<span class="c1">#blur the binned rate a bit to make it look nicer</span>
				<span class="n">sm_binned_rate</span> <span class="o">=</span> <span class="n">blur_image</span><span class="p">(</span><span class="n">binned_rate</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
				<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
				<span class="n">plt</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">speed_mesh</span><span class="p">,</span> <span class="n">spk_mesh</span><span class="p">,</span> <span class="n">sm_binned_rate</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">colors</span><span class="o">.</span><span class="n">LogNorm</span><span class="p">(),</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="s1">&#39;flat&#39;</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">)</span>
				<span class="c1">#overlay the smoothed binned rate against speed</span>
				<span class="n">plt</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
				<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sp_bin_edges</span><span class="p">,</span> <span class="n">binned_spk_rate</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
				<span class="c1">#do the linear regression and plot the fit too</span>
				<span class="c1"># TODO: linear regression is broken ie not regressing the correct variables</span>
				<span class="n">lr</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">linregress</span><span class="p">(</span><span class="n">speed_filt</span><span class="p">,</span> <span class="n">sm_spk_rate</span><span class="p">)</span>
				<span class="n">end_point</span> <span class="o">=</span> <span class="n">lr</span><span class="o">.</span><span class="n">intercept</span> <span class="o">+</span> <span class="p">((</span><span class="n">sp_bin_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">sp_bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">lr</span><span class="o">.</span><span class="n">slope</span><span class="p">)</span>
				<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">sp_bin_edges</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">sp_bin_edges</span><span class="p">)],</span> <span class="p">[</span><span class="n">lr</span><span class="o">.</span><span class="n">intercept</span><span class="p">,</span> <span class="n">end_point</span><span class="p">],</span> <span class="s1">&#39;r--&#39;</span><span class="p">)</span>
				<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
				<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">sp_bin_edges</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">sp_bin_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span>
				<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">binned_spk_rate</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.1</span><span class="p">)</span>
				<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Firing rate(Hz)&#39;</span><span class="p">)</span>
				<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Running speed(cm/s)&#39;</span><span class="p">)</span>
				<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Intercept: </span><span class="si">{0:.3f}</span><span class="s1">    Slope: </span><span class="si">{1:.5f}</span><span class="se">\n</span><span class="s1">Pearson: </span><span class="si">{2:.5f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lr</span><span class="o">.</span><span class="n">intercept</span><span class="p">,</span> <span class="n">lr</span><span class="o">.</span><span class="n">slope</span><span class="p">,</span> <span class="n">lr</span><span class="o">.</span><span class="n">rvalue</span><span class="p">))</span>
			<span class="c1">#do some shuffling of the data to see if the result is signficant            </span>
			<span class="k">if</span> <span class="n">shuffle</span><span class="p">:</span>                
				<span class="c1"># shift spikes by at least 30 seconds after trial start and</span>
				<span class="c1"># 30 seconds before trial end</span>
				<span class="n">timeSteps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">30</span> <span class="o">*</span> <span class="n">posSampRate</span><span class="p">,</span> <span class="n">nSamples</span> <span class="o">-</span> <span class="p">(</span><span class="mi">30</span> <span class="o">*</span> <span class="n">posSampRate</span><span class="p">),</span>
													  <span class="n">nShuffles</span><span class="p">)</span>
				<span class="n">shuffled_results</span> <span class="o">=</span> <span class="p">[]</span>            
				<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">timeSteps</span><span class="p">:</span>
					<span class="n">spk_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">spk_hist</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
					<span class="n">spk_count_filt</span> <span class="o">=</span> <span class="n">spk_count</span><span class="p">[</span><span class="o">~</span><span class="n">lowSpeedIdx</span><span class="p">]</span>
					<span class="n">spk_count_sm</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">spk_count_filt</span><span class="p">)</span>
					<span class="n">shuffled_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">pearsonr</span><span class="p">(</span><span class="n">spk_count_sm</span><span class="p">,</span> <span class="n">speed_filt</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
				<span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
					<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
					<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
					<span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">shuffled_results</span><span class="p">),</span> <span class="mi">20</span><span class="p">)</span>
					<span class="n">ylims</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()</span>
					<span class="n">ax</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">ylims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ylims</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
				
			<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;PPMC: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span></div>

<div class="viewcode-block" id="SpikeCalcs.xcorr"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.spikecalcs.SpikeCalcs.xcorr">[docs]</a>	<span class="k">def</span> <span class="nf">xcorr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Trange</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Returns the histogram of the ISIs</span>

<span class="sd">		Parameters</span>
<span class="sd">		---------------</span>
<span class="sd">		x1 - 1d np.array list of spike times</span>
<span class="sd">		x2 - (optional) 1d np.array of spike times</span>
<span class="sd">		Trange - 1x2 np.array for range of times to bin up. Defaults</span>
<span class="sd">					to [-500, +500]</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="n">x2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">x2</span> <span class="o">=</span> <span class="n">x1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">Trange</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">Trange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">500</span><span class="p">,</span> <span class="mi">500</span><span class="p">])</span>
		<span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">irange</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">Trange</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
		<span class="n">dts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">irange</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dts</span><span class="p">):</span>
			<span class="n">y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">x2</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
		<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">y</span></div>

<div class="viewcode-block" id="SpikeCalcs.smoothSpikePosCount"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.spikecalcs.SpikeCalcs.smoothSpikePosCount">[docs]</a>	<span class="k">def</span> <span class="nf">smoothSpikePosCount</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">npos</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Returns a spike train the same length as num pos samples that has been</span>
<span class="sd">		smoothed in time with a gaussian kernel M in width and standard deviation</span>
<span class="sd">		equal to sigma</span>
<span class="sd">		</span>
<span class="sd">		Parameters</span>
<span class="sd">		--------------</span>
<span class="sd">		x1 : np.array</span>
<span class="sd">			The pos indices the spikes occured at</span>
<span class="sd">		npos : int</span>
<span class="sd">			The number of position samples captured</span>
<span class="sd">		sigma : float</span>
<span class="sd">			the standard deviation of the gaussian used to smooth the spike</span>
<span class="sd">			train</span>
<span class="sd">		shuffle: int</span>
<span class="sd">			The number of seconds to shift the spike train by. Default None</span>
<span class="sd">		</span>
<span class="sd">		Returns</span>
<span class="sd">		-----------</span>
<span class="sd">		smoothed_spikes : np.array</span>
<span class="sd">			The smoothed spike train</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">spk_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="n">npos</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">shuffle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">spk_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">spk_hist</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">shuffle</span> <span class="o">*</span> <span class="mi">50</span><span class="p">))</span>
		<span class="c1"># smooth the spk_hist (which is a temporal histogram) with a 250ms</span>
		<span class="c1"># gaussian as with Kropff et al., 2015</span>
		<span class="n">h</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
		<span class="n">h</span> <span class="o">=</span> <span class="n">h</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">spk_hist</span><span class="p">)</span></div>
	
<div class="viewcode-block" id="SpikeCalcs.getMeanWaveform"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.spikecalcs.SpikeCalcs.getMeanWaveform">[docs]</a>	<span class="k">def</span> <span class="nf">getMeanWaveform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clusterA</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Returns the mean waveform and sem for a given spike train</span>
<span class="sd">		</span>
<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		clusterA: int</span>
<span class="sd">			The cluster to get the mean waveform for</span>
<span class="sd">			</span>
<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		mn_wvs: ndarray (floats) - usually 4x50 for tetrode recordings</span>
<span class="sd">			the mean waveforms</span>
<span class="sd">		std_wvs: ndarray (floats) - usually 4x50 for tetrode recordings</span>
<span class="sd">			the standard deviations of the waveforms</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="n">clusterA</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">:</span>
			<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Cluster not available. Try again!&#39;</span><span class="p">)</span>
		<span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getClustSpks</span><span class="p">(</span><span class="n">clusterA</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="SpikeCalcs.thetaBandMaxFreq"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.spikecalcs.SpikeCalcs.thetaBandMaxFreq">[docs]</a>	<span class="k">def</span> <span class="nf">thetaBandMaxFreq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Calculates the frequency with the max power in the theta band (6-12Hz)</span>
<span class="sd">		of a spike trains autocorrelogram. Partly to look for differences</span>
<span class="sd">		in theta frequency in different running directions a la Blair (Welday paper)</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xcorr</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
		<span class="n">corr</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="mi">201</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">500</span><span class="p">,</span><span class="mi">500</span><span class="p">]))</span>
		<span class="c1"># Take the fft of the spike train autocorr (from -500 to +500ms)</span>
		<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">periodogram</span>
		<span class="n">freqs</span><span class="p">,</span> <span class="n">power</span> <span class="o">=</span> <span class="n">periodogram</span><span class="p">(</span><span class="n">corr</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">return_onesided</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
		<span class="n">power_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">power</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">freqs</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">,</span><span class="n">freqs</span><span class="o">&gt;</span><span class="mi">12</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">freqs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">power_masked</span><span class="p">)]</span></div>

<div class="viewcode-block" id="SpikeCalcs.thetaModIdx"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.spikecalcs.SpikeCalcs.thetaModIdx">[docs]</a>	<span class="k">def</span> <span class="nf">thetaModIdx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Calculates a theta modulation index of a spike train based on the cells</span>
<span class="sd">		autocorrelogram</span>
<span class="sd">		</span>
<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		x1: np.array</span>
<span class="sd">			The spike time-series</span>
<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		thetaMod: float</span>
<span class="sd">			The difference of the values at the first peak and trough of the</span>
<span class="sd">			autocorrelogram</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xcorr</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
		<span class="n">corr</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="mi">201</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">500</span><span class="p">,</span><span class="mi">500</span><span class="p">]))</span>
		<span class="c1"># Take the fft of the spike train autocorr (from -500 to +500ms)</span>
		<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">periodogram</span>
		<span class="n">freqs</span><span class="p">,</span> <span class="n">power</span> <span class="o">=</span> <span class="n">periodogram</span><span class="p">(</span><span class="n">corr</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">return_onesided</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
		<span class="c1"># Smooth the power over +/- 1Hz</span>
		<span class="n">b</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">boxcar</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
		<span class="n">h</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">power</span><span class="p">)</span>
		
		<span class="c1"># Square the amplitude first</span>
		<span class="n">sqd_amp</span> <span class="o">=</span> <span class="n">h</span> <span class="o">**</span> <span class="mi">2</span>
		<span class="c1"># Then find the mean power in the +/-1Hz band either side of that</span>
		<span class="n">theta_band_max_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">sqd_amp</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">sqd_amp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">freqs</span><span class="o">&gt;</span><span class="mi">6</span><span class="p">,</span> <span class="n">freqs</span><span class="o">&lt;</span><span class="mi">11</span><span class="p">)]))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">mean_theta_band_power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sqd_amp</span><span class="p">[</span><span class="n">theta_band_max_idx</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">theta_band_max_idx</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
		<span class="c1"># Find the mean amplitude in the 2-50Hz range</span>
		<span class="n">other_band_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">freqs</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">,</span> <span class="n">freqs</span><span class="o">&lt;</span><span class="mi">50</span><span class="p">)</span>
		<span class="n">mean_other_band_power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sqd_amp</span><span class="p">[</span><span class="n">other_band_idx</span><span class="p">])</span>
		<span class="c1"># Find the ratio of these two - this is the theta modulation index</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">mean_theta_band_power</span> <span class="o">-</span> <span class="n">mean_other_band_power</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">mean_theta_band_power</span> <span class="o">+</span> <span class="n">mean_other_band_power</span><span class="p">)</span></div>

<div class="viewcode-block" id="SpikeCalcs.thetaModIdxV2"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.spikecalcs.SpikeCalcs.thetaModIdxV2">[docs]</a>	<span class="k">def</span> <span class="nf">thetaModIdxV2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		This is a simpler alternative to the thetaModIdx method in that it</span>
<span class="sd">		calculates the difference between the normalized temporal autocorrelogram</span>
<span class="sd">		at the trough between 50-70ms and the peak between 100-140ms over</span>
<span class="sd">		their sum (data is binned into 5ms bins)</span>
<span class="sd">		</span>
<span class="sd">		Measure used in Cacucci et al., 2004 and Kropff et al 2015</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xcorr</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
		<span class="n">corr</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="mi">201</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">500</span><span class="p">,</span><span class="mi">500</span><span class="p">]))</span>
		<span class="c1"># &#39;close&#39; the right-hand bin</span>
		<span class="n">bins</span> <span class="o">=</span> <span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="c1"># normalise corr so max is 1.0</span>
		<span class="n">corr</span> <span class="o">=</span> <span class="n">corr</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">corr</span><span class="p">))</span>
		<span class="n">thetaAntiPhase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">corr</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">bins</span><span class="o">&gt;</span><span class="mi">50</span><span class="p">,</span><span class="n">bins</span><span class="o">&lt;</span><span class="mi">70</span><span class="p">)])</span>
		<span class="n">thetaPhase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">corr</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">bins</span><span class="o">&gt;</span><span class="mi">100</span><span class="p">,</span> <span class="n">bins</span><span class="o">&lt;</span><span class="mi">140</span><span class="p">)])</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">thetaPhase</span><span class="o">-</span><span class="n">thetaAntiPhase</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">thetaPhase</span><span class="o">+</span><span class="n">thetaAntiPhase</span><span class="p">)</span></div>

<div class="viewcode-block" id="SpikeCalcs.clusterQuality"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.spikecalcs.SpikeCalcs.clusterQuality">[docs]</a>	<span class="k">def</span> <span class="nf">clusterQuality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">fet</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		returns the L-ratio and Isolation Distance measures</span>
<span class="sd">		calculated on the principal components of the energy in a spike matrix</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">nSpikes</span><span class="p">,</span> <span class="n">nElectrodes</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">waveforms</span><span class="o">.</span><span class="n">shape</span>
		<span class="n">wvs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">waveforms</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
		<span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">waveforms</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
		<span class="n">zeroIdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
		<span class="n">E</span> <span class="o">=</span> <span class="n">E</span><span class="p">[:,</span> <span class="o">~</span><span class="n">zeroIdx</span><span class="p">]</span>
		<span class="n">wvs</span> <span class="o">=</span> <span class="n">wvs</span><span class="p">[:,</span> <span class="o">~</span><span class="n">zeroIdx</span><span class="p">,</span> <span class="p">:]</span>
		<span class="n">normdWaves</span> <span class="o">=</span> <span class="p">(</span><span class="n">wvs</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="n">E</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
		<span class="n">PCA_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getParam</span><span class="p">(</span><span class="n">normdWaves</span><span class="p">,</span> <span class="s1">&#39;PCA&#39;</span><span class="p">,</span> <span class="n">fet</span><span class="o">=</span><span class="n">fet</span><span class="p">)</span>
		<span class="c1"># get mahalanobis distance</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="o">==</span> <span class="n">cluster</span>
		<span class="n">nClustSpikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mahal</span><span class="p">(</span><span class="n">PCA_m</span><span class="p">,</span><span class="n">PCA_m</span><span class="p">[</span><span class="n">idx</span><span class="p">,:])</span>
			<span class="c1"># get the indices of the spikes not in the cluster</span>
			<span class="n">M_noise</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="o">~</span><span class="n">idx</span><span class="p">]</span>
			<span class="n">df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">((</span><span class="n">fet</span><span class="p">,</span> <span class="n">nElectrodes</span><span class="p">))</span>
			<span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">M_noise</span><span class="p">,</span> <span class="n">df</span><span class="p">))</span>
			<span class="n">L_ratio</span> <span class="o">=</span> <span class="n">L</span> <span class="o">/</span> <span class="n">nClustSpikes</span>
			<span class="c1"># calculate isolation distance</span>
			<span class="k">if</span> <span class="n">nClustSpikes</span> <span class="o">&lt;</span> <span class="n">nSpikes</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
				<span class="n">M_noise</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
				<span class="n">isolation_dist</span> <span class="o">=</span> <span class="n">M_noise</span><span class="p">[</span><span class="n">nClustSpikes</span><span class="p">]</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">isolation_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
		<span class="k">except</span><span class="p">:</span>
			<span class="n">isolation_dist</span> <span class="o">=</span> <span class="n">L_ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
		<span class="k">return</span> <span class="n">L_ratio</span><span class="p">,</span> <span class="n">isolation_dist</span></div>

	<span class="k">def</span> <span class="nf">_mahal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		gets the mahalanobis distance between two vectors u and v</span>
<span class="sd">		a blatant copy of the Mathworks fcn as it doesn&#39;t require the covariance</span>
<span class="sd">		matrix to be calculated which is a pain if there are NaNs in the matrix</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">u_sz</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span>
		<span class="n">v_sz</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span>
		<span class="k">if</span> <span class="n">u_sz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">v_sz</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
			<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Input size mismatch: matrices must have same number of columns&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">v_sz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">v_sz</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
			<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Too few rows: v must have more rows than columns&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">u</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">v</span><span class="p">)):</span>
			<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;No complex inputs are allowed&#39;</span><span class="p">)</span>
		<span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
		<span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">reps</span><span class="o">=</span><span class="p">(</span><span class="n">u_sz</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">))</span>
		<span class="n">C</span> <span class="o">=</span> <span class="n">v</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">reps</span><span class="o">=</span><span class="p">(</span><span class="n">v_sz</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">))</span>
		<span class="n">Q</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
		<span class="n">ri</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="p">(</span><span class="n">u</span><span class="o">-</span><span class="n">M</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
		<span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ri</span> <span class="o">*</span> <span class="n">ri</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="p">(</span><span class="n">v_sz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">d</span>

<div class="viewcode-block" id="SpikeCalcs.plotClusterSpace"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.spikecalcs.SpikeCalcs.plotClusterSpace">[docs]</a>	<span class="k">def</span> <span class="nf">plotClusterSpace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clusters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="s1">&#39;Amp&#39;</span><span class="p">,</span> <span class="n">clusts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		TODO: aspect of plot boxes in ImageGrid not right as scaled by range of</span>
<span class="sd">		values now</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="kn">import</span> <span class="nn">tintColours</span> <span class="k">as</span> <span class="nn">tcols</span>
		<span class="kn">import</span> <span class="nn">matplotlib.colors</span> <span class="k">as</span> <span class="nn">colors</span>
		<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>
		<span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1</span> <span class="kn">import</span> <span class="n">ImageGrid</span>
		
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
			<span class="n">clusters</span> <span class="o">=</span> <span class="p">[</span><span class="n">clusters</span><span class="p">]</span>

		<span class="n">amps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getParam</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">param</span><span class="p">)</span>
		<span class="n">bad_electrodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">amps</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">cmap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">tcols</span><span class="o">.</span><span class="n">colours</span><span class="p">[</span><span class="mi">0</span><span class="p">],(</span><span class="n">bins</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
		<span class="n">cmap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">cmap</span> <span class="o">=</span> <span class="n">colors</span><span class="o">.</span><span class="n">ListedColormap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
		<span class="n">cmap</span><span class="o">.</span><span class="n">_init</span><span class="p">()</span>
		<span class="n">alpha_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cmap</span><span class="o">.</span><span class="n">N</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span>
		<span class="n">alpha_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="n">cmap</span><span class="o">.</span><span class="n">_lut</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha_vals</span>
		<span class="n">cmb</span> <span class="o">=</span> <span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span>
		<span class="k">if</span> <span class="s1">&#39;fig&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">fig</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fig&#39;</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
		<span class="k">if</span> <span class="s1">&#39;rect&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">rect</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;rect&#39;</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">rect</span> <span class="o">=</span> <span class="mi">111</span>
		<span class="n">grid</span> <span class="o">=</span> <span class="n">ImageGrid</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">rect</span><span class="p">,</span> <span class="n">nrows_ncols</span><span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">axes_pad</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="k">if</span> <span class="s1">&#39;Amp&#39;</span> <span class="ow">in</span> <span class="n">param</span><span class="p">:</span>
			<span class="n">myRange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">scaling</span><span class="o">*</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaling</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">myRange</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="n">clustCMap0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">tcols</span><span class="o">.</span><span class="n">colours</span><span class="p">[</span><span class="mi">0</span><span class="p">],(</span><span class="n">bins</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
		<span class="n">clustCMap0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">clustCMap0</span> <span class="o">=</span> <span class="n">colors</span><span class="o">.</span><span class="n">ListedColormap</span><span class="p">(</span><span class="n">clustCMap0</span><span class="p">)</span>
		<span class="n">clustCMap0</span><span class="o">.</span><span class="n">_init</span><span class="p">()</span>
		<span class="n">clustCMap0</span><span class="o">.</span><span class="n">_lut</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha_vals</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cmb</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bad_electrodes</span><span class="p">:</span>
				<span class="n">h</span><span class="p">,</span> <span class="n">ye</span><span class="p">,</span> <span class="n">xe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">(</span><span class="n">amps</span><span class="p">[:,</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">amps</span><span class="p">[:,</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="nb">range</span> <span class="o">=</span> <span class="n">myRange</span><span class="p">[:,</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">)</span>
				<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xe</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ye</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
				<span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">clustCMap0</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;face&#39;</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">clusters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
					<span class="k">for</span> <span class="n">thisclust</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
						<span class="n">clustidx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="o">==</span> <span class="n">thisclust</span>
						<span class="n">h</span><span class="p">,</span> <span class="n">ye</span><span class="p">,</span> <span class="n">xe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">(</span><span class="n">amps</span><span class="p">[</span><span class="n">clustidx</span><span class="p">,</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="n">amps</span><span class="p">[</span><span class="n">clustidx</span><span class="p">,</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="nb">range</span><span class="o">=</span><span class="n">myRange</span><span class="p">[:,</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">)</span>
						<span class="n">clustCMap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">tcols</span><span class="o">.</span><span class="n">colours</span><span class="p">[</span><span class="n">thisclust</span><span class="p">],(</span><span class="n">bins</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
						<span class="n">clustCMap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
						<span class="n">clustCMap</span> <span class="o">=</span> <span class="n">colors</span><span class="o">.</span><span class="n">ListedColormap</span><span class="p">(</span><span class="n">clustCMap</span><span class="p">)</span>
						<span class="n">clustCMap</span><span class="o">.</span><span class="n">_init</span><span class="p">()</span>
						<span class="n">clustCMap</span><span class="o">.</span><span class="n">_lut</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha_vals</span>
						<span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">clustCMap</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;face&#39;</span><span class="p">)</span>
			<span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; v &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s1">&#39;small&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>
			<span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">xe</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">xe</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
			<span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ye</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">ye</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
		<span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">],</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">get_yticklabels</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">],</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">fig</span></div>

<div class="viewcode-block" id="SpikeCalcs.p2t_time"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.spikecalcs.SpikeCalcs.p2t_time">[docs]</a>	<span class="k">def</span> <span class="nf">p2t_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		The peak to trough time of a spike in ms</span>
<span class="sd">		</span>
<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		cluster: int</span>
<span class="sd">			the cluster whose waveforms are to be analysed</span>
<span class="sd">			</span>
<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		p2t: float</span>
<span class="sd">			The mean peak-to-trough time for the channel (electrode) that has </span>
<span class="sd">			the strongest (highest amplitude) signal. Units are ms</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">waveforms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">waveforms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cut</span><span class="o">==</span><span class="n">cluster</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
		<span class="n">best_chan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">tP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getParam</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="s1">&#39;tP&#39;</span><span class="p">)</span>
		<span class="n">tT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getParam</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="s1">&#39;tT&#39;</span><span class="p">)</span>
		<span class="n">mn_tP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">tP</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">mn_tT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">tT</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">p2t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mn_tP</span><span class="p">[</span><span class="n">best_chan</span><span class="p">]</span> <span class="o">-</span> <span class="n">mn_tT</span><span class="p">[</span><span class="n">best_chan</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">p2t</span> <span class="o">*</span> <span class="mi">1000</span></div>
		
<div class="viewcode-block" id="SpikeCalcs.half_amp_dur"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.spikecalcs.SpikeCalcs.half_amp_dur">[docs]</a>	<span class="k">def</span> <span class="nf">half_amp_dur</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Half amplitude duration of a spike</span>
<span class="sd">		</span>
<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		A: ndarray</span>
<span class="sd">			An nSpikes x nElectrodes x nSamples array</span>
<span class="sd">			</span>
<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		had: float</span>
<span class="sd">			The half-amplitude duration for the channel (electrode) that has </span>
<span class="sd">			the strongest (highest amplitude) signal. Units are ms</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">interpolate</span><span class="p">,</span> <span class="n">optimize</span>
		
		<span class="n">waveforms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">waveforms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cut</span><span class="o">==</span><span class="n">cluster</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
		<span class="n">best_chan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">mn_wvs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">wvs</span> <span class="o">=</span> <span class="n">mn_wvs</span><span class="p">[</span><span class="n">best_chan</span><span class="p">,</span> <span class="p">:]</span>
		<span class="n">half_amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">wvs</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
		<span class="n">half_amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">wvs</span><span class="p">)</span> <span class="o">+</span> <span class="n">half_amp</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mf">1000.</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
		<span class="c1"># create functions from the data using PiecewisePolynomial</span>
		<span class="n">p1</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">PiecewisePolynomial</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">wvs</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
		<span class="n">p2</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">PiecewisePolynomial</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">half_amp</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
		<span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span>
		<span class="n">xs</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
		<span class="n">x_min</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
		<span class="n">x_max</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
		<span class="n">x_mid</span> <span class="o">=</span> <span class="n">xs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
		<span class="n">roots</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">x_mid</span><span class="p">:</span>
			<span class="n">root</span><span class="p">,</span> <span class="n">infodict</span><span class="p">,</span> <span class="n">ier</span><span class="p">,</span> <span class="n">mesg</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">fsolve</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">p1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="n">p2</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">val</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">ier</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">x_min</span> <span class="o">&lt;</span> <span class="n">root</span> <span class="o">&lt;</span> <span class="n">x_max</span><span class="p">:</span>
				<span class="n">roots</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">roots</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">roots</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
		<span class="k">return</span> <span class="n">r</span></div>

<div class="viewcode-block" id="SpikeCalcs.getParam"><a class="viewcode-back" href="../../../source/ephysiopy.dacq2py.html#ephysiopy.dacq2py.spikecalcs.SpikeCalcs.getParam">[docs]</a>	<span class="k">def</span> <span class="nf">getParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveforms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="s1">&#39;Amp&#39;</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">fet</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Returns the requested parameter from a spike train as a numpy array</span>
<span class="sd">		</span>
<span class="sd">		Parameters</span>
<span class="sd">		-------------------</span>
<span class="sd">		</span>
<span class="sd">		waveforms - numpy array		</span>
<span class="sd">			Shape of array can be an nSpikes x nSamples</span>
<span class="sd">			OR</span>
<span class="sd">			a nSpikes x nElectrodes x nSamples</span>
<span class="sd">		</span>
<span class="sd">		param - str</span>
<span class="sd">			Valid values are:</span>
<span class="sd">				&#39;Amp&#39; - peak-to-trough amplitude (default)</span>
<span class="sd">				&#39;P&#39; - height of peak</span>
<span class="sd">				&#39;T&#39; - depth of trough</span>
<span class="sd">				&#39;Vt&#39; height at time t</span>
<span class="sd">				&#39;tP&#39; - time of peak (in seconds)</span>
<span class="sd">				&#39;tT&#39; - time of trough (in seconds)</span>
<span class="sd">				&#39;PCA&#39; - first n fet principal components (defaults to 1)</span>
<span class="sd">				</span>
<span class="sd">		t - int</span>
<span class="sd">			The time used for Vt</span>
<span class="sd">			</span>
<span class="sd">		fet - int</span>
<span class="sd">			The number of principal components (used with param &#39;PCA&#39;)</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">interpolate</span>
		<span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>
		
		<span class="k">if</span> <span class="n">waveforms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">waveforms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">waveforms</span>
			
		<span class="k">if</span> <span class="n">param</span> <span class="o">==</span> <span class="s1">&#39;Amp&#39;</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">elif</span> <span class="n">param</span> <span class="o">==</span> <span class="s1">&#39;P&#39;</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">elif</span> <span class="n">param</span> <span class="o">==</span> <span class="s1">&#39;T&#39;</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">elif</span> <span class="n">param</span> <span class="o">==</span> <span class="s1">&#39;Vt&#39;</span><span class="p">:</span>
			<span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1000</span><span class="p">,</span><span class="mi">20</span><span class="p">)</span>
			<span class="n">f</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span> <span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
				<span class="k">return</span> <span class="n">waveforms</span><span class="p">[:,</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">))]</span>
			<span class="k">elif</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
				<span class="k">return</span> <span class="n">waveforms</span><span class="p">[:,</span> <span class="p">:,</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">))]</span>
		<span class="k">elif</span> <span class="n">param</span> <span class="o">==</span> <span class="s1">&#39;tP&#39;</span><span class="p">:</span>
			<span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">m</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mf">1000.</span><span class="p">])</span>
			<span class="k">return</span> <span class="n">m</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
		<span class="k">elif</span> <span class="n">param</span> <span class="o">==</span> <span class="s1">&#39;tT&#39;</span><span class="p">:</span>
			<span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">m</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mf">1000.</span><span class="p">])</span>
			<span class="k">return</span> <span class="n">m</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
		<span class="k">elif</span> <span class="n">param</span> <span class="o">==</span> <span class="s1">&#39;PCA&#39;</span><span class="p">:</span>
			<span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">fet</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
				<span class="k">return</span> <span class="n">pca</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">waveforms</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">waveforms</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
			<span class="k">elif</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
				<span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">waveforms</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">fet</span><span class="p">))</span>
				<span class="n">st</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">fet</span><span class="p">,</span> <span class="n">fet</span><span class="p">)</span>
				<span class="n">en</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">fet</span><span class="p">,</span> <span class="n">fet</span> <span class="o">+</span> <span class="p">(</span><span class="n">waveforms</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">fet</span><span class="p">),</span> <span class="n">fet</span><span class="p">)</span>
				<span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">st</span><span class="p">,</span> <span class="n">en</span><span class="p">))</span>
				<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">waveforms</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
					<span class="k">if</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">waveforms</span><span class="p">[:,</span><span class="n">i</span><span class="p">,:])):</span>
						<span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">waveforms</span><span class="p">[:,</span><span class="n">i</span><span class="p">,:]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">())</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">waveforms</span><span class="p">[:,</span><span class="n">i</span><span class="p">,:]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()))</span>
						<span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
							<span class="n">out</span><span class="p">[:,</span><span class="n">rng</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">]:</span><span class="n">rng</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
						<span class="k">else</span><span class="p">:</span>
							<span class="n">out</span><span class="p">[:,</span><span class="n">rng</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">]:</span><span class="n">rng</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">A</span>
				<span class="k">return</span> <span class="n">out</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Robin Hayman

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>