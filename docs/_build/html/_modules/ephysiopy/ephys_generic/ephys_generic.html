

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ephysiopy.ephys_generic.ephys_generic &mdash; ephysiopy 1.5.55 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> ephysiopy
          

          
          </a>

          
            
            
              <div class="version">
                1.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../source/README.html">Synopsis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../source/README.html#installation">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../source/README.html#code-example">Code Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../source/README.html#motivation">Motivation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../source/README.html#contributors">Contributors</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">ephysiopy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>ephysiopy.ephys_generic.ephys_generic</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for ephysiopy.ephys_generic.ephys_generic</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The classes contained in this module are supposed to be agnostic to recording format</span>
<span class="sd">and encapsulate some generic mechanisms for producing things like spike timing</span>
<span class="sd">autocorrelograms, power spectrum calculation and so on</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span><span class="p">,</span> <span class="n">spatial</span><span class="p">,</span> <span class="n">misc</span><span class="p">,</span> <span class="n">ndimage</span>
<span class="kn">import</span> <span class="nn">skimage</span> <span class="k">as</span> <span class="nn">skimage</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="kn">import</span> <span class="nn">matplotlib.pylab</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib.cm</span> <span class="k">as</span> <span class="nn">cm</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1</span> <span class="kn">import</span> <span class="n">make_axes_locatable</span>
<span class="kn">import</span> <span class="nn">matplotlib.transforms</span> <span class="k">as</span> <span class="nn">transforms</span>
<span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="kn">import</span> <span class="n">Rectangle</span>
<span class="kn">from</span> <span class="nn">ephysiopy.ephys_generic</span> <span class="kn">import</span> <span class="n">binning</span>
<span class="kn">from</span> <span class="nn">ephysiopy.dacq2py</span> <span class="kn">import</span> <span class="n">tintcolours</span> <span class="k">as</span> <span class="n">tcols</span>

<div class="viewcode-block" id="SpikeCalcsGeneric"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric">[docs]</a><span class="k">class</span> <span class="nc">SpikeCalcsGeneric</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Deals with the processing and analysis of spike timing data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    spike_times : array_like</span>
<span class="sd">        the times of &#39;spikes&#39; in the trial</span>
<span class="sd">        this should be all spikes as the cluster identity vector _spk_clusters</span>
<span class="sd">        is used to pick out the right spikes</span>
<span class="sd">    waveforms : np.array, optional</span>
<span class="sd">        not sure on shape yet but will be something like a</span>
<span class="sd">        a 4 x nSpikes x nSamples (4 for tetrode-based analysis)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Units for time are provided as per the sample rate but converted internally to milliseconds</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spike_times</span><span class="p">,</span> <span class="n">waveforms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span> <span class="o">=</span> <span class="n">spike_times</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">waveforms</span> <span class="o">=</span> <span class="n">waveforms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_event_ts</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># the times that events occured i.e. the laser came on</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_spk_clusters</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># vector of cluster ids, same length as spike_times</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_event_window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="o">-</span><span class="mf">0.050</span><span class="p">,</span> <span class="mf">0.100</span><span class="p">))</span> <span class="c1"># window, in seconds, either side of the stimulus, to examine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stim_width</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># the width, in ms, of the stimulus</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_secs_per_bin</span> <span class="o">=</span> <span class="mf">0.001</span> <span class="c1"># used to increase / decrease size of bins in psth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sample_rate</span> <span class="o">=</span> <span class="mi">30000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_duration</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sample_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sample_rate</span>

    <span class="nd">@sample_rate</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">sample_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sample_rate</span> <span class="o">=</span> <span class="n">value</span>

<div class="viewcode-block" id="SpikeCalcsGeneric.n_spikes"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.n_spikes">[docs]</a>    <span class="k">def</span> <span class="nf">n_spikes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cluster</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spk_clusters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;No clusters available, please load some into me.&quot;</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_spk_clusters</span><span class="o">==</span><span class="n">cluster</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">event_ts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_event_ts</span>

    <span class="nd">@event_ts</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">event_ts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_event_ts</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">duration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_duration</span>

    <span class="nd">@duration</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">duration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_duration</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spk_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spk_clusters</span>

    <span class="nd">@spk_clusters</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">spk_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_spk_clusters</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">event_window</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_event_window</span>

    <span class="nd">@event_window</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">event_window</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_event_window</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">stim_width</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stim_width</span>

    <span class="nd">@stim_width</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">stim_width</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stim_width</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_secs_per_bin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__secs_per_bin</span>

    <span class="nd">@_secs_per_bin</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">_secs_per_bin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__secs_per_bin</span> <span class="o">=</span> <span class="n">value</span>

<div class="viewcode-block" id="SpikeCalcsGeneric.trial_mean_fr"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.trial_mean_fr">[docs]</a>    <span class="k">def</span> <span class="nf">trial_mean_fr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span><span class="o">-&gt;</span><span class="nb">float</span><span class="p">:</span>
        <span class="c1"># Returns the trial mean firing rate for the cluster</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;No duration provided, give me one!&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_spikes</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">duration</span></div>

<div class="viewcode-block" id="SpikeCalcsGeneric.mean_isi_range"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.mean_isi_range">[docs]</a>    <span class="k">def</span> <span class="nf">mean_isi_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span><span class="o">-&gt;</span><span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the mean of the autocorrelation from 0 to n milliseconds</span>
<span class="sd">        Used to help classify a neruons type (principal, interneuron etc)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cluster : int</span>
<span class="sd">            The cluster to analyse</span>
<span class="sd">        n : int</span>
<span class="sd">            The range in milliseconds to calculate the mean over</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mean_isi_range : float</span>
<span class="sd">            The mean of the autocorrelogram between 0 and n milliseconds</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cluster</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spk_clusters</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Cluster not available&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="mi">201</span>
        <span class="n">trange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="o">-</span><span class="mi">500</span><span class="p">,</span> <span class="mi">500</span><span class="p">))</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">spk_clusters</span><span class="o">==</span><span class="n">cluster</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xcorr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">Trange</span><span class="o">=</span><span class="n">trange</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span> <span class="c1"># See xcorr docs</span>
        <span class="n">counts</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">y</span><span class="o">!=</span><span class="mi">0</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">trange</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">bins</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">bins</span><span class="o">&lt;</span><span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span></div>

<div class="viewcode-block" id="SpikeCalcsGeneric.xcorr"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.xcorr">[docs]</a>    <span class="k">def</span> <span class="nf">xcorr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">x2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Trange</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the histogram of the ISIs in x1 or x1 vs x2</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x1, x2 : array_like</span>
<span class="sd">            The times of the spikes emitted by the cluster(s)</span>
<span class="sd">            NB must be signed int to accomodate negative times</span>
<span class="sd">        Trange : array_like</span>
<span class="sd">            Range of times to bin up. Defaults to [-500, +500] in ms</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y : np.ndarray</span>
<span class="sd">            The time differences between spike times in x1 over the range</span>
<span class="sd">            of times defined Trange</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="n">x1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">Trange</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Trange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">500</span><span class="p">,</span> <span class="mi">500</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">Trange</span><span class="p">)</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="n">Trange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Trange</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">irange</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">Trange</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">dts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">irange</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dts</span><span class="p">):</span>
            <span class="n">y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">x2</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">y</span></div>

<div class="viewcode-block" id="SpikeCalcsGeneric.calculatePSTH"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.calculatePSTH">[docs]</a>    <span class="k">def</span> <span class="nf">calculatePSTH</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster_id</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the PSTH of event_ts against the spiking of a cell</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cluster_id : int</span>
<span class="sd">            The cluster for which to calculate the psth</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        x, y : list</span>
<span class="sd">            The list of time differences between the spikes of the cluster</span>
<span class="sd">            and the events (x) and the trials (y)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_event_ts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Need some event timestamps! Aborting&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spk_clusters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Need cluster identities! Aborting&quot;</span><span class="p">)</span>
        <span class="n">event_ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_ts</span>
        <span class="n">event_ts</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">event_ts</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">event_ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">event_ts</span><span class="p">)</span>

        <span class="n">spike_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">spk_clusters</span> <span class="o">==</span> <span class="n">cluster_id</span><span class="p">]</span>
        <span class="n">irange</span> <span class="o">=</span> <span class="n">event_ts</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_window</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">dts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">spike_times</span><span class="p">,</span> <span class="n">irange</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dts</span><span class="p">):</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">spike_times</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">event_ts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
            <span class="n">y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">tmp</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span></div>

<div class="viewcode-block" id="SpikeCalcsGeneric.plotPSTH"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.plotPSTH">[docs]</a>    <span class="k">def</span> <span class="nf">plotPSTH</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the PSTH for a cluster</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cluster : int</span>
<span class="sd">            The cluster to examine</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cluster, i : int</span>
<span class="sd">            The cluster and a junk variable (not sure why for now)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculatePSTH</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
        <span class="n">show</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># used below to show the figure or leave this to the caller</span>
        <span class="k">if</span> <span class="n">fig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">4.0</span><span class="p">,</span><span class="mf">7.0</span><span class="p">))</span>
            <span class="n">show</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">scatter_ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="n">scatter_ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">rasterized</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">scatter_ax</span><span class="p">)</span>
        <span class="n">scatter_ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">event_window</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_window</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">scatter_ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">event_window</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">event_window</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
        <span class="n">hist_ax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;top&quot;</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="n">scatter_ax</span><span class="p">,</span>
                                      <span class="n">transform</span><span class="o">=</span><span class="n">scatter_ax</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>
        <span class="n">scattTrans</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">blended_transform_factory</span><span class="p">(</span><span class="n">scatter_ax</span><span class="o">.</span><span class="n">transData</span><span class="p">,</span>
                                                          <span class="n">scatter_ax</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_width</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scatter_ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">Rectangle</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">width</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stim_width</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                        <span class="n">transform</span><span class="o">=</span><span class="n">scattTrans</span><span class="p">,</span>
                        <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">))</span>
            <span class="n">histTrans</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">blended_transform_factory</span><span class="p">(</span><span class="n">hist_ax</span><span class="o">.</span><span class="n">transData</span><span class="p">,</span>
                                                             <span class="n">hist_ax</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>
            <span class="n">hist_ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">Rectangle</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">width</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stim_width</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                              <span class="n">transform</span><span class="o">=</span><span class="n">histTrans</span><span class="p">,</span>
                              <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">))</span>
        <span class="n">scatter_ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Laser stimulation events&#39;</span><span class="p">,</span> <span class="n">labelpad</span><span class="o">=-</span><span class="mf">18.5</span><span class="p">)</span>
        <span class="n">scatter_ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time to stimulus onset(secs)&#39;</span><span class="p">)</span>
        <span class="n">nStms</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">event_ts</span><span class="p">))</span>
        <span class="n">scatter_ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nStms</span><span class="p">)</span>
        <span class="c1"># Label only the min and max of the y-axis</span>
        <span class="n">ylabels</span> <span class="o">=</span> <span class="n">scatter_ax</span><span class="o">.</span><span class="n">get_yticklabels</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ylabels</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">ylabels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">yticks</span> <span class="o">=</span> <span class="n">scatter_ax</span><span class="o">.</span><span class="n">get_yticklines</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">yticks</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">yticks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">histColor</span> <span class="o">=</span> <span class="p">[</span><span class="mi">192</span><span class="o">/</span><span class="mf">255.0</span><span class="p">,</span><span class="mi">192</span><span class="o">/</span><span class="mf">255.0</span><span class="p">,</span><span class="mi">192</span><span class="o">/</span><span class="mf">255.0</span><span class="p">]</span>
        <span class="n">hist_ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">event_window</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_window</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_secs_per_bin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_secs_per_bin</span><span class="p">),</span>
                             <span class="n">color</span><span class="o">=</span><span class="n">histColor</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">event_window</span><span class="p">,</span> <span class="n">rasterized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">histtype</span><span class="o">=</span><span class="s1">&#39;stepfilled&#39;</span><span class="p">)</span>
        <span class="n">hist_ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Spike count&quot;</span><span class="p">,</span> <span class="n">labelpad</span><span class="o">=-</span><span class="mf">2.5</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">hist_ax</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">(),</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Label only the min and max of the y-axis</span>
        <span class="n">ylabels</span> <span class="o">=</span> <span class="n">hist_ax</span><span class="o">.</span><span class="n">get_yticklabels</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ylabels</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">ylabels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">yticks</span> <span class="o">=</span> <span class="n">hist_ax</span><span class="o">.</span><span class="n">get_yticklines</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">yticks</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">yticks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">hist_ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">event_window</span><span class="p">)</span>
        <span class="n">scatter_ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">event_window</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">yield</span> <span class="n">cluster</span><span class="p">,</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="SpikeCalcsGeneric.plotAllXCorrs"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.plotAllXCorrs">[docs]</a>    <span class="k">def</span> <span class="nf">plotAllXCorrs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots all xcorrs in a single figure window</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        clusters : list</span>
<span class="sd">            The clusters to plot</span>
<span class="sd">        fig : matplotlib.figure instance, optional, default None</span>
<span class="sd">            If provided the figure will contain all the axes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">ephysiopy.dacq2py</span> <span class="kn">import</span> <span class="n">spikecalcs</span>
        <span class="n">SpkCalcs</span> <span class="o">=</span> <span class="n">spikecalcs</span><span class="o">.</span><span class="n">SpikeCalcs</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">fig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">))</span>

        <span class="n">nrows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">wspace</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span><span class="n">hspace</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">clusters</span><span class="p">):</span>
            <span class="n">cluster_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spk_clusters</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">cluster_ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spike_times</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">])</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span><span class="n">nrows</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">SpkCalcs</span><span class="o">.</span><span class="n">xcorr</span><span class="p">(</span><span class="n">cluster_ts</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">))</span> <span class="c1"># ms</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="mi">201</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">500</span><span class="p">,</span> <span class="mi">500</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">histtype</span><span class="o">=</span><span class="s1">&#39;stepfilled&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="mi">500</span><span class="p">,</span><span class="mi">500</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">((</span><span class="o">-</span><span class="mi">500</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">500</span><span class="p">))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="o">-</span><span class="mi">500</span><span class="p">),</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="mi">500</span><span class="p">)),</span><span class="n">fontweight</span><span class="o">=</span><span class="s1">&#39;normal&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">bottom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">fontweight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div></div>

<div class="viewcode-block" id="SpikeCalcsTetrode"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsTetrode">[docs]</a><span class="k">class</span> <span class="nc">SpikeCalcsTetrode</span><span class="p">(</span><span class="n">SpikeCalcsGeneric</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Encapsulates methods specific to the geometry inherent in tetrode-based</span>
<span class="sd">    recordings</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="SpikeCalcsProbe"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsProbe">[docs]</a><span class="k">class</span> <span class="nc">SpikeCalcsProbe</span><span class="p">(</span><span class="n">SpikeCalcsGeneric</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Encapsulates methods specific to probe-based recordings</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="EEGCalcsGeneric"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.EEGCalcsGeneric">[docs]</a><span class="k">class</span> <span class="nc">EEGCalcsGeneric</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generic class for processing and analysis of EEG data</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sig : array_like</span>
<span class="sd">        The signal (of the LFP data)</span>
<span class="sd">    fs  : float</span>
<span class="sd">        The sample rate</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">fs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">=</span> <span class="n">fs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thetaRange</span> <span class="o">=</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">12</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outsideRange</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">125</span><span class="p">]</span>
        <span class="c1"># for smoothing and plotting of power spectrum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">smthKernelWidth</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">smthKernelSigma</span> <span class="o">=</span> <span class="mf">0.1875</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sn2Width</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxFreq</span> <span class="o">=</span> <span class="mi">125</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxPow</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_nextpow2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span> <span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the next power of 2 that will hold val</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">val</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">val</span>
        <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="n">val</span>
        <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">val</span>
        <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">val</span>
        <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">val</span>
        <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span> <span class="n">val</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">val</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="EEGCalcsGeneric.butterFilter"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.EEGCalcsGeneric.butterFilter">[docs]</a>    <span class="k">def</span> <span class="nf">butterFilter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">low</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">high</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filters self.sig with a butterworth filter with a bandpass filter</span>
<span class="sd">        defined by low and high</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        low, high : float</span>
<span class="sd">            The lower and upper bounds of the bandpass filter</span>
<span class="sd">        order : int</span>
<span class="sd">            The order of the filter</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        filt : np.ndarray</span>
<span class="sd">            The filtered signal</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The signal is filtered in both the forward and reverse directions (scipy.signal.filtfilt)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nyqlim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">lowcut</span> <span class="o">=</span> <span class="n">low</span> <span class="o">/</span> <span class="n">nyqlim</span>
        <span class="n">highcut</span> <span class="o">=</span> <span class="n">high</span> <span class="o">/</span> <span class="n">nyqlim</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="p">[</span><span class="n">lowcut</span><span class="p">,</span> <span class="n">highcut</span><span class="p">],</span> <span class="n">btype</span><span class="o">=</span><span class="s1">&#39;band&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig</span><span class="p">)</span></div>

<div class="viewcode-block" id="EEGCalcsGeneric.calcEEGPowerSpectrum"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.EEGCalcsGeneric.calcEEGPowerSpectrum">[docs]</a>    <span class="k">def</span> <span class="nf">calcEEGPowerSpectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the power spectrum of self.sig</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing. Sets a bunch of instance variables for the first time including</span>
<span class="sd">            freqs : array_like</span>
<span class="sd">                The frequencies at which the spectrogram was calculated</span>
<span class="sd">            power : array_like</span>
<span class="sd">                The power at the frequencies defined above</span>
<span class="sd">            sm_power : array_like</span>
<span class="sd">                The smoothed power</span>
<span class="sd">            bandmaxpower : float</span>
<span class="sd">                The maximum power in the theta band</span>
<span class="sd">            freqatbandmaxpower : float</span>
<span class="sd">                The frequency at which the power is maximum</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nqlim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">origlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig</span><span class="p">)</span>
        <span class="n">fftlen</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nextpow2</span><span class="p">(</span><span class="n">origlen</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">freqs</span><span class="p">,</span> <span class="n">power</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">periodogram</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="n">return_onesided</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nfft</span><span class="o">=</span><span class="n">fftlen</span><span class="p">)</span>
        <span class="n">ffthalflen</span> <span class="o">=</span> <span class="n">fftlen</span> <span class="o">/</span> <span class="mi">2</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">binsperhz</span> <span class="o">=</span> <span class="p">(</span><span class="n">ffthalflen</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">nqlim</span>
        <span class="n">kernelsigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smthKernelSigma</span> <span class="o">*</span> <span class="n">binsperhz</span>
        <span class="n">smthkernelsigma</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="n">kernelsigma</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">gausswin</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">smthkernelsigma</span><span class="p">,</span> <span class="n">kernelsigma</span><span class="p">)</span>
        <span class="n">sm_power</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">fftconvolve</span><span class="p">(</span><span class="n">power</span><span class="p">,</span> <span class="n">gausswin</span><span class="p">,</span> <span class="s1">&#39;same&#39;</span><span class="p">)</span>
        <span class="n">sm_power</span> <span class="o">=</span> <span class="n">sm_power</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sm_power</span><span class="p">))</span>
        <span class="n">spectrummaskband</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">freqs</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">thetaRange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freqs</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">thetaRange</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">bandmaxpower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">sm_power</span><span class="p">[</span><span class="n">spectrummaskband</span><span class="p">])</span>
        <span class="n">maxbininband</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">sm_power</span><span class="p">[</span><span class="n">spectrummaskband</span><span class="p">])</span>
        <span class="n">bandfreqs</span> <span class="o">=</span> <span class="n">freqs</span><span class="p">[</span><span class="n">spectrummaskband</span><span class="p">]</span>
        <span class="n">freqatbandmaxpower</span> <span class="o">=</span> <span class="n">bandfreqs</span><span class="p">[</span><span class="n">maxbininband</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">freqs</span> <span class="o">=</span> <span class="n">freqs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">power</span> <span class="o">=</span> <span class="n">power</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sm_power</span> <span class="o">=</span> <span class="n">sm_power</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bandmaxpower</span> <span class="o">=</span> <span class="n">bandmaxpower</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">freqatbandmaxpower</span> <span class="o">=</span> <span class="n">freqatbandmaxpower</span></div>

<div class="viewcode-block" id="EEGCalcsGeneric.plotPowerSpectrum"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.EEGCalcsGeneric.plotPowerSpectrum">[docs]</a>    <span class="k">def</span> <span class="nf">plotPowerSpectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># calculate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calcEEGPowerSpectrum</span><span class="p">()</span>
        <span class="c1"># plotting</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pylab</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
        <span class="n">freqs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">50</span><span class="p">]</span>
        <span class="n">power</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">power</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">50</span><span class="p">]</span>
        <span class="n">sm_power</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sm_power</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">50</span><span class="p">]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mf">0.8627</span><span class="p">,</span> <span class="mf">0.8627</span><span class="p">,</span> <span class="mf">0.8627</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">sm_power</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxFreq</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;ylim&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">ylim</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ylim&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ylim</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bandmaxpower</span> <span class="o">/</span> <span class="mf">0.8</span><span class="p">]</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ylim</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Power&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">thetaRange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mf">0.9</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bandmaxpower</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">freqatbandmaxpower</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="kn">import</span> <span class="n">Rectangle</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">Rectangle</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">thetaRange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">),</span> <span class="n">width</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thetaRange</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">height</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">())[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">ec</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

<div class="viewcode-block" id="EEGCalcsGeneric.plotEventEEG"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.EEGCalcsGeneric.plotEventEEG">[docs]</a>    <span class="k">def</span> <span class="nf">plotEventEEG</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event_ts</span><span class="p">,</span> <span class="n">event_window</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">),</span> <span class="n">stim_width</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">=</span><span class="mf">3e4</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the mean eeg +- std. dev centred on event timestamps</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        event_ts : array_like</span>
<span class="sd">            The event timestamps in seconds</span>
<span class="sd">        event_window : 2-tuple, default = (-0.05, 0.1)</span>
<span class="sd">            The pre- and post-stimulus window to examine. In seconds.</span>
<span class="sd">            Defaults to the previous 50ms and the subsequent 100ms</span>
<span class="sd">        stim_width : float</span>
<span class="sd">            The duration of the stimulus. Used for plotting</span>
<span class="sd">        sample_rate : float</span>
<span class="sd">            The sample rate of the events</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># bandpass filter the raw data first</span>
        <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>
        <span class="n">nyq</span> <span class="o">=</span> <span class="n">sample_rate</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">highlim</span> <span class="o">=</span> <span class="mi">500</span> <span class="o">/</span> <span class="n">nyq</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">highlim</span><span class="p">,</span> <span class="n">btype</span><span class="o">=</span><span class="s1">&#39;lowpass&#39;</span><span class="p">)</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig</span><span class="p">)</span>

        <span class="n">event_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">event_ts</span><span class="o">*</span><span class="n">sample_rate</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">event_window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">event_window</span><span class="p">)</span>

        <span class="n">max_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">event_window</span><span class="o">*</span><span class="n">sample_rate</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">num_events</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">event_ts</span><span class="p">)</span>
        <span class="n">eeg_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">num_events</span><span class="p">,</span> <span class="n">max_samples</span><span class="p">])</span>
        <span class="n">st</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">event_window</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">sample_rate</span><span class="p">)</span>
        <span class="n">en</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">event_window</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">sample_rate</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">eeg_idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">event_idx</span><span class="p">):</span>
            <span class="n">eeg_array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">sig</span><span class="p">[</span><span class="n">eeg_idx</span><span class="o">+</span><span class="n">st</span><span class="p">:</span><span class="n">eeg_idx</span><span class="o">+</span><span class="n">en</span><span class="p">]</span>
        <span class="n">mn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">eeg_array</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">se</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">eeg_array</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">num_events</span><span class="p">)</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pylab</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="c1"># from mpl_toolkits.axes_grid1 import make_axes_locatable</span>
        <span class="kn">import</span> <span class="nn">matplotlib.transforms</span> <span class="k">as</span> <span class="nn">transforms</span>
        <span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="kn">import</span> <span class="n">Rectangle</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">event_window</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">event_window</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">mn</span><span class="p">)),</span> <span class="n">mn</span><span class="p">,</span> <span class="n">yerr</span><span class="o">=</span><span class="n">se</span><span class="p">,</span> <span class="n">rasterized</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">event_window</span><span class="p">)</span>
        <span class="n">axTrans</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">blended_transform_factory</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">transData</span><span class="p">,</span>
                                                           <span class="n">ax</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">Rectangle</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">width</span><span class="o">=</span><span class="n">stim_width</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                             <span class="n">transform</span><span class="o">=</span><span class="n">axTrans</span><span class="p">,</span>
                             <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;LFP ($\mu$V)&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time(s)&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div></div>

<div class="viewcode-block" id="PosCalcsGeneric"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric">[docs]</a><span class="k">class</span> <span class="nc">PosCalcsGeneric</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generic class for post-processing of position data</span>
<span class="sd">    Uses numpys masked arrays for dealing with bad positions, filtering etc</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x, y : array_like</span>
<span class="sd">        The x and y positions.</span>
<span class="sd">    ppm : int</span>
<span class="sd">        Pixels per metre</span>
<span class="sd">    cm : boolean</span>
<span class="sd">        Whether everything is converted into cms or not</span>
<span class="sd">    jumpmax : int</span>
<span class="sd">        Jumps in position (pixel coords) greater than this are bad</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The positional data (x,y) is turned into a numpy masked array once this</span>
<span class="sd">    class is initialised - that mask is then modified through various</span>
<span class="sd">    functions (postprocesspos being the main one).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ppm</span><span class="p">,</span> <span class="n">cm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">jumpmax</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dir</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">speed</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ppm</span> <span class="o">=</span> <span class="n">ppm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cm</span> <span class="o">=</span> <span class="n">cm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jumpmax</span> <span class="o">=</span> <span class="n">jumpmax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nleds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracker_params</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="PosCalcsGeneric.postprocesspos"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.postprocesspos">[docs]</a>    <span class="k">def</span> <span class="nf">postprocesspos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tracker_params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">-&gt;</span><span class="nb">tuple</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Post-process position data</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tracker_params : dict</span>
<span class="sd">            Same dict as created in OEKiloPhy.Settings.parsePos</span>
<span class="sd">            (from module openephys2py)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xy, hdir : np.ma.MaskedArray</span>
<span class="sd">            The post-processed position data</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Several internal functions are called here: speefilter, interpnans, smoothPos</span>
<span class="sd">        and calcSpeed. Some internal state/ instance variables are set as well. The</span>
<span class="sd">        mask of the positional data (an instance of numpy masked array) is modified</span>
<span class="sd">        throughout this method.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">x_zero</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="n">y_zero</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="n">xy</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">x_zero</span><span class="p">,</span> <span class="n">y_zero</span><span class="p">),</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tracker_params</span> <span class="o">=</span> <span class="n">tracker_params</span>
        <span class="k">if</span> <span class="s1">&#39;LeftBorder&#39;</span> <span class="ow">in</span> <span class="n">tracker_params</span><span class="p">:</span>
            <span class="n">min_x</span> <span class="o">=</span> <span class="n">tracker_params</span><span class="p">[</span><span class="s1">&#39;LeftBorder&#39;</span><span class="p">]</span>
            <span class="n">xy</span><span class="p">[:,</span> <span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">&lt;=</span> <span class="n">min_x</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
        <span class="k">if</span> <span class="s1">&#39;TopBorder&#39;</span> <span class="ow">in</span> <span class="n">tracker_params</span><span class="p">:</span>
            <span class="n">min_y</span> <span class="o">=</span> <span class="n">tracker_params</span><span class="p">[</span><span class="s1">&#39;TopBorder&#39;</span><span class="p">]</span> <span class="c1"># y origin at top</span>
            <span class="n">xy</span><span class="p">[:,</span> <span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">&lt;=</span> <span class="n">min_y</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
        <span class="k">if</span> <span class="s1">&#39;RightBorder&#39;</span> <span class="ow">in</span> <span class="n">tracker_params</span><span class="p">:</span>
            <span class="n">max_x</span> <span class="o">=</span> <span class="n">tracker_params</span><span class="p">[</span><span class="s1">&#39;RightBorder&#39;</span><span class="p">]</span>
            <span class="n">xy</span><span class="p">[:,</span> <span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">&gt;=</span> <span class="n">max_x</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
        <span class="k">if</span> <span class="s1">&#39;BottomBorder&#39;</span> <span class="ow">in</span> <span class="n">tracker_params</span><span class="p">:</span>
            <span class="n">max_y</span> <span class="o">=</span> <span class="n">tracker_params</span><span class="p">[</span><span class="s1">&#39;BottomBorder&#39;</span><span class="p">]</span>
            <span class="n">xy</span><span class="p">[:,</span> <span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">&gt;=</span> <span class="n">max_y</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
        <span class="k">if</span> <span class="s1">&#39;SampleRate&#39;</span> <span class="ow">in</span> <span class="n">tracker_params</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tracker_params</span><span class="p">[</span><span class="s1">&#39;SampleRate&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">=</span> <span class="mi">30</span>

        <span class="n">xy</span> <span class="o">=</span> <span class="n">xy</span><span class="o">.</span><span class="n">T</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">speedfilter</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpnans</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span> <span class="c1"># ADJUST THIS SO NP.MASKED ARE INTERPOLATED OVER</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoothPos</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calcSpeed</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span>

        <span class="kn">import</span> <span class="nn">math</span>
        <span class="n">pos2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npos</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">xy_f</span> <span class="o">=</span> <span class="n">xy</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dir</span><span class="p">[</span><span class="n">pos2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(((</span><span class="mi">180</span><span class="o">/</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="o">-</span><span class="n">xy_f</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">pos2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">xy_f</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">pos2</span><span class="p">],</span><span class="o">+</span><span class="n">xy_f</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">pos2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xy_f</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">pos2</span><span class="p">]))),</span> <span class="mi">360</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dir</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dir</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">hdir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dir</span>

        <span class="k">return</span> <span class="n">xy</span><span class="p">,</span> <span class="n">hdir</span></div>

<div class="viewcode-block" id="PosCalcsGeneric.speedfilter"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.speedfilter">[docs]</a>    <span class="k">def</span> <span class="nf">speedfilter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filters speed</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xy : np.ma.MaskedArray</span>
<span class="sd">            The xy data</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xy : np.ma.MaskedArray</span>
<span class="sd">            The xy data with speeds &gt; self.jumpmax masked</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">disp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">df</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">df</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">disp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">disp</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">xy</span><span class="p">[</span><span class="n">disp</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">jumpmax</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
        <span class="k">return</span> <span class="n">xy</span></div>

<div class="viewcode-block" id="PosCalcsGeneric.interpnans"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.interpnans">[docs]</a>    <span class="k">def</span> <span class="nf">interpnans</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xy</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">xy</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">missing</span> <span class="o">=</span> <span class="n">xy</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">ok</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">missing</span><span class="p">)</span>
            <span class="n">ok_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">ok</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span><span class="c1">#gets the indices of ok poses</span>
            <span class="n">missing_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">missing</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span><span class="c1">#get the indices of missing poses</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing_idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">good_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">xy</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">ok_idx</span><span class="p">,</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">good_data1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">xy</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">ok_idx</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">xy</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">missing_idx</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">missing_idx</span><span class="p">,</span><span class="n">ok_idx</span><span class="p">,</span><span class="n">good_data</span><span class="p">)</span><span class="c1">#,left=np.min(good_data),right=np.max(good_data)</span>
                    <span class="n">xy</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">missing_idx</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">missing_idx</span><span class="p">,</span><span class="n">ok_idx</span><span class="p">,</span><span class="n">good_data1</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">pass</span>
        <span class="n">xy</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> bad/ jumpy positions were interpolated over&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">missing_idx</span><span class="p">)))</span><span class="c1">#this is wrong i think</span>
        <span class="k">return</span> <span class="n">xy</span></div>

<div class="viewcode-block" id="PosCalcsGeneric.smoothPos"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.smoothPos">[docs]</a>    <span class="k">def</span> <span class="nf">smoothPos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Smooths position data</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xy : np.ma.MaskedArray</span>
<span class="sd">            The xy data</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xy : array_like</span>
<span class="sd">            The smoothed positional data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Extract boundaries of window used in recording</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">ephysiopy.ephys_generic.utils</span> <span class="kn">import</span> <span class="n">smooth</span>
        <span class="c1"># TODO: calculate window_len from pos sampling rate</span>
        <span class="c1"># 11 is roughly equal to 400ms at 30Hz (window_len needs to be odd)</span>
        <span class="n">sm_x</span> <span class="o">=</span> <span class="n">smooth</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">window_len</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;flat&#39;</span><span class="p">)</span>
        <span class="n">sm_y</span> <span class="o">=</span> <span class="n">smooth</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">window_len</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;flat&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sm_x</span><span class="p">,</span> <span class="n">sm_y</span><span class="p">])</span></div>

<div class="viewcode-block" id="PosCalcsGeneric.calcSpeed"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.calcSpeed">[docs]</a>    <span class="k">def</span> <span class="nf">calcSpeed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates speed</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">        xy : np.ma.MaskedArray</span>
<span class="sd">            The xy positional data</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing. Sets self.speed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">speed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xy</span><span class="p">),</span><span class="mi">2</span><span class="p">),</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">speed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">speed</span><span class="p">,</span> <span class="n">speed</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cm</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">speed</span> <span class="o">*</span> <span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppm</span><span class="p">)</span> <span class="c1"># in cm/s now</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">speed</span></div>

<div class="viewcode-block" id="PosCalcsGeneric.upsamplePos"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.upsamplePos">[docs]</a>    <span class="k">def</span> <span class="nf">upsamplePos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xy</span><span class="p">,</span> <span class="n">upsample_rate</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Upsamples position data from 30 to upsample_rate</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">        xy : np.ma.MaskedArray</span>
<span class="sd">            The xy positional data</span>

<span class="sd">        upsample_rate : int</span>
<span class="sd">            The rate to upsample to</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_xy : np.ma.MaskedArray</span>
<span class="sd">            The upsampled xy positional data</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is mostly to get pos data recorded using PosTracker at 30Hz</span>
<span class="sd">        into Axona format 50Hz data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">upsample_rate</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
        <span class="n">new_xy</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">resample_poly</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">upsample_rate</span><span class="o">/</span><span class="n">denom</span><span class="p">,</span> <span class="mi">30</span><span class="o">/</span><span class="n">denom</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_xy</span></div></div>

<div class="viewcode-block" id="MapCalcsGeneric"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric">[docs]</a><span class="k">class</span> <span class="nc">MapCalcsGeneric</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Produces graphical output including but not limited to spatial</span>
<span class="sd">    analysis of data.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xy : array_like</span>
<span class="sd">        The positional data usually as a 2D numpy array</span>
<span class="sd">    hdir : array_like</span>
<span class="sd">        The head direction data usually a 1D numpy array</span>
<span class="sd">    pos_ts : array_like</span>
<span class="sd">        1D array of timestamps in seconds</span>
<span class="sd">    spk_ts : array_like</span>
<span class="sd">        1D array of timestamps in seconds</span>
<span class="sd">    plot_type : str or list</span>
<span class="sd">        Determines the plots produced. Legal values:</span>
<span class="sd">        [&#39;map&#39;,&#39;path&#39;,&#39;hdir&#39;,&#39;sac&#39;, &#39;speed&#39;]</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Output possible: </span>
<span class="sd">    * ratemaps (xy)</span>
<span class="sd">    * polar plots (heading direction)</span>
<span class="sd">    * grid cell spatial autocorrelograms</span>
<span class="sd">    * speed vs rate plots</span>

<span class="sd">    It is possible to iterate through instances of this class as it has a yield</span>
<span class="sd">    method defined</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xy</span><span class="p">,</span> <span class="n">hdir</span><span class="p">,</span> <span class="n">speed</span><span class="p">,</span> <span class="n">pos_ts</span><span class="p">,</span> <span class="n">spk_ts</span><span class="p">,</span> <span class="n">plot_type</span><span class="o">=</span><span class="s1">&#39;map&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">xy</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">xy</span> <span class="o">=</span> <span class="n">xy</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">xy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hdir</span> <span class="o">=</span> <span class="n">hdir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">speed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos_ts</span> <span class="o">=</span> <span class="n">pos_ts</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">spk_ts</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">spk_ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">spk_ts</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spk_ts</span> <span class="o">=</span> <span class="n">spk_ts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_type</span> <span class="o">=</span> <span class="n">plot_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spk_pos_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__interpSpkPosTimes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__good_clusters</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__spk_clusters</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_grid_output_location</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="p">(</span> <span class="s1">&#39;ppm&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__ppm</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ppm&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__ppm</span> <span class="o">=</span> <span class="mi">400</span>
        <span class="k">if</span> <span class="s1">&#39;pos_sample_rate&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;pos_sample_rate&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span> <span class="o">=</span> <span class="mi">30</span>
        <span class="k">if</span> <span class="s1">&#39;save_grid_summary_location&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save_grid_output_location</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;save_grid_summary_location&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">good_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__good_clusters</span>

    <span class="nd">@good_clusters</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">good_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__good_clusters</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spk_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__spk_clusters</span>

    <span class="nd">@spk_clusters</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">spk_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__spk_clusters</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ppm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ppm</span>

    <span class="nd">@ppm</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">ppm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__ppm</span> <span class="o">=</span> <span class="n">value</span>

<div class="viewcode-block" id="MapCalcsGeneric.plotAll"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.plotAll">[docs]</a>    <span class="k">def</span> <span class="nf">plotAll</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots rate maps and other graphical output</span>

<span class="sd">        Notes</span>
<span class="sd">        ----</span>
<span class="sd">        This method uses the data provided to the class instance to plot</span>
<span class="sd">        various maps into a single figure window for each cluster. The things</span>
<span class="sd">        to plot are given in self.plot_type and the list of clusters in self.good_clusters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;all&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_type</span><span class="p">:</span>
            <span class="n">what_to_plot</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">,</span><span class="s1">&#39;path&#39;</span><span class="p">,</span><span class="s1">&#39;hdir&#39;</span><span class="p">,</span><span class="s1">&#39;sac&#39;</span><span class="p">,</span><span class="s1">&#39;speed&#39;</span><span class="p">,</span> <span class="s1">&#39;sp_hd&#39;</span><span class="p">]</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">what_to_plot</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plot_type</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">what_to_plot</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span><span class="c1">#, constrained_layout=True)</span>
        <span class="k">if</span> <span class="s1">&#39;sac&#39;</span> <span class="ow">in</span> <span class="n">what_to_plot</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">ephysiopy.ephys_generic</span> <span class="kn">import</span> <span class="n">gridcell</span>
            <span class="n">S</span> <span class="o">=</span> <span class="n">gridcell</span><span class="o">.</span><span class="n">SAC</span><span class="p">()</span>
        <span class="kn">import</span> <span class="nn">matplotlib.gridspec</span> <span class="k">as</span> <span class="nn">gridspec</span>
        <span class="n">nrows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">good_clusters</span><span class="p">)))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">outer</span> <span class="o">=</span> <span class="n">gridspec</span><span class="o">.</span><span class="n">GridSpec</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="n">nrows</span><span class="p">,</span> <span class="n">figure</span><span class="o">=</span><span class="n">fig</span><span class="p">)</span>

        <span class="n">inner_ncols</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">what_to_plot</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="c1"># max 2 cols</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">what_to_plot</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">inner_nrows</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inner_nrows</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">good_clusters</span><span class="p">):</span>
            <span class="n">inner</span> <span class="o">=</span> <span class="n">gridspec</span><span class="o">.</span><span class="n">GridSpecFromSubplotSpec</span><span class="p">(</span><span class="n">inner_nrows</span><span class="p">,</span><span class="n">inner_ncols</span><span class="p">,</span> <span class="n">subplot_spec</span><span class="o">=</span><span class="n">outer</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">plot_type_idx</span><span class="p">,</span> <span class="n">plot_type</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">what_to_plot</span><span class="p">):</span>
                <span class="k">if</span> <span class="s1">&#39;hdir&#39;</span> <span class="ow">in</span> <span class="n">plot_type</span><span class="p">:</span>
                    <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">inner</span><span class="p">[</span><span class="n">plot_type_idx</span><span class="p">],</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;polar&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">inner</span><span class="p">[</span><span class="n">plot_type_idx</span><span class="p">])</span>

                <span class="k">if</span> <span class="s1">&#39;path&#39;</span> <span class="ow">in</span> <span class="n">plot_type</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">makeSpikePathPlot</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span>
                <span class="k">if</span> <span class="s1">&#39;map&#39;</span> <span class="ow">in</span> <span class="n">plot_type</span><span class="p">:</span>
                    <span class="n">rmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">makeRateMap</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span>
                <span class="k">if</span> <span class="s1">&#39;hdir&#39;</span> <span class="ow">in</span> <span class="n">plot_type</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">makeHDPlot</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">add_mrv</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="s1">&#39;sac&#39;</span> <span class="ow">in</span> <span class="n">plot_type</span><span class="p">:</span>
                    <span class="n">rmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">makeRateMap</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
                    <span class="n">nodwell</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">rmap</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">sac</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">autoCorr2D</span><span class="p">(</span><span class="n">rmap</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nodwell</span><span class="p">)</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">getMeasures</span><span class="p">(</span><span class="n">sac</span><span class="p">)</span>
                    <span class="n">S</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">sac</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">ax</span><span class="p">)</span>
                <span class="k">if</span> <span class="s1">&#39;speed&#39;</span> <span class="ow">in</span> <span class="n">plot_type</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">makeSpeedVsRatePlot</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">40.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span>
                <span class="k">if</span> <span class="s1">&#39;sp_hd&#39;</span> <span class="ow">in</span> <span class="n">plot_type</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">makeSpeedVsHeadDirectionPlot</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span>
                <span class="c1"># if first_sub_axis in plot_type: # label the first sub-axis only</span>
                    <span class="c1"># ax = fig.add_subplot(inner[plot_type_idx])</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">fontweight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;all&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_type</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">ephysiopy.ephys_generic</span> <span class="kn">import</span> <span class="n">gridcell</span>
            <span class="n">S</span> <span class="o">=</span> <span class="n">gridcell</span><span class="o">.</span><span class="n">SAC</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">good_clusters</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cluster </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cluster</span><span class="p">))</span>
            <span class="k">if</span> <span class="s1">&#39;map&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_type</span><span class="p">:</span>
                <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">makeRateMap</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            <span class="k">elif</span> <span class="s1">&#39;path&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_type</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">makeSpikePathPlot</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            <span class="k">elif</span> <span class="s1">&#39;hdir&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_type</span><span class="p">:</span>
                <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;polar&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">makeHDPlot</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            <span class="k">elif</span> <span class="s1">&#39;both&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_type</span><span class="p">:</span>
                <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax0</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
                <span class="c1"># ratemap</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">makeRateMap</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">ax0</span><span class="p">)</span>
                <span class="c1"># path / spikes</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">makeSpikePathPlot</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">ax1</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            <span class="k">elif</span> <span class="s1">&#39;speed&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_type</span><span class="p">:</span>
                <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">makeSpeedVsRatePlot</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">40.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span>
            <span class="k">elif</span> <span class="s1">&#39;sp_hd&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_type</span><span class="p">:</span>
                <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">makeSpeedVsHeadDirectionPlot</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span>
            <span class="k">elif</span> <span class="s1">&#39;all&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_type</span><span class="p">:</span>
                <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mf">9.6</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">])</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s2">&quot;Cluster </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cluster</span><span class="p">))</span>
                <span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">makeSpikePathPlot</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">ax1</span><span class="p">)</span>
                <span class="n">ax0</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">rmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">makeRateMap</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">ax0</span><span class="p">)</span>
                <span class="n">ax2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
                <span class="n">nodwell</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">rmap</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">sac</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">autoCorr2D</span><span class="p">(</span><span class="n">rmap</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nodwell</span><span class="p">)</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">getMeasures</span><span class="p">(</span><span class="n">sac</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_grid_output_location</span><span class="p">:</span>
                    <span class="n">d</span><span class="p">[</span><span class="s1">&#39;Cluster&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cluster</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">save_grid_output_location</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="n">S</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">sac</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">ax2</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Gridscore: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;gridness&#39;</span><span class="p">]))</span>
                <span class="n">ax3</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;polar&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">makeHDPlot</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">ax3</span><span class="p">,</span> <span class="n">add_mrv</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">ax4</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">makeSpeedVsRatePlot</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">40.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">ax4</span><span class="p">)</span>
                <span class="n">ax5</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">makeSpeedVsHeadDirectionPlot</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">ax5</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            <span class="k">yield</span> <span class="n">cluster</span>

<div class="viewcode-block" id="MapCalcsGeneric.makeRateMap"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.makeRateMap">[docs]</a>    <span class="k">def</span> <span class="nf">makeRateMap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">pos_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_ts</span><span class="p">)</span>
        <span class="n">mapMaker</span> <span class="o">=</span> <span class="n">binning</span><span class="o">.</span><span class="n">RateMap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">pos_w</span><span class="p">,</span> <span class="n">ppm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ppm</span><span class="p">)</span>
        <span class="n">spk_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spk_pos_idx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spk_clusters</span><span class="o">==</span><span class="n">cluster</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># print(&quot;nSpikes: {}&quot;.format(np.sum(spk_w).astype(int)))</span>
        <span class="n">rmap</span> <span class="o">=</span> <span class="n">mapMaker</span><span class="o">.</span><span class="n">getMap</span><span class="p">(</span><span class="n">spk_w</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">rmap</span>
        <span class="n">ratemap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">rmap</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">rmap</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">rmap</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">rmap</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">ratemap</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ratemap</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">jet</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;face&#39;</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">max</span><span class="p">()])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">(),</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yticklabels</span><span class="p">(),</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">get_xaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rmap</span></div>

<div class="viewcode-block" id="MapCalcsGeneric.makeSpikePathPlot"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.makeSpikePathPlot">[docs]</a>    <span class="k">def</span> <span class="nf">makeSpikePathPlot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">ax</span><span class="p">):</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">tcols</span><span class="o">.</span><span class="n">colours</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spk_pos_idx</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">spk_clusters</span><span class="o">==</span><span class="n">cluster</span><span class="p">]</span>
        <span class="n">spk_colour</span> <span class="o">=</span> <span class="n">tcols</span><span class="o">.</span><span class="n">colours</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">idx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">idx</span><span class="p">],</span><span class="s1">&#39;s&#39;</span><span class="p">,</span><span class="n">ms</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">spk_colour</span><span class="p">,</span><span class="n">mec</span><span class="o">=</span><span class="n">spk_colour</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">(),</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yticklabels</span><span class="p">(),</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">get_xaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="MapCalcsGeneric.makeHDPlot"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.makeHDPlot">[docs]</a>    <span class="k">def</span> <span class="nf">makeHDPlot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">pos_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_ts</span><span class="p">)</span>
        <span class="n">mapMaker</span> <span class="o">=</span> <span class="n">binning</span><span class="o">.</span><span class="n">RateMap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdir</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">pos_w</span><span class="p">,</span> <span class="n">ppm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ppm</span><span class="p">)</span>
        <span class="n">spk_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spk_pos_idx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spk_clusters</span><span class="o">==</span><span class="n">cluster</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">rmap</span> <span class="o">=</span> <span class="n">mapMaker</span><span class="o">.</span><span class="n">getMap</span><span class="p">(</span><span class="n">spk_w</span><span class="p">,</span> <span class="s1">&#39;dir&#39;</span><span class="p">,</span> <span class="s1">&#39;rate&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rmap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># polar plot</span>
            <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;polar&#39;</span><span class="p">)</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">rmap</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">rmap</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">labelbottom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">labelleft</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">labeltop</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">labelright</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_rticks</span><span class="p">([])</span>

            <span class="c1"># See if we should add the mean resultant vector (mrv)</span>
            <span class="k">if</span> <span class="s1">&#39;add_mrv&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="kn">from</span> <span class="nn">ephysiopy.dacq2py</span> <span class="kn">import</span> <span class="n">statscalcs</span>
                <span class="n">S</span> <span class="o">=</span> <span class="n">statscalcs</span><span class="o">.</span><span class="n">StatsCalcs</span><span class="p">()</span>
                <span class="n">angles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdir</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">spk_pos_idx</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">spk_clusters</span><span class="o">==</span><span class="n">cluster</span><span class="p">]]</span>
                <span class="n">r</span><span class="p">,</span> <span class="n">th</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">mean_resultant_vector</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">angles</span><span class="p">))</span>
                <span class="c1"># print(&quot;Mean resultant vector:&quot;)</span>
                <span class="c1"># print(&#39;\tUnit vector length: {:.3f}\n\tVector angle: {:.2f}&#39;.format(r,np.rad2deg(th)))</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">th</span><span class="p">,</span> <span class="n">th</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">rmap</span><span class="p">[</span><span class="mi">0</span><span class="p">])],</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_thetagrids</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">270</span><span class="p">])</span></div>

<div class="viewcode-block" id="MapCalcsGeneric.makeSpeedVsRatePlot"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.makeSpeedVsRatePlot">[docs]</a>    <span class="k">def</span> <span class="nf">makeSpeedVsRatePlot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">minSpeed</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">maxSpeed</span><span class="o">=</span><span class="mf">40.0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Plots the instantaneous firing rate of a cell against running speed</span>
<span class="sd">        Also outputs a couple of measures as with Kropff et al., 2015; the</span>
<span class="sd">        Pearsons correlation and the depth of modulation (dom) - see below for</span>
<span class="sd">        details</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">speed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">speed</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">speed</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">maxSpeed</span><span class="p">:</span>
            <span class="n">maxSpeed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">speed</span><span class="p">)</span>
        <span class="n">spd_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">minSpeed</span><span class="p">,</span> <span class="n">maxSpeed</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="c1"># Construct the mask</span>
        <span class="n">speed_filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">speed</span><span class="p">)</span>
        <span class="n">speed_filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">speed_filt</span> <span class="o">&lt;</span> <span class="n">minSpeed</span><span class="p">,</span> <span class="n">speed_filt</span><span class="p">)</span>
        <span class="n">speed_filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">speed_filt</span> <span class="o">&gt;</span> <span class="n">maxSpeed</span><span class="p">,</span> <span class="n">speed_filt</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">ephysiopy.dacq2py</span> <span class="kn">import</span> <span class="n">spikecalcs</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">spikecalcs</span><span class="o">.</span><span class="n">SpikeCalcs</span><span class="p">()</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spk_pos_idx</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">spk_clusters</span><span class="o">==</span><span class="n">cluster</span><span class="p">]</span>
        <span class="n">spk_sm</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">smoothSpikePosCount</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sigma</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">spk_sm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">spk_sm</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmask</span><span class="p">(</span><span class="n">speed_filt</span><span class="p">))</span>
        <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>
        <span class="n">stats</span><span class="o">.</span><span class="n">mstats</span><span class="o">.</span><span class="n">pearsonr</span><span class="p">(</span><span class="n">spk_sm</span><span class="p">,</span> <span class="n">speed_filt</span><span class="p">)</span>
        <span class="n">spd_dig</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">speed_filt</span><span class="p">,</span> <span class="n">spd_bins</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">mn_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">spk_sm</span><span class="p">[</span><span class="n">spd_dig</span><span class="o">==</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">spd_bins</span><span class="p">))])</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">spk_sm</span><span class="p">[</span><span class="n">spd_dig</span><span class="o">==</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">spd_bins</span><span class="p">))])</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">spk_sm</span><span class="p">[</span><span class="n">spd_dig</span><span class="o">==</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">spd_bins</span><span class="p">))])</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span><span class="n">spd_bins</span><span class="p">,</span> <span class="n">mn_rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span><span class="p">,</span> <span class="n">yerr</span><span class="o">=</span><span class="n">var</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">spd_bins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">spd_bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">([</span><span class="n">spd_bins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">spd_bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{:.2g}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spd_bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])],</span> <span class="n">fontweight</span><span class="o">=</span><span class="s1">&#39;normal&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">mn_rate</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_sample_rate</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{:.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">mn_rate</span><span class="p">))],</span> <span class="n">fontweight</span><span class="o">=</span><span class="s1">&#39;normal&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="MapCalcsGeneric.makeSpeedVsHeadDirectionPlot"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.makeSpeedVsHeadDirectionPlot">[docs]</a>    <span class="k">def</span> <span class="nf">makeSpeedVsHeadDirectionPlot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">ax</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spk_pos_idx</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">spk_clusters</span><span class="o">==</span><span class="n">cluster</span><span class="p">]</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">speed</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">dir_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">360</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>
        <span class="n">spd_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">speed</span><span class="p">,</span> <span class="p">[</span><span class="n">dir_bins</span><span class="p">,</span><span class="n">spd_bins</span><span class="p">],</span><span class="n">weights</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">binning</span><span class="o">.</span><span class="n">RateMap</span><span class="p">()</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">blurImage</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">5</span><span class="p">,</span><span class="n">ftype</span><span class="o">=</span><span class="s1">&#39;gaussian&#39;</span><span class="p">)</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
        <span class="c1"># mask low rates...</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">im</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">,</span> <span class="n">im</span><span class="p">)</span>
        <span class="c1"># ... and where less than 0.5% of data is accounted for</span>
        <span class="c1"># all_sp_x_hd_binned = np.histogram2d(self.hdir, self.speed, [dir_bins,spd_bins])[0]</span>
        <span class="c1"># im = np.ma.masked_where(all_sp_x_hd_binned &lt; (len(self.speed) * 0.005), im)</span>
        <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">dir_bins</span><span class="p">,</span> <span class="n">spd_bins</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">im</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">([</span><span class="mi">90</span><span class="p">,</span><span class="mi">180</span><span class="p">,</span><span class="mi">270</span><span class="p">],</span> <span class="n">fontweight</span><span class="o">=</span><span class="s1">&#39;normal&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">],</span> <span class="n">fontweight</span><span class="o">=</span><span class="s1">&#39;normal&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="FieldCalcs"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.FieldCalcs">[docs]</a><span class="k">class</span> <span class="nc">FieldCalcs</span><span class="p">:</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	This class differs from MapCalcsGeneric in that this one is mostly concerned with</span>
<span class="sd">	treating rate maps as images as opposed to using the spiking information contained</span>
<span class="sd">	within them. It therefore mostly deals with spatial rate maps of place and grid cells.</span>
<span class="sd">	&quot;&quot;&quot;</span>

	<span class="k">def</span> <span class="nf">_blur_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ftype</span><span class="o">=</span><span class="s1">&#39;boxcar&#39;</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		blurs the image by convolving with a filter (&#39;gaussian&#39; or</span>
<span class="sd">		&#39;boxcar&#39;) of</span>
<span class="sd">		size n. The optional keyword argument ny allows for a different</span>
<span class="sd">		size in the y direction.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">ny</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">ny</span> <span class="o">=</span> <span class="n">n</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">ny</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ny</span><span class="p">)</span>
		<span class="c1">#  keep track of nans</span>
		<span class="n">nan_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
		<span class="n">im</span><span class="p">[</span><span class="n">nan_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">if</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;boxcar&#39;</span><span class="p">:</span>
		    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">im</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			    <span class="n">g</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">boxcar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
		    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">im</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
			    <span class="n">g</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">boxcar</span><span class="p">([</span><span class="n">n</span><span class="p">,</span> <span class="n">ny</span><span class="p">])</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
		<span class="k">elif</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span>
			<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="o">-</span><span class="n">n</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">ny</span><span class="p">:</span><span class="n">ny</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
			<span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">ny</span><span class="p">)))</span>
		<span class="n">g</span> <span class="o">=</span> <span class="n">g</span> <span class="o">/</span> <span class="n">g</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">im</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="p">:]</span>
		<span class="n">improc</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>
		<span class="n">improc</span><span class="p">[</span><span class="n">nan_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
		<span class="k">return</span> <span class="n">improc</span>

<div class="viewcode-block" id="FieldCalcs.limit_to_one"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.FieldCalcs.limit_to_one">[docs]</a>	<span class="k">def</span> <span class="nf">limit_to_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">prc</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Processes a multi-peaked ratemap (ie grid cell) and returns a matrix</span>
<span class="sd">		where the multi-peaked ratemap consist of a single peaked field that is</span>
<span class="sd">		a) not connected to the border and b) close to the middle of the ratemap</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">Ac</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
		<span class="n">Ac</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">A</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="c1"># smooth Ac more to remove local irregularities</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">ny</span> <span class="o">=</span> <span class="mi">5</span>
		<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="o">-</span><span class="n">n</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">ny</span><span class="p">:</span><span class="n">ny</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">ny</span><span class="p">)))</span>
		<span class="n">g</span> <span class="o">=</span> <span class="n">g</span> <span class="o">/</span> <span class="n">g</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
		<span class="n">Ac</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">Ac</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>
		<span class="n">peak_mask</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">peak_local_max</span><span class="p">(</span><span class="n">Ac</span><span class="p">,</span> <span class="n">min_distance</span><span class="o">=</span><span class="n">min_dist</span><span class="p">,</span>
											 <span class="n">exclude_border</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
											 <span class="n">indices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="n">peak_labels</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">peak_mask</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
		<span class="n">field_labels</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">watershed</span><span class="p">(</span><span class="n">image</span><span class="o">=-</span><span class="n">Ac</span><span class="p">,</span>
											  <span class="n">markers</span><span class="o">=</span><span class="n">peak_labels</span><span class="p">)</span>
		<span class="n">nFields</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">field_labels</span><span class="p">)</span>
		<span class="n">sub_field_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nFields</span><span class="p">,</span> <span class="n">Ac</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Ac</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
		<span class="n">labelled_sub_field_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">sub_field_mask</span><span class="p">)</span>
		<span class="n">sub_field_props</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">regionprops</span><span class="p">(</span><span class="n">field_labels</span><span class="p">,</span>
												<span class="n">intensity_image</span><span class="o">=</span><span class="n">Ac</span><span class="p">)</span>
		<span class="n">sub_field_centroids</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">sub_field_size</span> <span class="o">=</span> <span class="p">[]</span>

		<span class="k">for</span> <span class="n">sub_field</span> <span class="ow">in</span> <span class="n">sub_field_props</span><span class="p">:</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Ac</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
			<span class="n">tmp</span><span class="p">[</span><span class="n">sub_field</span><span class="o">.</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">sub_field</span><span class="o">.</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>
			<span class="n">tmp2</span> <span class="o">=</span> <span class="n">Ac</span> <span class="o">&gt;</span> <span class="n">sub_field</span><span class="o">.</span><span class="n">max_intensity</span> <span class="o">*</span> <span class="p">(</span><span class="n">prc</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>
			<span class="n">sub_field_mask</span><span class="p">[</span><span class="n">sub_field</span><span class="o">.</span><span class="n">label</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">tmp2</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span>
			<span class="n">labelled_sub_field_mask</span><span class="p">[</span><span class="n">sub_field</span><span class="o">.</span><span class="n">label</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
						   <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">tmp2</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)]</span> <span class="o">=</span> <span class="n">sub_field</span><span class="o">.</span><span class="n">label</span>
			<span class="n">sub_field_centroids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_field</span><span class="o">.</span><span class="n">centroid</span><span class="p">)</span>
			<span class="n">sub_field_size</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_field</span><span class="o">.</span><span class="n">area</span><span class="p">)</span>  <span class="c1"># in bins</span>
		<span class="n">sub_field_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sub_field_mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">middle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">normd_dists</span> <span class="o">=</span> <span class="n">sub_field_centroids</span> <span class="o">-</span> <span class="n">middle</span>
		<span class="n">field_dists_from_middle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">normd_dists</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">normd_dists</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
		<span class="n">central_field_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">field_dists_from_middle</span><span class="p">)</span>
		<span class="n">central_field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">labelled_sub_field_mask</span><span class="p">[</span><span class="n">central_field_idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>
		<span class="c1"># collapse the labelled mask down to an 2d array</span>
		<span class="n">labelled_sub_field_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">labelled_sub_field_mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="c1"># clear the border</span>
		<span class="n">cleared_mask</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">segmentation</span><span class="o">.</span><span class="n">clear_border</span><span class="p">(</span><span class="n">central_field</span><span class="p">)</span>
		<span class="c1"># check we&#39;ve still got stuff in the matrix or fail</span>
		<span class="k">if</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cleared_mask</span><span class="p">):</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No fields were detected away from edges so nothing returned&#39;</span><span class="p">)</span>
			<span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">central_field_props</span> <span class="o">=</span> <span class="n">sub_field_props</span><span class="p">[</span><span class="n">central_field_idx</span><span class="p">]</span>
		<span class="k">return</span> <span class="n">central_field_props</span><span class="p">,</span> <span class="n">central_field</span><span class="p">,</span> <span class="n">central_field_idx</span></div>

<div class="viewcode-block" id="FieldCalcs.global_threshold"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.FieldCalcs.global_threshold">[docs]</a>	<span class="k">def</span> <span class="nf">global_threshold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">prc</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Globally thresholds a ratemap and counts number of fields found</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">Ac</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
		<span class="n">Ac</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">A</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">ny</span> <span class="o">=</span> <span class="mi">5</span>
		<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="o">-</span><span class="n">n</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">ny</span><span class="p">:</span><span class="n">ny</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">ny</span><span class="p">)))</span>
		<span class="n">g</span> <span class="o">=</span> <span class="n">g</span> <span class="o">/</span> <span class="n">g</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
		<span class="n">Ac</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">Ac</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>
		<span class="n">maxRate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">Ac</span><span class="p">))</span>
		<span class="n">Ac</span><span class="p">[</span><span class="n">Ac</span> <span class="o">&lt;</span> <span class="n">maxRate</span><span class="o">*</span><span class="p">(</span><span class="n">prc</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="mi">100</span><span class="p">))]</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="n">peak_mask</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">peak_local_max</span><span class="p">(</span><span class="n">Ac</span><span class="p">,</span> <span class="n">min_distance</span><span class="o">=</span><span class="n">min_dist</span><span class="p">,</span>
											 <span class="n">exclude_border</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
											 <span class="n">indices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="n">peak_labels</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">peak_mask</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
		<span class="n">field_labels</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">watershed</span><span class="p">(</span><span class="n">image</span><span class="o">=-</span><span class="n">Ac</span><span class="p">,</span>
											  <span class="n">markers</span><span class="o">=</span><span class="n">peak_labels</span><span class="p">)</span>
		<span class="n">nFields</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">field_labels</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">nFields</span></div>

<div class="viewcode-block" id="FieldCalcs.local_threshold"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.FieldCalcs.local_threshold">[docs]</a>	<span class="k">def</span> <span class="nf">local_threshold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">prc</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Locally thresholds a ratemap to take only the surrounding prc amount</span>
<span class="sd">		around any local peak</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">Ac</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
		<span class="n">nanidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Ac</span><span class="p">)</span>
		<span class="n">Ac</span><span class="p">[</span><span class="n">nanidx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="c1"># smooth Ac more to remove local irregularities</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">ny</span> <span class="o">=</span> <span class="mi">5</span>
		<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="o">-</span><span class="n">n</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">ny</span><span class="p">:</span><span class="n">ny</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">ny</span><span class="p">)))</span>
		<span class="n">g</span> <span class="o">=</span> <span class="n">g</span> <span class="o">/</span> <span class="n">g</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
		<span class="n">Ac</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">Ac</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>
		<span class="n">peak_mask</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">peak_local_max</span><span class="p">(</span><span class="n">Ac</span><span class="p">,</span> <span class="n">min_distance</span><span class="o">=</span><span class="n">min_dist</span><span class="p">,</span>
											 <span class="n">exclude_border</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
											 <span class="n">indices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="n">peak_labels</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">peak_mask</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
		<span class="n">field_labels</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">watershed</span><span class="p">(</span><span class="n">image</span><span class="o">=-</span><span class="n">Ac</span><span class="p">,</span>
											  <span class="n">markers</span><span class="o">=</span><span class="n">peak_labels</span><span class="p">)</span>
		<span class="n">nFields</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">field_labels</span><span class="p">)</span>
		<span class="n">sub_field_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nFields</span><span class="p">,</span> <span class="n">Ac</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Ac</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
		<span class="n">sub_field_props</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">regionprops</span><span class="p">(</span><span class="n">field_labels</span><span class="p">,</span>
												<span class="n">intensity_image</span><span class="o">=</span><span class="n">Ac</span><span class="p">)</span>
		<span class="n">sub_field_centroids</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">sub_field_size</span> <span class="o">=</span> <span class="p">[]</span>

		<span class="k">for</span> <span class="n">sub_field</span> <span class="ow">in</span> <span class="n">sub_field_props</span><span class="p">:</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Ac</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
			<span class="n">tmp</span><span class="p">[</span><span class="n">sub_field</span><span class="o">.</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">sub_field</span><span class="o">.</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>
			<span class="n">tmp2</span> <span class="o">=</span> <span class="n">Ac</span> <span class="o">&gt;</span> <span class="n">sub_field</span><span class="o">.</span><span class="n">max_intensity</span> <span class="o">*</span> <span class="p">(</span><span class="n">prc</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>
			<span class="n">sub_field_mask</span><span class="p">[</span><span class="n">sub_field</span><span class="o">.</span><span class="n">label</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">tmp2</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span>
			<span class="n">sub_field_centroids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_field</span><span class="o">.</span><span class="n">centroid</span><span class="p">)</span>
			<span class="n">sub_field_size</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_field</span><span class="o">.</span><span class="n">area</span><span class="p">)</span>  <span class="c1"># in bins</span>
		<span class="n">sub_field_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sub_field_mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">A_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
		<span class="n">A_out</span><span class="p">[</span><span class="n">sub_field_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">sub_field_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)]</span>
		<span class="n">A_out</span><span class="p">[</span><span class="n">nanidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
		<span class="k">return</span> <span class="n">A_out</span></div>

<div class="viewcode-block" id="FieldCalcs.getBorderScore"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.FieldCalcs.getBorderScore">[docs]</a>	<span class="k">def</span> <span class="nf">getBorderScore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="s1">&#39;square&#39;</span><span class="p">,</span> <span class="n">fieldThresh</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">smthKernSig</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
					<span class="n">circumPrc</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">binSize</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">minArea</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Calculates a border score totally dis-similar to that calculated in Solstad et al</span>
<span class="sd">		(2008)</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		A : array_like</span>
<span class="sd">			Should be the ratemap</span>
<span class="sd">		B : array_like</span>
<span class="sd">			This should be a boolean mask where True (1)</span>
<span class="sd">			is equivalent to the presence of a border and False (0)</span>
<span class="sd">			is equivalent to &#39;open space&#39;. Naievely this will be the</span>
<span class="sd">			edges of the ratemap but could be used to take account of</span>
<span class="sd">			boundary insertions/ creations to check tuning to multiple</span>
<span class="sd">			environmental boundaries. Default None: when the mask is</span>
<span class="sd">			None then a mask is created that has 1&#39;s at the edges of the</span>
<span class="sd">			ratemap i.e. it is assumed that occupancy = environmental</span>
<span class="sd">			shape</span>
<span class="sd">		shape : str</span>
<span class="sd">			description of environment shape. Currently</span>
<span class="sd">			only &#39;square&#39; or &#39;circle&#39; accepted. Used to calculate the</span>
<span class="sd">			proportion of the environmental boundaries to examine for</span>
<span class="sd">			firing</span>
<span class="sd">		fieldThresh : float</span>
<span class="sd">			Between 0 and 1 this is the percentage</span>
<span class="sd">			amount of the maximum firing rate</span>
<span class="sd">			to remove from the ratemap (i.e. to remove noise)</span>
<span class="sd">		smthKernSig : float</span>
<span class="sd">			the sigma value used in smoothing the ratemap</span>
<span class="sd">			(again!) with a gaussian kernel</span>
<span class="sd">		circumPrc : float</span>
<span class="sd">			The percentage amount of the circumference</span>
<span class="sd">			of the environment that the field needs to be to count</span>
<span class="sd">			as long enough to make it through</span>
<span class="sd">		binSize : float</span>
<span class="sd">			bin size in cm</span>
<span class="sd">		minArea : float</span>
<span class="sd">			min area for a field to be considered</span>
<span class="sd">		debug : bool</span>
<span class="sd">			If True then some plots and text will be output</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		float : the border score</span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">		If the cell is a border cell (BVC) then we know that it should</span>
<span class="sd">		fire at a fixed distance from a given boundary (possibly more</span>
<span class="sd">		than one). In essence this algorithm estimates the amount of</span>
<span class="sd">		variance in this distance i.e. if the cell is a border cell this</span>
<span class="sd">		number should be small. This is achieved by first doing a bunch of</span>
<span class="sd">		morphological operations to isolate individual fields in the</span>
<span class="sd">		ratemap (similar to the code used in phasePrecession.py - see</span>
<span class="sd">		the partitionFields method therein). These partitioned fields are then</span>
<span class="sd">		thinned out (using skimage&#39;s skeletonize) to a single pixel</span>
<span class="sd">		wide field which will lie more or less in the middle of the</span>
<span class="sd">		(highly smoothed) sub-field. It is the variance in distance from the</span>
<span class="sd">		nearest boundary along this pseudo-iso-line that is the boundary measure</span>

<span class="sd">		Other things to note are that the pixel-wide field has to have some minimum</span>
<span class="sd">		length. In the case of a circular environment this is set to</span>
<span class="sd">		20% of the circumference; in the case of a square environment markers</span>
<span class="sd">		this is at least half the length of the longest side</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="c1"># need to know borders of the environment so we can see if a field</span>
		<span class="c1"># touches the edges, and the perimeter length of the environment</span>
		<span class="c1"># deal with square or circles differently</span>
		<span class="n">borderMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
		<span class="n">A_rows</span><span class="p">,</span> <span class="n">A_cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
		<span class="k">if</span> <span class="s1">&#39;circle&#39;</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">:</span>
			<span class="n">radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">A</span><span class="p">)))</span> <span class="o">/</span> <span class="mf">2.0</span>
			<span class="n">dist_mask</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">disk</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">dist_mask</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
			    <span class="n">dist_mask</span> <span class="o">=</span> <span class="n">dist_mask</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">A_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">A_cols</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">A_rows</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">A_cols</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span>
			<span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist_mask</span>
			<span class="n">dists</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">distance_transform_bf</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
			<span class="n">dists</span> <span class="o">=</span> <span class="n">dists</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="n">borderMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">dists</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dists</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
			<span class="c1"># open up the border mask a little</span>
			<span class="n">borderMask</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">(</span>
				<span class="n">borderMask</span><span class="p">,</span> <span class="n">skimage</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">disk</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
		<span class="k">elif</span> <span class="s1">&#39;square&#39;</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">:</span>
			<span class="n">borderMask</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
			<span class="n">borderMask</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
			<span class="n">borderMask</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
			<span class="n">borderMask</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">3</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">A_rows</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">A_cols</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span>
			<span class="n">dist_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
			<span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist_mask</span>
			<span class="n">dists</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">distance_transform_bf</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
			<span class="c1"># remove edges to make same shape as input ratemap</span>
			<span class="n">dists</span> <span class="o">=</span> <span class="n">dists</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">A</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">A</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="c1"># get some morphological info about the fields in the ratemap</span>
		<span class="c1"># start image processing:</span>
		<span class="c1"># get some markers</span>
		<span class="c1"># NB I&#39;ve tried a variety of techniques to optimise this part and the</span>
		<span class="c1"># best seems to be the local adaptive thresholding technique which)</span>
		<span class="c1"># smooths locally with a gaussian - see the skimage docs for more</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">A</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">A</span><span class="p">))</span> <span class="o">*</span> <span class="n">fieldThresh</span>
		<span class="n">A_thresh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
		<span class="n">A_thresh</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

		<span class="c1"># label these markers so each blob has a unique id</span>
		<span class="n">labels</span><span class="p">,</span> <span class="n">nFields</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">A_thresh</span><span class="p">)</span>
		<span class="c1"># remove small objects</span>
		<span class="n">min_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">minArea</span> <span class="o">/</span> <span class="n">binSize</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
		<span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
			<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
			<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">A_thresh</span><span class="p">)</span>
			<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Before removing small objects&#39;</span><span class="p">)</span>
		<span class="n">skimage</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">remove_small_objects</span><span class="p">(</span>
			<span class="n">labels</span><span class="p">,</span> <span class="n">min_size</span><span class="o">=</span><span class="n">min_size</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
		<span class="n">labels</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">segmentation</span><span class="o">.</span><span class="n">relabel_sequential</span><span class="p">(</span><span class="n">labels</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">nFields</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">nFields</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
		<span class="c1"># Iterate over the labelled parts of the array labels calculating</span>
		<span class="c1"># how much of the total circumference of the environment edge it</span>
		<span class="c1"># covers</span>

		<span class="n">fieldAngularCoverage</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">nFields</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
		<span class="n">fractionOfPixelsOnBorder</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">nFields</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
		<span class="n">fieldsToKeep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nFields</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
			<span class="n">fieldMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">labels</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="n">borderMask</span><span class="p">)</span>

			<span class="c1"># check the angle subtended by the fieldMask</span>
			<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fieldMask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
				<span class="n">s</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">regionprops</span><span class="p">(</span>
				<span class="n">fieldMask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">intensity_image</span><span class="o">=</span><span class="n">A_thresh</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
				<span class="n">x</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">A_cols</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
				<span class="n">y</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">A_rows</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
				<span class="n">subtended_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)))</span>
				<span class="k">if</span> <span class="n">subtended_angle</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">360</span> <span class="o">*</span> <span class="n">circumPrc</span><span class="p">):</span>
					<span class="n">pixelsOnBorder</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span>
					<span class="n">fieldMask</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">labels</span> <span class="o">==</span> <span class="n">i</span><span class="p">))</span>
					<span class="n">fractionOfPixelsOnBorder</span><span class="p">[:,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pixelsOnBorder</span>
					<span class="k">if</span> <span class="n">pixelsOnBorder</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">:</span>
						<span class="n">fieldAngularCoverage</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">subtended_angle</span>

				<span class="n">fieldsToKeep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">fieldsToKeep</span><span class="p">,</span> <span class="n">labels</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
			<span class="n">_</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span>
			<span class="n">ax1</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
			<span class="n">ax2</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
			<span class="n">ax3</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
			<span class="n">ax4</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
			<span class="n">ax1</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
			<span class="n">ax2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
			<span class="n">ax3</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">A_thresh</span><span class="p">)</span>
			<span class="n">ax4</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">fieldsToKeep</span><span class="p">)</span>
			<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
			<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fieldAngularCoverage</span><span class="o">.</span><span class="n">ravel</span><span class="p">()):</span>
				<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;angle subtended by field </span><span class="si">{0}</span><span class="s2"> = </span><span class="si">{1:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
			<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fractionOfPixelsOnBorder</span><span class="o">.</span><span class="n">ravel</span><span class="p">()):</span>
				<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;% pixels on border for field </span><span class="si">{0}</span><span class="s2"> = </span><span class="si">{1:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
		<span class="n">fieldAngularCoverage</span> <span class="o">=</span> <span class="p">(</span><span class="n">fieldAngularCoverage</span> <span class="o">/</span> <span class="mf">360.</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fieldsToKeep</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
		<span class="n">rateInField</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">fieldsToKeep</span><span class="p">]</span>
		<span class="c1"># normalize firing rate in the field to sum to 1</span>
		<span class="n">rateInField</span> <span class="o">=</span> <span class="n">rateInField</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">rateInField</span><span class="p">)</span>
		<span class="n">dist2WallInField</span> <span class="o">=</span> <span class="n">dists</span><span class="p">[</span><span class="n">fieldsToKeep</span><span class="p">]</span>
		<span class="n">Dm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dist2WallInField</span><span class="p">,</span> <span class="n">rateInField</span><span class="p">)</span>
		<span class="k">if</span> <span class="s1">&#39;circle&#39;</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">:</span>
			<span class="n">Dm</span> <span class="o">=</span> <span class="n">Dm</span> <span class="o">/</span> <span class="n">radius</span>
		<span class="k">elif</span> <span class="s1">&#39;square&#39;</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">:</span>
			<span class="n">Dm</span> <span class="o">=</span> <span class="n">Dm</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">A</span><span class="p">))</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
		<span class="n">borderScore</span> <span class="o">=</span> <span class="p">(</span><span class="n">fractionOfPixelsOnBorder</span><span class="o">-</span><span class="n">Dm</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">fractionOfPixelsOnBorder</span><span class="o">+</span><span class="n">Dm</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">borderScore</span><span class="p">)</span></div>

<div class="viewcode-block" id="FieldCalcs.get_field_props"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.FieldCalcs.get_field_props">[docs]</a>	<span class="k">def</span> <span class="nf">get_field_props</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">neighbours</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">prc</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
					 <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tri</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns a dictionary of properties of the field(s) in a ratemap A</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		A : array_like</span>
<span class="sd">			a ratemap (but could be any image)</span>
<span class="sd">		min_dist : float</span>
<span class="sd">			the separation (in bins) between fields for measures</span>
<span class="sd">			such as field distance to make sense. Used to</span>
<span class="sd">			partition the image into separate fields in the call to</span>
<span class="sd">			skimage.feature.peak_local_max</span>
<span class="sd">		neighbours : int</span>
<span class="sd">			the number of fields to consider as neighbours to</span>
<span class="sd">			any given field. Defaults to 2</span>
<span class="sd">		prc : float</span>
<span class="sd">			percent of fields to consider</span>
<span class="sd">		ax : matplotlib.Axes</span>
<span class="sd">			user supplied axis. If None a new figure window is created</span>
<span class="sd">		tri : bool</span>
<span class="sd">			whether to do Delaunay triangulation between fields</span>
<span class="sd">			and add to plot</span>
<span class="sd">		verbose : bool</span>
<span class="sd">			dumps the properties to the console</span>
<span class="sd">		plot : bool</span>
<span class="sd">			whether to plot some output - currently consists of the</span>
<span class="sd">			ratemap A, the fields of which are outline in a black</span>
<span class="sd">			contour. Default False</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		result : dict</span>
<span class="sd">			The properties of the field(s) in the input ratemap A</span>
<span class="sd">		&quot;&quot;&quot;</span>

		<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">Delaunay</span>
		<span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="kn">import</span> <span class="n">find_contours</span>
		<span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">NearestNeighbors</span>
		<span class="kn">import</span> <span class="nn">gridcell</span>
		<span class="kn">import</span> <span class="nn">matplotlib.cm</span> <span class="k">as</span> <span class="nn">cm</span>

		<span class="n">nan_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
		<span class="n">Ac</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
		<span class="n">Ac</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">A</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="c1"># smooth Ac more to remove local irregularities</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">ny</span> <span class="o">=</span> <span class="mi">5</span>
		<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="o">-</span><span class="n">n</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">ny</span><span class="p">:</span><span class="n">ny</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">ny</span><span class="p">)))</span>
		<span class="n">g</span> <span class="o">=</span> <span class="n">g</span> <span class="o">/</span> <span class="n">g</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
		<span class="n">Ac</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">Ac</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="s1">&#39;clear_border&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">clear_border</span> <span class="o">=</span> <span class="kc">True</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">clear_border</span> <span class="o">=</span> <span class="kc">False</span>
		<span class="n">peak_idx</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">peak_local_max</span><span class="p">(</span><span class="n">Ac</span><span class="p">,</span> <span class="n">min_distance</span><span class="o">=</span><span class="n">min_dist</span><span class="p">,</span>
											<span class="n">exclude_border</span><span class="o">=</span><span class="n">clear_border</span><span class="p">,</span>
											<span class="n">indices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">neighbours</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">peak_idx</span><span class="p">):</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;neighbours value of </span><span class="si">{0}</span><span class="s1"> &gt; the </span><span class="si">{1}</span><span class="s1"> peaks found&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">neighbours</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">peak_idx</span><span class="p">)))</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Reducing neighbours to number of peaks found&#39;</span><span class="p">)</span>
			<span class="n">neighbours</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">peak_idx</span><span class="p">)</span>
		<span class="n">peak_mask</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">peak_local_max</span><span class="p">(</span><span class="n">Ac</span><span class="p">,</span> <span class="n">min_distance</span><span class="o">=</span><span class="n">min_dist</span><span class="p">,</span> <span class="n">exclude_border</span><span class="o">=</span><span class="n">clear_border</span><span class="p">,</span>
											 <span class="n">indices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="n">peak_labels</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">peak_mask</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
		<span class="n">field_labels</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">watershed</span><span class="p">(</span><span class="n">image</span><span class="o">=-</span><span class="n">Ac</span><span class="p">,</span>
											  <span class="n">markers</span><span class="o">=</span><span class="n">peak_labels</span><span class="p">)</span>
		<span class="n">nFields</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">field_labels</span><span class="p">)</span>
		<span class="n">sub_field_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nFields</span><span class="p">,</span> <span class="n">Ac</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Ac</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
		<span class="n">sub_field_props</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">regionprops</span><span class="p">(</span><span class="n">field_labels</span><span class="p">,</span>
												<span class="n">intensity_image</span><span class="o">=</span><span class="n">Ac</span><span class="p">)</span>
		<span class="n">sub_field_centroids</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">sub_field_size</span> <span class="o">=</span> <span class="p">[]</span>

		<span class="k">for</span> <span class="n">sub_field</span> <span class="ow">in</span> <span class="n">sub_field_props</span><span class="p">:</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Ac</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
			<span class="n">tmp</span><span class="p">[</span><span class="n">sub_field</span><span class="o">.</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">sub_field</span><span class="o">.</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>
			<span class="n">tmp2</span> <span class="o">=</span> <span class="n">Ac</span> <span class="o">&gt;</span> <span class="n">sub_field</span><span class="o">.</span><span class="n">max_intensity</span> <span class="o">*</span> <span class="p">(</span><span class="n">prc</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>
			<span class="n">sub_field_mask</span><span class="p">[</span><span class="n">sub_field</span><span class="o">.</span><span class="n">label</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">tmp2</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span>
			<span class="n">sub_field_centroids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_field</span><span class="o">.</span><span class="n">centroid</span><span class="p">)</span>
			<span class="n">sub_field_size</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_field</span><span class="o">.</span><span class="n">area</span><span class="p">)</span>  <span class="c1"># in bins</span>
		<span class="n">sub_field_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sub_field_mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">contours</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">find_contours</span><span class="p">(</span><span class="n">sub_field_mask</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
		<span class="c1"># find the nearest neighbors to the peaks of each sub-field</span>
		<span class="n">nbrs</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">neighbours</span><span class="p">,</span>
								<span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;ball_tree&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">peak_idx</span><span class="p">)</span>
		<span class="n">distances</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">nbrs</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">peak_idx</span><span class="p">)</span>
		<span class="n">mean_field_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">distances</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="n">neighbours</span><span class="p">])</span>

		<span class="n">nValid_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">nan_idx</span><span class="p">)</span>
		<span class="c1"># calculate the amount of out of field firing</span>
		<span class="n">A_non_field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
		<span class="n">A_non_field</span><span class="p">[</span><span class="o">~</span><span class="n">sub_field_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="o">~</span><span class="n">sub_field_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)]</span>
		<span class="n">A_non_field</span><span class="p">[</span><span class="n">nan_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
		<span class="n">out_of_field_firing_prc</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">A_non_field</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">nValid_bins</span><span class="p">))</span> <span class="o">*</span> <span class="mi">100</span>
		<span class="n">Ac</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">A</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		get some stats about the field ellipticity</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">_</span><span class="p">,</span> <span class="n">central_field</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">limit_to_one</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">prc</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">central_field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">ellipse_ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">contour_coords</span> <span class="o">=</span> <span class="n">find_contours</span><span class="p">(</span><span class="n">central_field</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
			<span class="n">G</span> <span class="o">=</span> <span class="n">gridcell</span><span class="o">.</span><span class="n">SAC</span><span class="p">()</span>
			<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">__fit_ellipse__</span><span class="p">(</span><span class="n">contour_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">contour_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">])</span>
			<span class="n">ellipse_axes</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">__ellipse_axis_length__</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
			<span class="n">ellipse_ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ellipse_axes</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ellipse_axes</span><span class="p">)</span>
		<span class="sd">&#39;&#39;&#39; using the peak_idx values calculate the angles of the triangles that</span>
<span class="sd">		make up a delaunay tesselation of the space if the calc_angles arg is</span>
<span class="sd">		in kwargs</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="s1">&#39;calc_angs&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="n">angs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_angs</span><span class="p">(</span><span class="n">peak_idx</span><span class="p">)</span>
			<span class="k">except</span><span class="p">:</span>
				<span class="n">angs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">angs</span> <span class="o">=</span> <span class="kc">None</span>

		<span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
				<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span>
			<span class="n">Am</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">Ac</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">nan_idx</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">Am</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">jet</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;face&#39;</span><span class="p">)</span>
			<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">contours</span><span class="p">:</span>
				<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">c</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;k&#39;</span><span class="p">)</span>
			<span class="c1"># do the delaunay thing</span>
			<span class="k">if</span> <span class="n">tri</span><span class="p">:</span>
				<span class="n">tri</span> <span class="o">=</span> <span class="n">Delaunay</span><span class="p">(</span><span class="n">peak_idx</span><span class="p">)</span>
				<span class="n">ax</span><span class="o">.</span><span class="n">triplot</span><span class="p">(</span><span class="n">peak_idx</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">peak_idx</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
						   <span class="n">tri</span><span class="o">.</span><span class="n">simplices</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Ac</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Ac</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>
		<span class="n">props</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Ac&#39;</span><span class="p">:</span> <span class="n">Ac</span><span class="p">,</span>
					<span class="s1">&#39;Peak_rate&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">A</span><span class="p">),</span>
					<span class="s1">&#39;Mean_rate&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">A</span><span class="p">),</span>
					<span class="s1">&#39;Field_size&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sub_field_size</span><span class="p">),</span>
					<span class="s1">&#39;Pct_bins_with_firing&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sub_field_mask</span><span class="p">)</span> <span class="o">/</span> <span class="n">nValid_bins</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span>
					<span class="s1">&#39;Out_of_field_firing_prc&#39;</span><span class="p">:</span> <span class="n">out_of_field_firing_prc</span><span class="p">,</span>
					<span class="s1">&#39;Dist_between_fields&#39;</span><span class="p">:</span> <span class="n">mean_field_distance</span><span class="p">,</span>
					<span class="s1">&#39;Num_fields&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">nFields</span><span class="p">),</span>
					<span class="s1">&#39;Sub_field_mask&#39;</span><span class="p">:</span> <span class="n">sub_field_mask</span><span class="p">,</span>
					<span class="s1">&#39;Smoothed_map&#39;</span><span class="p">:</span> <span class="n">Ac</span><span class="p">,</span>
					<span class="s1">&#39;field_labels&#39;</span><span class="p">:</span> <span class="n">field_labels</span><span class="p">,</span>
					<span class="s1">&#39;Peak_idx&#39;</span><span class="p">:</span> <span class="n">peak_idx</span><span class="p">,</span>
					<span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="n">angs</span><span class="p">,</span>
					<span class="s1">&#39;contours&#39;</span><span class="p">:</span> <span class="n">contours</span><span class="p">,</span>
					<span class="s1">&#39;ellipse_ratio&#39;</span><span class="p">:</span> <span class="n">ellipse_ratio</span><span class="p">}</span>

		<span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Percentage of bins with firing: </span><span class="si">{:.2%}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
			<span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sub_field_mask</span><span class="p">)</span> <span class="o">/</span> <span class="n">nValid_bins</span><span class="p">))</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Percentage out of field firing: </span><span class="si">{:.2%}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
				<span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">A_non_field</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">nValid_bins</span><span class="p">)))</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Peak firing rate: </span><span class="si">{:.3}</span><span class="s1"> Hz&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">A</span><span class="p">)))</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Mean firing rate: </span><span class="si">{:.3}</span><span class="s1"> Hz&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">A</span><span class="p">)))</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of fields: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nFields</span><span class="p">))</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Mean field size: </span><span class="si">{:.5}</span><span class="s1"> cm&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sub_field_size</span><span class="p">)))</span>  <span class="c1"># 3 is binsize)</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Mean inter-peak distance between fields: </span><span class="si">{:.4}</span><span class="s1"> cm&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mean_field_distance</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">props</span></div>

<div class="viewcode-block" id="FieldCalcs.calc_angs"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.FieldCalcs.calc_angs">[docs]</a>	<span class="k">def</span> <span class="nf">calc_angs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Calculates the angles for all triangles in a delaunay tesselation of</span>
<span class="sd">		the peak points in the ratemap</span>
<span class="sd">		&quot;&quot;&quot;</span>

		<span class="c1"># calculate the lengths of the sides of the triangles</span>
		<span class="n">sideLen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
		<span class="n">tri</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">Delaunay</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
		<span class="n">indices</span><span class="p">,</span> <span class="n">indptr</span> <span class="o">=</span> <span class="n">tri</span><span class="o">.</span><span class="n">vertex_neighbor_vertices</span>
		<span class="n">nTris</span> <span class="o">=</span> <span class="n">tri</span><span class="o">.</span><span class="n">nsimplex</span>
		<span class="n">outAngs</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nTris</span><span class="p">):</span>
			<span class="n">idx</span> <span class="o">=</span> <span class="n">indptr</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span><span class="n">indices</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
			<span class="n">a</span> <span class="o">=</span> <span class="n">sideLen</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
			<span class="n">b</span> <span class="o">=</span> <span class="n">sideLen</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
			<span class="n">c</span> <span class="o">=</span> <span class="n">sideLen</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
			<span class="n">angA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getAng</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
			<span class="n">angB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getAng</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
			<span class="n">angC</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getAng</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
			<span class="n">outAngs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">angA</span><span class="p">,</span> <span class="n">angB</span><span class="p">,</span> <span class="n">angC</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">outAngs</span><span class="p">)</span><span class="o">.</span><span class="n">T</span></div>

	<span class="k">def</span> <span class="nf">_getAng</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Given lengths a,b,c of the sides of a triangle this returns the angles</span>
<span class="sd">		in degress of all 3 angles</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">((</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">a</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="o">-</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">)))</span>

<div class="viewcode-block" id="FieldCalcs.corr_maps"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.FieldCalcs.corr_maps">[docs]</a>	<span class="k">def</span> <span class="nf">corr_maps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">map1</span><span class="p">,</span> <span class="n">map2</span><span class="p">,</span> <span class="n">maptype</span><span class="o">=</span><span class="s1">&#39;normal&#39;</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		correlates two ratemaps together ignoring areas that have zero sampling</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="n">map1</span><span class="o">.</span><span class="n">shape</span> <span class="o">&gt;</span> <span class="n">map2</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
			<span class="n">map2</span> <span class="o">=</span> <span class="n">misc</span><span class="o">.</span><span class="n">imresize</span><span class="p">(</span><span class="n">map2</span><span class="p">,</span> <span class="n">map1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
		<span class="k">elif</span> <span class="n">map1</span><span class="o">.</span><span class="n">shape</span> <span class="o">&lt;</span> <span class="n">map2</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
			<span class="n">map1</span> <span class="o">=</span> <span class="n">misc</span><span class="o">.</span><span class="n">imresize</span><span class="p">(</span><span class="n">map1</span><span class="p">,</span> <span class="n">map2</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
		<span class="n">map1</span> <span class="o">=</span> <span class="n">map1</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
		<span class="n">map2</span> <span class="o">=</span> <span class="n">map2</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">maptype</span> <span class="ow">is</span> <span class="s1">&#39;normal&#39;</span><span class="p">:</span>
			<span class="n">valid_map1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">((</span><span class="n">map1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">map1</span><span class="p">))</span>
			<span class="n">valid_map2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">((</span><span class="n">map2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">map2</span><span class="p">))</span>
		<span class="k">elif</span> <span class="n">maptype</span> <span class="ow">is</span> <span class="s1">&#39;grid&#39;</span><span class="p">:</span>
			<span class="n">valid_map1</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">map1</span><span class="p">)</span>
			<span class="n">valid_map2</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">map2</span><span class="p">)</span>
		<span class="n">valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">valid_map1</span><span class="p">,</span> <span class="n">valid_map2</span><span class="p">)</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">map1</span><span class="p">[</span><span class="n">valid</span><span class="p">],</span> <span class="n">map2</span><span class="p">[</span><span class="n">valid</span><span class="p">])</span>
		<span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
			<span class="k">return</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>

<div class="viewcode-block" id="FieldCalcs.coherence"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.FieldCalcs.coherence">[docs]</a>	<span class="k">def</span> <span class="nf">coherence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">smthd_rate</span><span class="p">,</span> <span class="n">unsmthd_rate</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;calculates coherence of receptive field via correlation of smoothed</span>
<span class="sd">		and unsmoothed ratemaps</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">smthd</span> <span class="o">=</span> <span class="n">smthd_rate</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
		<span class="n">unsmthd</span> <span class="o">=</span> <span class="n">unsmthd_rate</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
		<span class="n">si</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">smthd</span><span class="p">)</span>
		<span class="n">ui</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">unsmthd</span><span class="p">)</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="o">~</span><span class="n">si</span> <span class="o">|</span> <span class="o">~</span><span class="n">ui</span><span class="p">)</span>
		<span class="n">coherence</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">unsmthd</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">smthd</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">coherence</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="FieldCalcs.kldiv_dir"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.FieldCalcs.kldiv_dir">[docs]</a>	<span class="k">def</span> <span class="nf">kldiv_dir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polarPlot</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns a kl divergence for directional firing: measure of directionality.</span>
<span class="sd">		Calculates kl diveregence between a smoothed ratemap (probably should be smoothed</span>
<span class="sd">		otherwise information theoretic measures don&#39;t &#39;care&#39; about position of bins relative to</span>
<span class="sd">		one another) and a pure circular distribution. The larger the divergence the more</span>
<span class="sd">		tendancy the cell has to fire when the animal faces a specific direction.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		polarPlot: 1D-array</span>
<span class="sd">			The binned and smoothed directional ratemap</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		klDivergence: float</span>
<span class="sd">			The divergence from circular of the 1D-array from a uniform circular</span>
<span class="sd">			distribution</span>
<span class="sd">		&quot;&quot;&quot;</span>

		<span class="n">__inc</span> <span class="o">=</span> <span class="mf">0.00001</span>
		<span class="n">polarPlot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">polarPlot</span><span class="p">)</span>
		<span class="n">polarPlot</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">polarPlot</span><span class="p">)]</span> <span class="o">=</span> <span class="n">__inc</span>
		<span class="n">polarPlot</span><span class="p">[</span><span class="n">polarPlot</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">__inc</span>
		<span class="n">normdPolar</span> <span class="o">=</span> <span class="n">polarPlot</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">polarPlot</span><span class="p">))</span>
		<span class="n">nDirBins</span> <span class="o">=</span> <span class="n">polarPlot</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">compCirc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">polarPlot</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">nDirBins</span><span class="p">)</span>
		<span class="n">kldivergence</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kldiv</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nDirBins</span><span class="p">),</span> <span class="n">normdPolar</span><span class="p">,</span> <span class="n">compCirc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">kldivergence</span></div>

<div class="viewcode-block" id="FieldCalcs.kldiv"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.FieldCalcs.kldiv">[docs]</a>	<span class="k">def</span> <span class="nf">kldiv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">pvect1</span><span class="p">,</span> <span class="n">pvect2</span><span class="p">,</span> <span class="n">variant</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Calculates the Kullback-Leibler or Jensen-Shannon divergence between two distributions.</span>

<span class="sd">		kldiv(X,P1,P2) returns the Kullback-Leibler divergence between two</span>
<span class="sd">		distributions specified over the M variable values in vector X.  P1 is a</span>
<span class="sd">		length-M vector of probabilities representing distribution 1, and P2 is a</span>
<span class="sd">		length-M vector of probabilities representing distribution 2.  Thus, the</span>
<span class="sd">		probability of value X(i) is P1(i) for distribution 1 and P2(i) for</span>
<span class="sd">		distribution 2.  The Kullback-Leibler divergence is given by:</span>

<span class="sd">		.. math:: KL(P1(x),P2(x)) = sum_[P1(x).log(P1(x)/P2(x))]</span>

<span class="sd">		If X contains duplicate values, there will be an warning message, and these</span>
<span class="sd">		values will be treated as distinct values.  (I.e., the actual values do</span>
<span class="sd">		not enter into the computation, but the probabilities for the two</span>
<span class="sd">		duplicate values will be considered as probabilities corresponding to</span>
<span class="sd">		two unique values.)  The elements of probability vectors P1 and P2 must</span>
<span class="sd">		each sum to 1 +/- .00001.</span>

<span class="sd">		kldiv(X,P1,P2,&#39;sym&#39;) returns a symmetric variant of the Kullback-Leibler</span>
<span class="sd">		divergence, given by [KL(P1,P2)+KL(P2,P1)]/2 [1]_</span>

<span class="sd">		kldiv(X,P1,P2,&#39;js&#39;) returns the Jensen-Shannon divergence, given by</span>
<span class="sd">		[KL(P1,Q)+KL(P2,Q)]/2, where Q = (P1+P2)/2.  See the Wikipedia article</span>
<span class="sd">		for &quot;Kullback–Leibler divergence&quot;.  This is equal to 1/2 the so-called</span>
<span class="sd">		&quot;Jeffrey divergence.&quot; [2]_</span>

<span class="sd">		References</span>
<span class="sd">		----------</span>
<span class="sd">		.. [1] Johnson, D.H. and S. Sinanovic. &quot;Symmetrizing the Kullback-Leibler</span>
<span class="sd">		distance.&quot; IEEE Transactions on Information Theory (Submitted).</span>
<span class="sd">		.. [2] Rubner, Y., Tomasi, C., and Guibas, L. J., 2000. &quot;The Earth Mover&#39;s</span>
<span class="sd">		distance as a metric for image retrieval.&quot; International Journal of</span>
<span class="sd">		Computer Vision, 40(2): 99-121.</span>

<span class="sd">		See Also</span>
<span class="sd">		--------</span>
<span class="sd">		Cover, T.M. and J.A. Thomas. &quot;Elements of Information Theory,&quot; Wiley, 1991.</span>

<span class="sd">		https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence</span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">		This function is taken from one on the Mathworks file exchange</span>
<span class="sd">		&#39;&#39;&#39;</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">X</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
			<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;X contains duplicate values. Treated as distinct values.&#39;</span><span class="p">,</span>
				<span class="ne">UserWarning</span><span class="p">)</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">pvect1</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">pvect2</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
			<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;All inputs must have the same dimension.&#39;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pvect1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.00001</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pvect2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.00001</span><span class="p">):</span>
			<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Probabilities don&#39;&#39;t sum to 1.&#39;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">variant</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">variant</span> <span class="o">==</span> <span class="s1">&#39;js&#39;</span><span class="p">:</span>
				<span class="n">logqvect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">((</span><span class="n">pvect2</span> <span class="o">+</span> <span class="n">pvect1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
				<span class="n">KL</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">pvect1</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">pvect1</span><span class="p">)</span> <span class="o">-</span> <span class="n">logqvect</span><span class="p">))</span> <span class="o">+</span>
							<span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pvect2</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">pvect2</span><span class="p">)</span> <span class="o">-</span> <span class="n">logqvect</span><span class="p">)))</span>
				<span class="k">return</span> <span class="n">KL</span>
			<span class="k">elif</span> <span class="n">variant</span> <span class="o">==</span> <span class="s1">&#39;sym&#39;</span><span class="p">:</span>
				<span class="n">KL1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">pvect1</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">pvect1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">pvect2</span><span class="p">)))</span>
				<span class="n">KL2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">pvect2</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">pvect2</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">pvect1</span><span class="p">)))</span>
				<span class="n">KL</span> <span class="o">=</span> <span class="p">(</span><span class="n">KL1</span> <span class="o">+</span> <span class="n">KL2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
				<span class="k">return</span> <span class="n">KL</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Last argument not recognised&#39;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
		<span class="n">KL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">pvect1</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">pvect1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">pvect2</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">KL</span></div>

<div class="viewcode-block" id="FieldCalcs.skaggsInfo"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.ephys_generic.FieldCalcs.skaggsInfo">[docs]</a>	<span class="k">def</span> <span class="nf">skaggsInfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ratemap</span><span class="p">,</span> <span class="n">dwelltimes</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Calculates Skaggs information measure</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		ratemap : array_like</span>
<span class="sd">			The binned up ratemap</span>
<span class="sd">		dwelltimes: array_like</span>
<span class="sd">			Must be same size as ratemap</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		bits_per_spike : float</span>
<span class="sd">			Skaggs information score</span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">		THIS DATA SHOULD UNDERGO ADAPTIVE BINNING - See adaptiveBin in binning class above</span>
<span class="sd">		</span>
<span class="sd">		Returns Skaggs et al&#39;s estimate of spatial information in bits per spike:</span>

<span class="sd">		.. math:: I = sum_{x} p(x).r(x).log(r(x)/r)</span>
<span class="sd">		</span>
<span class="sd">		&quot;&quot;&quot;</span>

		<span class="n">dwelltimes</span> <span class="o">=</span> <span class="n">dwelltimes</span> <span class="o">/</span> <span class="mi">50</span>  <span class="c1"># assumed sample rate of 50Hz</span>
		<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">ratemap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">ratemap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ratemap</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">ratemap</span><span class="p">)),</span> <span class="mi">1</span><span class="p">))</span>
			<span class="n">dwelltimes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dwelltimes</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">dwelltimes</span><span class="p">)),</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">duration</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">dwelltimes</span><span class="p">)</span>
		<span class="n">meanrate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">ratemap</span> <span class="o">*</span> <span class="n">dwelltimes</span><span class="p">)</span> <span class="o">/</span> <span class="n">duration</span>
		<span class="k">if</span> <span class="n">meanrate</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
			<span class="n">bits_per_spike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
			<span class="k">return</span> <span class="n">bits_per_spike</span>
		<span class="n">p_x</span> <span class="o">=</span> <span class="n">dwelltimes</span> <span class="o">/</span> <span class="n">duration</span>
		<span class="n">p_r</span> <span class="o">=</span> <span class="n">ratemap</span> <span class="o">/</span> <span class="n">meanrate</span>
		<span class="n">dum</span> <span class="o">=</span> <span class="n">p_x</span> <span class="o">*</span> <span class="n">ratemap</span>
		<span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">dum</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">bits_per_spike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">dum</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">p_r</span><span class="p">[</span><span class="n">ind</span><span class="p">]))</span>
		<span class="n">bits_per_spike</span> <span class="o">=</span> <span class="n">bits_per_spike</span> <span class="o">/</span> <span class="n">meanrate</span>
		<span class="k">return</span> <span class="n">bits_per_spike</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Robin Hayman

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>