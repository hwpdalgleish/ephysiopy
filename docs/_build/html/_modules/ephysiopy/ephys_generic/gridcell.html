

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ephysiopy.ephys_generic.gridcell &mdash; ephysiopy 1.5.55 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> ephysiopy
          

          
          </a>

          
            
            
              <div class="version">
                1.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"></div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">ephysiopy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>ephysiopy.ephys_generic.gridcell</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for ephysiopy.ephys_generic.gridcell</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Calculation of the various metrics for quantifying the behaviour of grid cells</span>
<span class="sd">and some graphical output etc</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span><span class="o">,</span> <span class="nn">scipy.io</span><span class="o">,</span> <span class="nn">scipy.signal</span>
<span class="kn">import</span> <span class="nn">skimage</span><span class="o">,</span> <span class="nn">skimage.morphology</span><span class="o">,</span> <span class="nn">skimage.measure</span><span class="o">,</span> <span class="nn">skimage.feature</span><span class="o">,</span> <span class="nn">skimage.segmentation</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib.cm</span> <span class="k">as</span> <span class="nn">cm</span>
<span class="kn">from</span> <span class="nn">ephysiopy.dacq2py.utils</span> <span class="kn">import</span> <span class="n">rect</span>
<span class="kn">import</span> <span class="nn">mahotas</span>
<span class="kn">import</span> <span class="nn">collections</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;invalid value encountered in sqrt&quot;</span><span class="p">)</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;invalid value encountered in subtract&quot;</span><span class="p">)</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;invalid value encountered in greater&quot;</span><span class="p">)</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;invalid value encountered in true_divide&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="SAC"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.gridcell.SAC">[docs]</a><span class="k">class</span> <span class="nc">SAC</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Spatial AutoCorrelation (SAC) class</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">pass</span>
<div class="viewcode-block" id="SAC.autoCorr2D"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.gridcell.SAC.autoCorr2D">[docs]</a>	<span class="k">def</span> <span class="nf">autoCorr2D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">nodwell</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Performs a spatial autocorrelation on the array A</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		A : array_like</span>
<span class="sd">			Either 2 or 3D. In the former it is simply the binned up ratemap </span>
<span class="sd">			where the two dimensions correspond to x and y. </span>
<span class="sd">			If 3D then the first two dimensions are x</span>
<span class="sd">			and y and the third (last dimension) is &#39;stack&#39; of ratemaps</span>
<span class="sd">		nodwell : array_like</span>
<span class="sd">			A boolean array corresponding the bins in the ratemap that</span>
<span class="sd">			weren&#39;t visited. See Notes below.</span>
<span class="sd">		tol : float, optional</span>
<span class="sd">			Values below this are set to zero to deal with v small values</span>
<span class="sd">			thrown up by the fft. Default 1e-10</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>

<span class="sd">		sac : array_like</span>
<span class="sd">			The spatial autocorrelation in the relevant dimensionality</span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">		The nodwell input can usually be generated by:</span>

<span class="sd">		&gt;&gt;&gt; nodwell = ~np.isfinite(A)</span>
<span class="sd">		</span>
<span class="sd">		&quot;&quot;&quot;</span>

		<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
			<span class="n">m</span><span class="p">,</span><span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
			<span class="n">o</span> <span class="o">=</span> <span class="mi">1</span>
			<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">o</span><span class="p">))</span>
			<span class="n">nodwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nodwell</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">o</span><span class="p">))</span>
		<span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
			<span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">o</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
			<span class="n">x</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
		
		<span class="n">x</span><span class="p">[</span><span class="n">nodwell</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="c1"># [Step 1] Obtain FFTs of x, the sum of squares and bins visited</span>
		<span class="n">Fx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">FsumOfSquares_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">Fn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">nodwell</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
		<span class="c1"># [Step 2] Multiply the relevant transforms and invert to obtain the</span>
		<span class="c1"># equivalent convolutions</span>
		<span class="n">rawCorr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Fx</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Fx</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span><span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
		<span class="n">sums_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Fx</span><span class="p">)</span> <span class="o">*</span> <span class="n">Fn</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span><span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
		<span class="n">sumOfSquares_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Fn</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">FsumOfSquares_x</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span><span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
		<span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Fn</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Fn</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span><span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
		<span class="c1"># [Step 3] Account for rounding errors.</span>
		<span class="n">rawCorr</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">rawCorr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="n">sums_x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sums_x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="n">sumOfSquares_x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sumOfSquares_x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
		<span class="n">N</span><span class="p">[</span><span class="n">N</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
		<span class="c1"># [Step 4] Compute correlation matrix</span>
		<span class="n">mapStd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">sumOfSquares_x</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span> <span class="o">-</span> <span class="n">sums_x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
		<span class="n">mapCovar</span> <span class="o">=</span> <span class="p">(</span><span class="n">rawCorr</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span> <span class="o">-</span> <span class="n">sums_x</span> <span class="o">*</span> <span class="n">sums_x</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,:,:][:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">,:][:,:,:]</span>

		<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">mapCovar</span> <span class="o">/</span> <span class="n">mapStd</span> <span class="o">/</span> <span class="n">mapStd</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,:,:][:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">,:][:,:,:])</span></div>

<div class="viewcode-block" id="SAC.crossCorr2D"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.gridcell.SAC.crossCorr2D">[docs]</a>	<span class="k">def</span> <span class="nf">crossCorr2D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">A_nodwell</span><span class="p">,</span> <span class="n">B_nodwell</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Performs a spatial crosscorrelation between the arrays A and B</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		A, B : array_like</span>
<span class="sd">			Either 2 or 3D. In the former it is simply the binned up ratemap </span>
<span class="sd">			where the two dimensions correspond to x and y. </span>
<span class="sd">			If 3D then the first two dimensions are x</span>
<span class="sd">			and y and the third (last dimension) is &#39;stack&#39; of ratemaps</span>
<span class="sd">		nodwell_A, nodwell_B : array_like</span>
<span class="sd">			A boolean array corresponding the bins in the ratemap that</span>
<span class="sd">			weren&#39;t visited. See Notes below.</span>
<span class="sd">		tol : float, optional</span>
<span class="sd">			Values below this are set to zero to deal with v small values</span>
<span class="sd">			thrown up by the fft. Default 1e-10</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>

<span class="sd">		sac : array_like</span>
<span class="sd">			The spatial crosscorrelation in the relevant dimensionality</span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">		The nodwell input can usually be generated by:</span>

<span class="sd">		&gt;&gt;&gt; nodwell = ~np.isfinite(A)</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Both arrays must have the same dimensionality&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
			<span class="n">ma</span><span class="p">,</span> <span class="n">na</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
			<span class="n">mb</span><span class="p">,</span> <span class="n">nb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
			<span class="n">oa</span> <span class="o">=</span> <span class="n">ob</span> <span class="o">=</span> <span class="mi">1</span>
		<span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
			<span class="p">[</span><span class="n">ma</span><span class="p">,</span><span class="n">na</span><span class="p">,</span><span class="n">oa</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
			<span class="p">[</span><span class="n">mb</span><span class="p">,</span><span class="n">nb</span><span class="p">,</span><span class="n">ob</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
		<span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="p">(</span><span class="n">ma</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">oa</span><span class="p">))</span>
		<span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="p">(</span><span class="n">mb</span><span class="p">,</span> <span class="n">nb</span><span class="p">,</span> <span class="n">ob</span><span class="p">))</span>
<span class="c1">#		import pdb</span>
<span class="c1">#		pdb.set_trace()</span>
		<span class="n">A_nodwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">A_nodwell</span><span class="p">,</span> <span class="p">(</span><span class="n">ma</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">oa</span><span class="p">))</span>
		<span class="n">B_nodwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">B_nodwell</span><span class="p">,</span> <span class="p">(</span><span class="n">mb</span><span class="p">,</span> <span class="n">nb</span><span class="p">,</span> <span class="n">ob</span><span class="p">))</span>
		<span class="n">A</span><span class="p">[</span><span class="n">A_nodwell</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="n">B</span><span class="p">[</span><span class="n">B_nodwell</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="c1"># [Step 1] Obtain FFTs of x, the sum of squares and bins visited</span>
		<span class="n">Fa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">mb</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span><span class="mi">2</span><span class="o">*</span><span class="n">nb</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">FsumOfSquares_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="mi">2</span><span class="o">*</span><span class="n">mb</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span><span class="mi">2</span><span class="o">*</span><span class="n">nb</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">Fn_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">A_nodwell</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span><span class="mi">2</span><span class="o">*</span><span class="n">mb</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span><span class="mi">2</span><span class="o">*</span><span class="n">nb</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

		<span class="n">Fb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">ma</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span><span class="mi">2</span><span class="o">*</span><span class="n">na</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">FsumOfSquares_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="mi">2</span><span class="o">*</span><span class="n">ma</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span><span class="mi">2</span><span class="o">*</span><span class="n">na</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">Fn_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">B_nodwell</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span><span class="mi">2</span><span class="o">*</span><span class="n">ma</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span><span class="mi">2</span><span class="o">*</span><span class="n">na</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
		<span class="c1"># [Step 2] Multiply the relevant transforms and invert to obtain the</span>
		<span class="c1"># equivalent convolutions</span>
		<span class="n">rawCorr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Fa</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Fb</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span>
		<span class="n">sums_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Fa</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Fn_b</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span>
		<span class="n">sums_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Fn_a</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Fb</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span>
		<span class="n">sumOfSquares_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">FsumOfSquares_a</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Fn_b</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span>
		<span class="n">sumOfSquares_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Fn_a</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">FsumOfSquares_b</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span>
		<span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Fn_a</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Fn_b</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span>
		<span class="c1"># [Step 3] Account for rounding errors.</span>
		<span class="n">rawCorr</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">rawCorr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="n">sums_a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sums_a</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="n">sums_b</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sums_b</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="n">sumOfSquares_a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sumOfSquares_a</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="n">sumOfSquares_b</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sumOfSquares_b</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
		<span class="n">N</span><span class="p">[</span><span class="n">N</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
		<span class="c1"># [Step 4] Compute correlation matrix</span>
		<span class="n">mapStd_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">sumOfSquares_a</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span> <span class="o">-</span> <span class="n">sums_a</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
		<span class="n">mapStd_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">sumOfSquares_b</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span> <span class="o">-</span> <span class="n">sums_b</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
		<span class="n">mapCovar</span> <span class="o">=</span> <span class="p">(</span><span class="n">rawCorr</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span> <span class="o">-</span> <span class="n">sums_a</span> <span class="o">*</span> <span class="n">sums_b</span>

		<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">mapCovar</span> <span class="o">/</span> <span class="p">(</span><span class="n">mapStd_a</span> <span class="o">*</span> <span class="n">mapStd_b</span><span class="p">))</span></div>

<div class="viewcode-block" id="SAC.t_win_SAC"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.gridcell.SAC.t_win_SAC">[docs]</a>	<span class="k">def</span> <span class="nf">t_win_SAC</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xy</span><span class="p">,</span> <span class="n">spkIdx</span><span class="p">,</span> <span class="n">ppm</span> <span class="o">=</span> <span class="mi">365</span><span class="p">,</span> <span class="n">winSize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">pos_sample_rate</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">nbins</span><span class="o">=</span><span class="mi">71</span><span class="p">,</span> <span class="n">boxcar</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">Pthresh</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">downsampfreq</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Temporal windowed spatial autocorrelation. For rationale see Notes below</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		xy : array_like</span>
<span class="sd">			The position data</span>
<span class="sd">		spkIdx : array_like</span>
<span class="sd">			The indices in xy where the cell fired</span>
<span class="sd">		ppm : int, optional</span>
<span class="sd">			The camera pixels per metre. Default 365</span>
<span class="sd">		winSize : int, optional</span>
<span class="sd">			The window size for the temporal search</span>
<span class="sd">		pos_sample_rate : int, optional</span>
<span class="sd">			The rate at which position was sampled. Default 50</span>
<span class="sd">		nbins : int, optional</span>
<span class="sd">			The number of bins for creating the resulting ratemap. Default 71</span>
<span class="sd">		boxcar : int, optional</span>
<span class="sd">			The size of the smoothing kernel to smooth ratemaps. Default 5</span>
<span class="sd">		Pthresh : int, optional</span>
<span class="sd">			The cut=off for values in the ratemap; values &lt; Pthresh become nans.</span>
<span class="sd">			Default 100</span>
<span class="sd">		downsampfreq : int, optional</span>
<span class="sd">			How much to downsample. Default 50</span>
<span class="sd">		plot : bool, optional</span>
<span class="sd">			Whether to show a plot of the result. Default False</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		H : array_like</span>
<span class="sd">			The temporal windowed SAC</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="c1"># [Stage 0] Get some numbers</span>
		<span class="n">xy</span> <span class="o">=</span> <span class="n">xy</span> <span class="o">/</span> <span class="n">ppm</span> <span class="o">*</span> <span class="mi">100</span>
		<span class="n">n_samps</span> <span class="o">=</span> <span class="n">xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">n_spks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spkIdx</span><span class="p">)</span>
		<span class="n">winSizeBins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">winSize</span> <span class="o">*</span> <span class="n">pos_sample_rate</span><span class="p">,</span> <span class="n">n_samps</span><span class="p">])</span>
		<span class="n">downsample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">pos_sample_rate</span> <span class="o">/</span> <span class="n">downsampfreq</span><span class="p">)</span> <span class="c1"># factor by which positions are downsampled.</span>
		<span class="n">Pthresh</span> <span class="o">=</span> <span class="n">Pthresh</span> <span class="o">/</span> <span class="n">downsample</span> <span class="c1"># take account of downsampling</span>

		<span class="c1"># [Stage 1] Calculate number of spikes in the window for each spikeInd (ignoring spike itself)</span>
		<span class="c1">#1a. Loop preparation</span>
		<span class="n">nSpikesInWin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_spks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

		<span class="c1">#1b. Keep looping until we have dealt with all spikes</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spkIdx</span><span class="p">):</span>
			<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">spkIdx</span><span class="p">,</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">winSizeBins</span><span class="p">))</span>
			<span class="n">nSpikesInWin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spkIdx</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># i.e. ignore ith spike</span>

		<span class="c1"># [Stage 2] Prepare for main loop</span>
		<span class="c1">#2a. Work out offset inidices to be used when storing spike data</span>
		<span class="n">off_spike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">([</span><span class="n">nSpikesInWin</span><span class="p">])</span>
		<span class="n">off_spike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">off_spike</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span><span class="n">constant_values</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

		<span class="c1">#2b. Work out number of downsampled pos bins in window and offset indicies for storing data</span>
		<span class="n">nPosInWindow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">winSizeBins</span><span class="p">,</span> <span class="n">n_samps</span> <span class="o">-</span> <span class="n">spkIdx</span><span class="p">)</span>
		<span class="n">nDownsampInWin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">nPosInWindow</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">downsample</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>

		<span class="n">off_dwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">nDownsampInWin</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
		<span class="n">off_dwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">off_dwell</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span><span class="n">constant_values</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
		
		<span class="c1">#2c. Pre-allocate dwell and spike arrays, singles for speed</span>
		<span class="n">dwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">off_dwell</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">single</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
		<span class="n">spike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">off_spike</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">single</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

		<span class="n">filled_pvals</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="n">filled_svals</span> <span class="o">=</span> <span class="mi">0</span>

		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_spks</span><span class="p">):</span>
			<span class="c1"># calculate dwell displacements</span>
			<span class="n">winInd_dwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">spkIdx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">spkIdx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">winSizeBins</span><span class="p">,</span> <span class="n">n_samps</span><span class="p">),</span> <span class="n">downsample</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
			<span class="n">WL</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">winInd_dwell</span><span class="p">)</span>
			<span class="n">dwell</span><span class="p">[:,</span> <span class="n">filled_pvals</span><span class="p">:</span><span class="n">filled_pvals</span> <span class="o">+</span> <span class="n">WL</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span><span class="n">xy</span><span class="p">[:,</span> <span class="n">winInd_dwell</span><span class="p">])</span> <span class="o">-</span> <span class="n">xy</span><span class="p">[:,</span><span class="n">spkIdx</span><span class="p">[</span><span class="n">i</span><span class="p">]]))</span>
			<span class="n">filled_pvals</span> <span class="o">=</span> <span class="n">filled_pvals</span> <span class="o">+</span> <span class="n">WL</span>
			<span class="c1"># calculate spike displacements</span>
			<span class="n">winInd_spks</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">spkIdx</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">n_spks</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">spkIdx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">winSizeBins</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
			<span class="n">WL</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">winInd_spks</span><span class="p">)</span>
			<span class="n">spike</span><span class="p">[:,</span> <span class="n">filled_svals</span><span class="p">:</span><span class="n">filled_svals</span><span class="o">+</span><span class="n">WL</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span><span class="n">xy</span><span class="p">[:,</span> <span class="n">spkIdx</span><span class="p">[</span><span class="n">winInd_spks</span><span class="p">]])</span> <span class="o">-</span> <span class="n">xy</span><span class="p">[:,</span><span class="n">spkIdx</span><span class="p">[</span><span class="n">i</span><span class="p">]]))</span>
			<span class="n">filled_svals</span> <span class="o">=</span> <span class="n">filled_svals</span> <span class="o">+</span> <span class="n">WL</span>

		<span class="n">dwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">dwell</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dwell</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">spike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">spike</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">spike</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

		<span class="n">dwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">dwell</span><span class="p">,</span> <span class="o">-</span><span class="n">dwell</span><span class="p">))</span>
		<span class="n">spike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">spike</span><span class="p">,</span> <span class="o">-</span><span class="n">spike</span><span class="p">))</span>

		<span class="n">dwell_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dwell</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">dwell_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dwell</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

		<span class="n">binsize</span> <span class="o">=</span> <span class="p">(</span><span class="n">dwell_max</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dwell_min</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">nbins</span>

		<span class="n">dwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((</span><span class="n">dwell</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">dwell</span><span class="p">)</span> <span class="o">*</span> <span class="n">dwell_min</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">)</span>
		<span class="n">spike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((</span><span class="n">spike</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">spike</span><span class="p">)</span> <span class="o">*</span> <span class="n">dwell_min</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span> <span class="o">/</span> <span class="n">binsize</span><span class="p">)</span>

		<span class="n">binsize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dwell</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">binedges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(((</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="o">-</span><span class="mf">0.5</span><span class="p">),</span><span class="n">binsize</span><span class="o">+</span><span class="mf">0.5</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
		<span class="n">Hp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">(</span><span class="n">dwell</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span> <span class="n">dwell</span><span class="p">[</span><span class="mi">1</span><span class="p">,:],</span> <span class="nb">range</span><span class="o">=</span><span class="n">binedges</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">binsize</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">Hs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">(</span><span class="n">spike</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span> <span class="n">spike</span><span class="p">[</span><span class="mi">1</span><span class="p">,:],</span> <span class="nb">range</span><span class="o">=</span><span class="n">binedges</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">binsize</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1">#        # reverse y,x order</span>
		<span class="n">Hp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">Hp</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">Hs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">Hs</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

		<span class="kn">from</span> <span class="nn">ephysiopy.ephys_generic.binning</span> <span class="kn">import</span> <span class="n">RateMap</span>
		<span class="n">R</span> <span class="o">=</span> <span class="n">RateMap</span><span class="p">()</span>

		<span class="n">fHp</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">blurImage</span><span class="p">(</span><span class="n">Hp</span><span class="p">,</span> <span class="n">boxcar</span><span class="p">)</span>
		<span class="n">fHs</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">blurImage</span><span class="p">(</span><span class="n">Hs</span><span class="p">,</span> <span class="n">boxcar</span><span class="p">)</span>

		<span class="n">H</span> <span class="o">=</span> <span class="n">fHs</span> <span class="o">/</span> <span class="n">fHp</span>
		<span class="n">H</span><span class="p">[</span><span class="n">Hp</span> <span class="o">&lt;</span> <span class="n">Pthresh</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

		<span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
			<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
			<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
			<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
		<span class="k">return</span> <span class="n">H</span></div>

<div class="viewcode-block" id="SAC.getMeasures"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.gridcell.SAC.getMeasures">[docs]</a>	<span class="k">def</span> <span class="nf">getMeasures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">maxima</span><span class="o">=</span><span class="s1">&#39;centroid&#39;</span><span class="p">,</span> <span class="n">field_extent_method</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">allProps</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Extracts various measures from a spatial autocorrelogram</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		A : array_like</span>
<span class="sd">			The spatial autocorrelogram (SAC)</span>
<span class="sd">		maxima : str, optional</span>
<span class="sd">			The method used to detect the peaks in the SAC. </span>
<span class="sd">			Legal values are &#39;single&#39; and &#39;centroid&#39;. Default &#39;centroid&#39;</span>
<span class="sd">		field_extent_method : int, optional</span>
<span class="sd">			The method used to delimit the regions of interest in the SAC</span>
<span class="sd">			Legal values:</span>
<span class="sd">			* 1 - uses the half height of the ROI peak to limit field extent</span>
<span class="sd">			* 2 - uses a watershed method to limit field extent</span>
<span class="sd">			Default 2</span>
<span class="sd">		allProps : bool, optional</span>
<span class="sd">			Whether to return a dictionary that contains the attempt to fit an</span>
<span class="sd">			ellipse around the edges of the central size peaks. See below</span>
<span class="sd">			Default True</span>
<span class="sd">		</span>
<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		props : dict</span>
<span class="sd">			A dictionary containing measures of the SAC. The keys include things like:</span>
<span class="sd">			* gridness score</span>
<span class="sd">			* scale</span>
<span class="sd">			* orientation</span>
<span class="sd">			* the coordinates of the peaks (nominally 6) closest to the centre of the SAC</span>
<span class="sd">			* a binary mask that defines the extent of the 6 central fields around the centre</span>
<span class="sd">			* values of the rotation procedure used to calculate the gridness score</span>
<span class="sd">			* ellipse axes and angle (if allProps is True and the procedure worked)</span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">		The output from this method can be used as input to the show() method of this class.</span>
<span class="sd">		When it is the plot produced will be a lot more informative.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">A_tmp</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
		<span class="n">A_tmp</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">A</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
		<span class="n">A_tmp</span><span class="p">[</span><span class="n">A_tmp</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
		<span class="n">A_sz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
		<span class="c1"># [STAGE 1] find peaks &amp; identify 7 closest to centre</span>
		<span class="k">if</span> <span class="s1">&#39;min_distance&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">min_distance</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;min_distance&#39;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">min_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">A_sz</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">8.</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
		<span class="n">peaksMask</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">peak_local_max</span><span class="p">(</span><span class="n">A_tmp</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">min_distance</span><span class="o">=</span><span class="n">min_distance</span><span class="p">,</span><span class="n">exclude_border</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="n">peaksLabel</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">peaksMask</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">maxima</span> <span class="o">==</span> <span class="s1">&#39;centroid&#39;</span><span class="p">:</span>
			<span class="n">S</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">regionprops</span><span class="p">(</span><span class="n">peaksLabel</span><span class="p">)</span>
			<span class="n">xyCoordPeaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;Centroid&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;Centroid&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">S</span><span class="p">]))</span>
		<span class="k">elif</span> <span class="n">maxima</span> <span class="o">==</span> <span class="s1">&#39;single&#39;</span><span class="p">:</span>
			<span class="n">xyCoordPeaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">peaksLabel</span><span class="p">))))</span><span class="c1"># flipped so xy instead of yx</span>
		<span class="c1"># Convert to a new reference frame which has the origin at the centre of the autocorr</span>
		<span class="n">centralPoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">A_sz</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
		<span class="n">xyCoordPeaksCentral</span> <span class="o">=</span> <span class="n">xyCoordPeaks</span> <span class="o">-</span> <span class="n">centralPoint</span>
		<span class="c1"># calculate distance of peaks from centre and find 7 closest</span>
		<span class="c1"># NB one is central peak - dealt with later</span>
		<span class="n">peaksDistToCentre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">xyCoordPeaksCentral</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">xyCoordPeaksCentral</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">orderOfClose</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">peaksDistToCentre</span><span class="p">)</span>
		<span class="c1">#Get id and coordinates of closest peaks1</span>
		<span class="c1"># NB closest peak at index 0 will be centre</span>
		<span class="n">closestPeaks</span> <span class="o">=</span> <span class="n">orderOfClose</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">((</span><span class="mi">7</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">orderOfClose</span><span class="p">)))]</span>
		<span class="n">closestPeaksCoord</span> <span class="o">=</span> <span class="n">xyCoordPeaks</span><span class="p">[</span><span class="n">closestPeaks</span><span class="p">,:]</span>
		<span class="n">closestPeaksCoord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">closestPeaksCoord</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
		<span class="c1"># [Stage 2] Expand peak pixels into the surrounding half-height region</span>
		<span class="k">if</span> <span class="n">field_extent_method</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">peakLabel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">closestPeaks</span><span class="p">)))</span>
			<span class="n">perimeterLabel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">peakLabel</span><span class="p">)</span>
			<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">closestPeaks</span><span class="p">)):</span>
				<span class="n">peakLabel</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">],</span> <span class="n">perimeterLabel</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__findPeakExtent__</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">closestPeaks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">closestPeaksCoord</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">fieldsLabel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">peakLabel</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
			<span class="n">fieldsMask</span> <span class="o">=</span> <span class="n">fieldsLabel</span> <span class="o">&gt;</span> <span class="mi">0</span>
		<span class="k">elif</span> <span class="n">field_extent_method</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
			<span class="c1"># 2a find the inverse drainage bin for each peak</span>
			<span class="n">fieldsLabel</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">watershed</span><span class="p">(</span><span class="n">image</span><span class="o">=-</span><span class="n">A_tmp</span><span class="p">,</span> <span class="n">markers</span><span class="o">=</span><span class="n">peaksLabel</span><span class="p">)</span>
<span class="c1">#            fieldsLabel = skimage.segmentation.random_walker(-A, peaksLabel)</span>
			<span class="c1"># 2b. Work out what threshold to use in each drainage-basin</span>
			<span class="n">nZones</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">fieldsLabel</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
			<span class="n">fieldIDs</span> <span class="o">=</span> <span class="n">fieldsLabel</span><span class="p">[</span><span class="n">closestPeaksCoord</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">closestPeaksCoord</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span>
			<span class="n">thresholds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nZones</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
			<span class="c1"># set thresholds for each sub-field at half-maximum</span>
			<span class="n">thresholds</span><span class="p">[</span><span class="n">fieldIDs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">closestPeaksCoord</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">closestPeaksCoord</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">/</span> <span class="mi">2</span>
			<span class="n">fieldsMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">nZones</span><span class="p">))</span>
			<span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fieldIDs</span><span class="p">:</span>
				<span class="n">sub</span> <span class="o">=</span> <span class="n">fieldsLabel</span> <span class="o">==</span> <span class="n">field</span>
				<span class="n">fieldsMask</span><span class="p">[:,:,</span> <span class="n">field</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;</span><span class="n">thresholds</span><span class="p">[</span><span class="n">field</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
				<span class="c1"># TODO: the above step can fragment a sub-field in poorly formed SACs</span>
				<span class="c1"># need to deal with this...perhaps by only retaining the largest</span>
				<span class="c1"># sub-sub-field</span>
				<span class="n">labelled_sub_field</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">fieldsMask</span><span class="p">[:,:,</span> <span class="n">field</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
				<span class="n">sub_props</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">regionprops</span><span class="p">(</span><span class="n">labelled_sub_field</span><span class="p">)</span>
				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub_props</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
					<span class="n">distFromCentre</span> <span class="o">=</span> <span class="p">[]</span>
					<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sub_props</span><span class="p">)):</span>
						<span class="n">centroid</span> <span class="o">=</span> <span class="n">sub_props</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="s1">&#39;Centroid&#39;</span><span class="p">]</span>
						<span class="n">distFromCentre</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">A_sz</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">A_sz</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
					<span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distFromCentre</span><span class="p">)</span>
					<span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
					<span class="n">tmp</span><span class="p">[</span><span class="n">sub_props</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="s1">&#39;Coordinates&#39;</span><span class="p">][:,</span><span class="mi">0</span><span class="p">],</span><span class="n">sub_props</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="s1">&#39;Coordinates&#39;</span><span class="p">][:,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
					<span class="n">fieldsMask</span><span class="p">[:,:,</span> <span class="n">field</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
			<span class="n">fieldsMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">fieldsMask</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
			<span class="n">fieldsLabel</span><span class="p">[</span><span class="o">~</span><span class="n">fieldsMask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="n">fieldPerim</span> <span class="o">=</span> <span class="n">mahotas</span><span class="o">.</span><span class="n">bwperim</span><span class="p">(</span><span class="n">fieldsMask</span><span class="p">)</span>
		<span class="n">fieldsLabel</span> <span class="o">=</span> <span class="n">fieldsLabel</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
		<span class="c1"># [Stage 3] Calculate a couple of metrics based on the closest peaks</span>
		<span class="c1">#Find the (mean) autoCorr value at the closest peak pixels</span>
		<span class="n">nPixelsInLabel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">fieldsLabel</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
		<span class="n">sumRInLabel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">fieldsLabel</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">weights</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
		<span class="n">meanRInLabel</span> <span class="o">=</span> <span class="n">sumRInLabel</span><span class="p">[</span><span class="n">closestPeaks</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">nPixelsInLabel</span><span class="p">[</span><span class="n">closestPeaks</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
		<span class="c1"># get scale of grid</span>
		<span class="n">closestPeakDistFromCentre</span> <span class="o">=</span> <span class="n">peaksDistToCentre</span><span class="p">[</span><span class="n">closestPeaks</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
		<span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">closestPeakDistFromCentre</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
		<span class="c1"># get orientation</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="n">orientation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getorientation</span><span class="p">(</span><span class="n">xyCoordPeaksCentral</span><span class="p">,</span> <span class="n">closestPeaks</span><span class="p">)</span>
		<span class="k">except</span><span class="p">:</span>
			<span class="n">orientation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
		<span class="c1"># calculate gridness</span>
		<span class="c1"># THIS STEP MASKS THE MIDDLE AND OUTER PARTS OF THE SAC</span>
		<span class="c1"># </span>
		<span class="c1"># crop to the central region of the image and remove central peak</span>
		<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">centralPoint</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">centralPoint</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">A_sz</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">centralPoint</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">centralPoint</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">A_sz</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">indexing</span> <span class="o">=</span> <span class="s1">&#39;ij&#39;</span><span class="p">)</span>
		<span class="n">dist2Centre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span><span class="n">yy</span><span class="p">)</span>
		<span class="n">maxDistFromCentre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">closestPeaks</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">7</span><span class="p">:</span>
			<span class="n">maxDistFromCentre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dist2Centre</span><span class="p">[</span><span class="n">fieldsMask</span><span class="p">])</span>
		<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">maxDistFromCentre</span><span class="p">),</span> <span class="n">maxDistFromCentre</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">A_sz</span><span class="o">/</span><span class="mi">2</span><span class="p">))):</span>
			<span class="n">maxDistFromCentre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">A_sz</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
		<span class="n">gridnessMaskAll</span> <span class="o">=</span> <span class="n">dist2Centre</span> <span class="o">&lt;=</span> <span class="n">maxDistFromCentre</span>
		<span class="n">centreMask</span> <span class="o">=</span> <span class="n">fieldsLabel</span> <span class="o">==</span> <span class="n">fieldsLabel</span><span class="p">[</span><span class="n">centralPoint</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">centralPoint</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
		<span class="n">gridnessMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">gridnessMaskAll</span><span class="p">,</span> <span class="o">~</span><span class="n">centreMask</span><span class="p">)</span>
		<span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">maxDistFromCentre</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
		<span class="n">autoCorrMiddle</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
		<span class="n">autoCorrMiddle</span><span class="p">[</span><span class="o">~</span><span class="n">gridnessMask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
		<span class="n">autoCorrMiddle</span> <span class="o">=</span> <span class="n">autoCorrMiddle</span><span class="p">[</span><span class="o">-</span><span class="n">W</span> <span class="o">+</span> <span class="n">centralPoint</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">W</span> <span class="o">+</span> <span class="n">centralPoint</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="n">W</span><span class="o">+</span><span class="n">centralPoint</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">W</span><span class="o">+</span><span class="n">centralPoint</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
		<span class="c1"># crop the edges of the middle if there are rows/ columns of nans</span>
		<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">autoCorrMiddle</span><span class="p">),</span> <span class="mi">1</span><span class="p">)):</span>
			<span class="n">autoCorrMiddle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">autoCorrMiddle</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">autoCorrMiddle</span><span class="p">),</span> <span class="mi">1</span><span class="p">)))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">autoCorrMiddle</span><span class="p">),</span> <span class="mi">0</span><span class="p">)):</span>
			<span class="n">autoCorrMiddle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">autoCorrMiddle</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">autoCorrMiddle</span><span class="p">),</span> <span class="mi">0</span><span class="p">)))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="s1">&#39;step&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">step</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;step&#39;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">step</span> <span class="o">=</span> <span class="mi">30</span>
		<span class="n">gridness</span><span class="p">,</span> <span class="n">rotationCorrVals</span><span class="p">,</span> <span class="n">rotationArr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getgridness</span><span class="p">(</span><span class="n">autoCorrMiddle</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">)</span>
		<span class="c1"># attempt to fit an ellipse to the closest peaks</span>
		<span class="k">if</span> <span class="n">allProps</span><span class="p">:</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fit_ellipse__</span><span class="p">(</span><span class="n">closestPeaksCoord</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span><span class="mi">0</span><span class="p">],</span><span class="n">closestPeaksCoord</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span><span class="mi">1</span><span class="p">])</span>
				<span class="n">im_centre</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ellipse_center__</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
				<span class="n">ellipse_axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ellipse_axis_length__</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
				<span class="n">ellipse_angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ellipse_angle_of_rotation__</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
	<span class="c1">#            ang =  ang + np.pi</span>
				<span class="n">ellipseXY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getellipseXY__</span><span class="p">(</span><span class="n">ellipse_axes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ellipse_axes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ellipse_angle</span><span class="p">,</span> <span class="n">im_centre</span><span class="p">)</span>
				<span class="c1"># get the minimum containing circle based on the minor axis of the ellipse</span>
				<span class="n">circleXY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getcircleXY__</span><span class="p">(</span><span class="n">im_centre</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ellipse_axes</span><span class="p">))</span>
			<span class="k">except</span><span class="p">:</span>
				<span class="n">im_centre</span> <span class="o">=</span> <span class="n">centralPoint</span>
				<span class="n">ellipse_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
				<span class="n">ellipse_axes</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
				<span class="n">ellipseXY</span> <span class="o">=</span> <span class="n">centralPoint</span>
				<span class="n">circleXY</span> <span class="o">=</span> <span class="n">centralPoint</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">ellipseXY</span> <span class="o">=</span> <span class="kc">None</span>
			<span class="n">circleXY</span> <span class="o">=</span> <span class="kc">None</span>
			<span class="n">ellipse_axes</span> <span class="o">=</span> <span class="kc">None</span>
			<span class="n">ellipse_angle</span> <span class="o">=</span> <span class="kc">None</span>
			<span class="n">im_centre</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="c1"># collect all the following keywords into a dict for output</span>
		<span class="n">dictKeys</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;gridness&#39;</span><span class="p">,</span><span class="s1">&#39;scale&#39;</span><span class="p">,</span> <span class="s1">&#39;orientation&#39;</span><span class="p">,</span> <span class="s1">&#39;closestPeaksCoord&#39;</span><span class="p">,</span> <span class="s1">&#39;gridnessMaskAll&#39;</span><span class="p">,</span> <span class="s1">&#39;gridnessMask&#39;</span><span class="p">,</span>
		<span class="s1">&#39;ellipse_axes&#39;</span><span class="p">,</span> <span class="s1">&#39;ellipse_angle&#39;</span><span class="p">,</span> <span class="s1">&#39;im_centre&#39;</span><span class="p">,</span> <span class="s1">&#39;rotationArr&#39;</span><span class="p">,</span><span class="s1">&#39;rotationCorrVals&#39;</span><span class="p">)</span>
		<span class="n">outDict</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">dictKeys</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">thiskey</span> <span class="ow">in</span> <span class="n">outDict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">outDict</span><span class="p">[</span><span class="n">thiskey</span><span class="p">]</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()[</span><span class="n">thiskey</span><span class="p">]</span><span class="c1"># neat trick: locals is a dict that holds all locally scoped variables</span>
		<span class="k">return</span> <span class="n">outDict</span></div>

<div class="viewcode-block" id="SAC.getorientation"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.gridcell.SAC.getorientation">[docs]</a>	<span class="k">def</span> <span class="nf">getorientation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peakCoords</span><span class="p">,</span> <span class="n">closestPeakIdx</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Calculates the angle of the peaks working counter-clockwise from 3 o&#39;clock</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		peakCoords : array_like</span>
<span class="sd">			The peak coordinates as pairs of xy</span>
<span class="sd">		closestPeakIdx : array_like</span>
<span class="sd">			A 1D array of the indices in peakCoords of the peaks closest to the centre</span>
<span class="sd">			of the SAC</span>
<span class="sd">		</span>
<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		peak_orientations : array_like</span>
<span class="sd">			An array of the angles of the peaks in the SAC working counter-clockwise</span>
<span class="sd">			from a line extending from the middle of the SAC to 3 o&#39;clock. The array</span>
<span class="sd">			is sorted from closest peak to the centre to the most distant</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">closestPeakIdx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">polar</span>
			<span class="n">closestPeaksCoordCentral</span> <span class="o">=</span> <span class="n">peakCoords</span><span class="p">[</span><span class="n">closestPeakIdx</span><span class="p">[</span><span class="mi">1</span><span class="p">::]]</span>
			<span class="n">theta</span> <span class="o">=</span> <span class="n">polar</span><span class="p">(</span><span class="n">closestPeaksCoordCentral</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">closestPeaksCoordCentral</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">deg</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
			<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">theta</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">theta</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="SAC.getgridness"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.gridcell.SAC.getgridness">[docs]</a>	<span class="k">def</span> <span class="nf">getgridness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">30</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Calculates the gridness score in a grid cell spatial autocorrelogram (SAC).</span>

<span class="sd">		Briefly, the data in `image` is rotated in `step` amounts and each rotated array</span>
<span class="sd">		is correlated with the original. The maximum of the values at 30, 90 and 150 degrees</span>
<span class="sd">		is the subtracted from the minimum of the values at 60, 120 and 180 degrees to give the</span>
<span class="sd">		grid score.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		image : array_like</span>
<span class="sd">			The spatial autocorrelogram</span>
<span class="sd">		step : int, optional</span>
<span class="sd">			The amount to rotate the SAC by in each step of the rotational correlation</span>
<span class="sd">			procedure</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		gridmeasures : 3-tuple</span>
<span class="sd">			The gridscore, the correlation values at each `step` and the rotational array</span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">		The correlation performed is a Pearsons R. Some rescaling of the values in `image` is</span>
<span class="sd">		performed following rotation.</span>

<span class="sd">		See Also</span>
<span class="sd">		--------</span>
<span class="sd">		skimage.transform.rotate : for how the rotation of `image` is done</span>
<span class="sd">		skimage.exposure.rescale_intensity : for the resscaling following rotation</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="c1">#TODO: add options in here for whether the full range of correlations are wanted</span>
		<span class="c1"># or whether a reduced set is wanted (i.e. at the 30-tuples)</span>
		<span class="n">rotationalCorrVals</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">181</span><span class="p">,</span><span class="n">step</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
		<span class="n">rotationArr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rotationalCorrVals</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
		<span class="c1"># autoCorrMiddle needs to be rescaled or the image rotation falls down</span>
		<span class="c1"># as values are cropped to lie between 0 and 1.0</span>
		<span class="n">in_range</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">image</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">image</span><span class="p">))</span>
		<span class="n">out_range</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">autoCorrMiddleRescaled</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">exposure</span><span class="o">.</span><span class="n">rescale_intensity</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">in_range</span><span class="p">,</span> <span class="n">out_range</span><span class="p">)</span>
		<span class="n">origNanIdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">autoCorrMiddleRescaled</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
		<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">angle</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rotationalCorrVals</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
			<span class="n">rotatedA</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">autoCorrMiddleRescaled</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="n">angle</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
			<span class="c1"># ignore nans</span>
			<span class="n">rotatedNanIdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">rotatedA</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
			<span class="n">allNans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">origNanIdx</span><span class="p">,</span> <span class="n">rotatedNanIdx</span><span class="p">)</span>
			<span class="c1"># get the correlation between the original and rotated images and assign</span>
			<span class="n">rotationalCorrVals</span><span class="p">[</span><span class="n">angle</span><span class="p">]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">pearsonr</span><span class="p">(</span><span class="n">autoCorrMiddleRescaled</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="o">~</span><span class="n">allNans</span><span class="p">],</span> <span class="n">rotatedA</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="o">~</span><span class="n">allNans</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
			<span class="n">rotationArr</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">rotationalCorrVals</span><span class="p">[</span><span class="n">angle</span><span class="p">]</span>
		<span class="n">gridscore</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">((</span><span class="n">rotationalCorrVals</span><span class="p">[</span><span class="mi">60</span><span class="p">],</span><span class="n">rotationalCorrVals</span><span class="p">[</span><span class="mi">120</span><span class="p">]))</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">((</span><span class="n">rotationalCorrVals</span><span class="p">[</span><span class="mi">150</span><span class="p">],</span><span class="n">rotationalCorrVals</span><span class="p">[</span><span class="mi">30</span><span class="p">],</span><span class="n">rotationalCorrVals</span><span class="p">[</span><span class="mi">90</span><span class="p">]))</span>
		<span class="k">return</span> <span class="n">gridscore</span><span class="p">,</span> <span class="n">rotationalCorrVals</span><span class="p">,</span> <span class="n">rotationArr</span></div>

<div class="viewcode-block" id="SAC.show"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.gridcell.SAC.show">[docs]</a>	<span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">inDict</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Displays the result of performing a spatial autocorrelation on a grid cell.</span>

<span class="sd">		Uses the spatial autocorrelogram calculated in autoCorr2D() and the dictionary</span>
<span class="sd">		populated in getmeasures() to make a pretty picture</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		A : array_like</span>
<span class="sd">			The spatial autocorrelogram</span>
<span class="sd">		inDict : dict</span>
<span class="sd">			The dictionary calculated in getmeasures</span>
<span class="sd">		ax : matplotlib.axes._subplots.AxesSubplot, optional</span>
<span class="sd">			If given the plot will get drawn in these axes. Default None</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		ret : matplotlib.image.AxesImage</span>
<span class="sd">			The axes in which the SAC is shown</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
			<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
		<span class="n">Am</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
		<span class="n">Am</span><span class="p">[</span><span class="o">~</span><span class="n">inDict</span><span class="p">[</span><span class="s1">&#39;gridnessMaskAll&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
		<span class="n">Am</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">Am</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">gray_r</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
		<span class="n">cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">jet</span>
		<span class="n">cmap</span><span class="o">.</span><span class="n">set_bad</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">Am</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;face&#39;</span><span class="p">)</span>
		<span class="c1"># horizontal green line at 3 o&#39;clock</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">((</span><span class="n">inDict</span><span class="p">[</span><span class="s1">&#39;closestPeaksCoord&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">inDict</span><span class="p">[</span><span class="s1">&#39;closestPeaksCoord&#39;</span><span class="p">][:,</span><span class="mi">1</span><span class="p">])),</span>
				  <span class="p">(</span><span class="n">inDict</span><span class="p">[</span><span class="s1">&#39;closestPeaksCoord&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">inDict</span><span class="p">[</span><span class="s1">&#39;closestPeaksCoord&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span><span class="s1">&#39;-g&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
		<span class="n">mag</span> <span class="o">=</span> <span class="n">inDict</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.5</span>
		<span class="n">th</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">inDict</span><span class="p">[</span><span class="s1">&#39;orientation&#39;</span><span class="p">],</span> <span class="mi">50</span><span class="p">)</span>
		<span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">rect</span><span class="p">(</span><span class="n">mag</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
		<span class="c1"># angle subtended by orientation</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">inDict</span><span class="p">[</span><span class="s1">&#39;gridnessMask&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="n">inDict</span><span class="p">[</span><span class="s1">&#39;gridnessMask&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
		<span class="c1"># plot lines from centre to peaks above middle</span>
		<span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">inDict</span><span class="p">[</span><span class="s1">&#39;closestPeaksCoord&#39;</span><span class="p">]:</span>
			<span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">inDict</span><span class="p">[</span><span class="s1">&#39;gridnessMask&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
				<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">((</span><span class="n">inDict</span><span class="p">[</span><span class="s1">&#39;gridnessMask&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]),(</span><span class="n">inDict</span><span class="p">[</span><span class="s1">&#39;gridnessMask&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
		<span class="n">all_ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">axes</span>
		<span class="n">x_ax</span> <span class="o">=</span> <span class="n">all_ax</span><span class="o">.</span><span class="n">get_xaxis</span><span class="p">()</span>
		<span class="n">x_ax</span><span class="o">.</span><span class="n">set_tick_params</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">labelbottom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
							 <span class="n">top</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="n">y_ax</span> <span class="o">=</span> <span class="n">all_ax</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span>
		<span class="n">y_ax</span><span class="o">.</span><span class="n">set_tick_params</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">labelleft</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
							 <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="n">all_ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
		<span class="n">all_ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">((</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">inDict</span><span class="p">[</span><span class="s1">&#39;gridnessMask&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mf">1.5</span><span class="p">))</span>
		<span class="n">all_ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">((</span><span class="n">inDict</span><span class="p">[</span><span class="s1">&#39;gridnessMask&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-.</span><span class="mi">5</span><span class="p">,</span> <span class="o">-.</span><span class="mi">5</span><span class="p">))</span>
		<span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">(),</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yticklabels</span><span class="p">(),</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">get_xaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
		<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
		<span class="k">if</span> <span class="s2">&quot;show_gridscore&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inDict</span><span class="p">[</span><span class="s1">&#39;gridness&#39;</span><span class="p">]),</span> <span class="p">(</span><span class="mf">0.9</span><span class="p">,</span><span class="mf">0.15</span><span class="p">),</span> \
				<span class="n">xycoords</span><span class="o">=</span><span class="s1">&#39;figure fraction&#39;</span><span class="p">,</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;figure fraction&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="SAC.deformSAC"><a class="viewcode-back" href="../../../source/ephysiopy.ephys_generic.html#ephysiopy.ephys_generic.gridcell.SAC.deformSAC">[docs]</a>	<span class="k">def</span> <span class="nf">deformSAC</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">circleXY</span><span class="p">,</span> <span class="n">ellipseXY</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Deforms a SAC that is non-circular to be more circular</span>

<span class="sd">		Basically a blatant attempt to improve grid scores, possibly introduced in</span>
<span class="sd">		a paper by Matt Nolan...</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		A : array_like</span>
<span class="sd">			The SAC</span>
<span class="sd">		circleXY : array_like</span>
<span class="sd">			The xy coordinates defining a circle. See Notes</span>
<span class="sd">		ellipseXY : array_like</span>
<span class="sd">			The xy coordinates defining an ellipse</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		deformed_sac : array_like</span>
<span class="sd">			The SAC deformed to be more circular</span>

<span class="sd">		See Also</span>
<span class="sd">		--------</span>
<span class="sd">		skimage.transform.AffineTransform : for calculation of the affine transform</span>
<span class="sd">		skimage.transform.warp : for performance of the image warping</span>
<span class="sd">		skimage.exposure.rescale_intensity : for rescaling following deformation</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">A</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">A</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">if</span> <span class="n">circleXY</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
			<span class="n">circleXY</span> <span class="o">=</span> <span class="n">circleXY</span><span class="o">.</span><span class="n">T</span>
		<span class="k">if</span> <span class="n">ellipseXY</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
			<span class="n">ellipseXY</span> <span class="o">=</span> <span class="n">ellipseXY</span><span class="o">.</span><span class="n">T</span>
		<span class="n">tform</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">AffineTransform</span><span class="p">()</span>
		<span class="n">tform</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">ellipseXY</span><span class="p">,</span> <span class="n">circleXY</span><span class="p">)</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		the transformation algorithms used here crop values &lt; 0 to 0. Need to</span>
<span class="sd">		rescale the SAC values before doing the deformation and then rescale</span>
<span class="sd">		again so the values assume the same range as in the unadulterated SAC</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">SACmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span><span class="c1">#should be 1</span>
		<span class="n">SACmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
		<span class="n">AA</span> <span class="o">=</span> <span class="n">A</span> <span class="o">+</span> <span class="mi">1</span>
		<span class="n">deformedSAC</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">warp</span><span class="p">(</span><span class="n">AA</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">AA</span><span class="o">.</span><span class="n">flatten</span><span class="p">()),</span> <span class="n">inverse_map</span><span class="o">=</span><span class="n">tform</span><span class="o">.</span><span class="n">inverse</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">skimage</span><span class="o">.</span><span class="n">exposure</span><span class="o">.</span><span class="n">rescale_intensity</span><span class="p">(</span><span class="n">deformedSAC</span><span class="p">,</span> <span class="n">out_range</span><span class="o">=</span><span class="p">(</span><span class="n">SACmin</span><span class="p">,</span><span class="n">SACmax</span><span class="p">))</span></div>

	<span class="k">def</span> <span class="nf">__getcircleXY__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">centre</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Calculates xy coordinate pairs that define a circle</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		centre : array_like</span>
<span class="sd">			The xy coordinate of the centre of the circle</span>
<span class="sd">		radius : int</span>
<span class="sd">			The radius of the circle</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		circ : array_like</span>
<span class="sd">			100 xy coordinate pairs that describe the circle</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">npts</span> <span class="o">=</span> <span class="mi">100</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="o">+</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span> <span class="n">npts</span><span class="p">)</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">npts</span><span class="p">)</span>
		<span class="n">x</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">centre</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">y</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">centre</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span>

	<span class="k">def</span> <span class="nf">__getellipseXY__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ang</span><span class="p">,</span> <span class="n">im_centre</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Calculates xy coordinate pairs that define an ellipse</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		a, b : float</span>
<span class="sd">			The major and minor axes of the ellipse respectively</span>
<span class="sd">		ang : float</span>
<span class="sd">			The angle of orientation of the ellipse</span>
<span class="sd">		im_centre : array_like</span>
<span class="sd">			The xy coordinate of the centre of the ellipse</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		ellipse : array_like</span>
<span class="sd">			100 xy coordinate pairs that describe the ellipse</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">pts</span> <span class="o">=</span> <span class="mi">100</span>
		<span class="n">cos_a</span><span class="p">,</span> <span class="n">sin_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ang</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ang</span><span class="p">)</span>
		<span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">pts</span><span class="p">)</span>
		<span class="n">X</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">cos_a</span> <span class="o">-</span> <span class="n">sin_a</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">+</span> <span class="n">im_centre</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">Y</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">sin_a</span> <span class="o">+</span> <span class="n">cos_a</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">+</span> <span class="n">im_centre</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">))</span>

	<span class="k">def</span> <span class="nf">__fit_ellipse__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Does a best fits of an ellipse to the x/y coordinates provided</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		x, y : array_like</span>
<span class="sd">			The x and y coordinates</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		a : array_like</span>
<span class="sd">			The xy coordinate pairs that fit</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
		<span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
		<span class="n">D</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
		<span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">D</span><span class="p">)</span>
		<span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
		<span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">C</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
		<span class="n">E</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="n">C</span><span class="p">))</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">E</span><span class="p">))</span>
		<span class="n">a</span> <span class="o">=</span> <span class="n">V</span><span class="p">[:,</span><span class="n">n</span><span class="p">]</span>
		<span class="k">return</span> <span class="n">a</span>

	<span class="k">def</span> <span class="nf">__ellipse_center__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Finds the centre of an ellipse</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		a : array_like</span>
<span class="sd">			The values that describe the ellipse; major, minor axes etc</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		xy_centre : array_like</span>
<span class="sd">			The xy coordinates of the centre of the ellipse</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="n">g</span><span class="p">,</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">num</span> <span class="o">=</span> <span class="n">b</span><span class="o">*</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">c</span>
		<span class="n">x0</span><span class="o">=</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">d</span><span class="o">-</span><span class="n">b</span><span class="o">*</span><span class="n">f</span><span class="p">)</span><span class="o">/</span><span class="n">num</span>
		<span class="n">y0</span><span class="o">=</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">f</span><span class="o">-</span><span class="n">b</span><span class="o">*</span><span class="n">d</span><span class="p">)</span><span class="o">/</span><span class="n">num</span>
		<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x0</span><span class="p">,</span><span class="n">y0</span><span class="p">])</span>

	<span class="k">def</span> <span class="nf">__ellipse_angle_of_rotation__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Finds the angle of rotation of an ellipse</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		a : array_like</span>
<span class="sd">			The values that describe the ellipse; major, minor axes etc</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		angle : array_like</span>
<span class="sd">			The angle of rotation of the ellipse</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="n">g</span><span class="p">,</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">b</span><span class="o">/</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">c</span><span class="p">))</span>

	<span class="k">def</span> <span class="nf">__ellipse_axis_length__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Finds the axis length of an ellipse</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		a : array_like</span>
<span class="sd">			The values that describe the ellipse; major, minor axes etc</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		axes_length : array_like</span>
<span class="sd">			The length of the major and minor axes (I think)</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="n">g</span><span class="p">,</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">_up</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">f</span><span class="o">+</span><span class="n">c</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">d</span><span class="o">+</span><span class="n">g</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">b</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">f</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">c</span><span class="o">*</span><span class="n">g</span><span class="p">)</span>
		<span class="n">down1</span><span class="o">=</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">c</span><span class="p">)</span><span class="o">*</span><span class="p">(</span> <span class="p">(</span><span class="n">c</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">b</span><span class="o">/</span><span class="p">((</span><span class="n">a</span><span class="o">-</span><span class="n">c</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">c</span><span class="p">)))</span><span class="o">-</span><span class="p">(</span><span class="n">c</span><span class="o">+</span><span class="n">a</span><span class="p">))</span>
		<span class="n">down2</span><span class="o">=</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">c</span><span class="p">)</span><span class="o">*</span><span class="p">(</span> <span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">c</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">b</span><span class="o">/</span><span class="p">((</span><span class="n">a</span><span class="o">-</span><span class="n">c</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">c</span><span class="p">)))</span><span class="o">-</span><span class="p">(</span><span class="n">c</span><span class="o">+</span><span class="n">a</span><span class="p">))</span>
		<span class="n">res1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">_up</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">down1</span><span class="p">))</span>
		<span class="n">res2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">_up</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">down2</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">res1</span><span class="p">,</span> <span class="n">res2</span><span class="p">])</span>

	<span class="k">def</span> <span class="nf">__findPeakExtent__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">peakID</span><span class="p">,</span> <span class="n">peakCoord</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Finds extent of field that belongs to each peak.</span>
<span class="sd">		</span>
<span class="sd">		The extent is defined as the area that falls under the half-height.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		A : array_like</span>
<span class="sd">			The SAC</span>
<span class="sd">		peakID : array_like</span>
<span class="sd">			I think this is a list of the peak identities i.e. [1, 2, 3 etc]</span>
<span class="sd">		peakCoord : array_like</span>
<span class="sd">			xy coordinates into A that contain the full peaks</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		out : 2-tuple</span>
<span class="sd">			Consisting of the labelled peaks and their labelled perimeters</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">peakLabel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
		<span class="n">perimeterLabel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">peakLabel</span><span class="p">)</span>

		<span class="c1"># define threshold to use - currently this is half-height</span>
		<span class="n">halfHeight</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">peakCoord</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">peakCoord</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="o">.</span><span class="mi">5</span>
		<span class="n">aboveHalfHeightLabel</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">A</span> <span class="o">&gt;</span> <span class="n">halfHeight</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">peakIDTmp</span> <span class="o">=</span> <span class="n">aboveHalfHeightLabel</span><span class="p">[</span><span class="n">peakCoord</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">peakCoord</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
		<span class="n">peakLabel</span><span class="p">[</span><span class="n">aboveHalfHeightLabel</span> <span class="o">==</span> <span class="n">peakIDTmp</span><span class="p">]</span> <span class="o">=</span> <span class="n">peakID</span>
		<span class="n">perimeterLabel</span><span class="p">[</span><span class="n">mahotas</span><span class="o">.</span><span class="n">bwperim</span><span class="p">(</span><span class="n">aboveHalfHeightLabel</span><span class="o">==</span><span class="n">peakIDTmp</span><span class="p">)]</span> <span class="o">=</span> <span class="n">peakID</span>
		<span class="k">return</span> <span class="n">peakLabel</span><span class="p">,</span> <span class="n">perimeterLabel</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Robin Hayman

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>