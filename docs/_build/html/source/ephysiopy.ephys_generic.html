

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ephysiopy.ephys_generic package &mdash; ephysiopy 1.5.75 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> ephysiopy
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="readme.html">Synopsis</a></li>
<li class="toctree-l1"><a class="reference internal" href="readme.html#installation">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="readme.html#code-example">Code Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="readme.html#motivation">Motivation</a></li>
<li class="toctree-l1"><a class="reference internal" href="readme.html#contributors">Contributors</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">ephysiopy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>ephysiopy.ephys_generic package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/source/ephysiopy.ephys_generic.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="ephysiopy-ephys-generic-package">
<h1>ephysiopy.ephys_generic package<a class="headerlink" href="#ephysiopy-ephys-generic-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-ephysiopy.ephys_generic.binning">
<span id="ephysiopy-ephys-generic-binning-module"></span><h2>ephysiopy.ephys_generic.binning module<a class="headerlink" href="#module-ephysiopy.ephys_generic.binning" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="ephysiopy.ephys_generic.binning.RateMap">
<em class="property">class </em><code class="sig-prename descclassname">ephysiopy.ephys_generic.binning.</code><code class="sig-name descname">RateMap</code><span class="sig-paren">(</span><em class="sig-param">xy=None</em>, <em class="sig-param">hdir=None</em>, <em class="sig-param">speed=None</em>, <em class="sig-param">pos_weights=None</em>, <em class="sig-param">ppm=430</em>, <em class="sig-param">xyInCms=False</em>, <em class="sig-param">cmsPerBin=3</em>, <em class="sig-param">smooth_sz=5</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.binning.RateMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Bins up positional data (xy, head direction etc) and produces rate maps
of the relevant kind. This is a generic class meant to be independent of
any particular recording format</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xy</strong> (<em>array_like</em><em>, </em><em>optional</em>) – The xy data, usually given as a 2 x n sample numpy array</p></li>
<li><p><strong>hdir</strong> (<em>array_like</em><em>, </em><em>optional</em>) – The head direction data, usualy a 1 x n sample numpy array</p></li>
<li><p><strong>speed</strong> (<em>array_like</em><em>, </em><em>optional</em>) – Similar to hdir</p></li>
<li><p><strong>pos_weights</strong> (<em>array_like</em><em>, </em><em>optional</em>) – A 1D numpy array n samples long which is used to weight a particular
position sample when binning data. For example, if there were 5 positions
recorded and a cell spiked once in position 2 and 5 times in position 3 and
nothing anywhere else then pos_weights looks like: [0 0 1 5 0]
In the case of binning up position this will be an array of mostly just 1’s
unless there are some positions you want excluded for some reason</p></li>
<li><p><strong>ppm</strong> (<em>int</em><em>, </em><em>optional</em>) – Pixels per metre. Specifies how many camera pixels per metre so this,
in combination with cmsPerBin, will determine how many bins there are
in the rate map</p></li>
<li><p><strong>xyInCms</strong> (<em>bool</em><em>, </em><em>optional</em><em>, </em><em>default False</em>) – Whether the positional data is in cms</p></li>
<li><p><strong>cmsPerBin</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default 3</em>) – How many cms on a side each bin is in a rate map OR the number of degrees
per bin in the case of directional binning</p></li>
<li><p><strong>smooth_sz</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default = 5</em>) – The width of the smoothing kernel for smoothing rate maps</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>There are several instance variables you can set, see below</p>
<dl class="method">
<dt id="ephysiopy.ephys_generic.binning.RateMap.binsize">
<em class="property">property </em><code class="sig-name descname">binsize</code><a class="headerlink" href="#ephysiopy.ephys_generic.binning.RateMap.binsize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.binning.RateMap.blurImage">
<code class="sig-name descname">blurImage</code><span class="sig-paren">(</span><em class="sig-param">im</em>, <em class="sig-param">n</em>, <em class="sig-param">ny=None</em>, <em class="sig-param">ftype='boxcar'</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.binning.RateMap.blurImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Smooths a 2D image by convolving with a filter</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>im</strong> (<em>array_like</em>) – The array to smooth</p></li>
<li><p><strong>ny</strong> (<em>n</em><em>,</em>) – The size of the smoothing kernel</p></li>
<li><p><strong>ftype</strong> (<em>str</em>) – The type of smoothing kernel. Either ‘boxcar’ or ‘gaussian’</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>res</strong> – The smoothed vector with shape the same as im</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.binning.RateMap.cmsPerBin">
<em class="property">property </em><code class="sig-name descname">cmsPerBin</code><a class="headerlink" href="#ephysiopy.ephys_generic.binning.RateMap.cmsPerBin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.binning.RateMap.getMap">
<code class="sig-name descname">getMap</code><span class="sig-paren">(</span><em class="sig-param">spkWeights</em>, <em class="sig-param">varType='xy'</em>, <em class="sig-param">mapType='rate'</em>, <em class="sig-param">smoothing=True</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.binning.RateMap.getMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Bins up the variable type varType and returns a tuple of (rmap, binnedPositionDir) or
(rmap, binnedPostionX, binnedPositionY)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>spkWeights</strong> (<em>array_like</em>) – Shape equal to number of positions samples captured and consists of
position weights. For example, if there were 5 positions
recorded and a cell spiked once in position 2 and 5 times in position 3 and
nothing anywhere else then pos_weights looks like: [0 0 1 5 0]</p></li>
<li><p><strong>varType</strong> (<em>str</em><em>, </em><em>optional</em><em>, </em><em>default 'xy'</em>) – The variable to bin up. Legal values are: ‘xy’, ‘dir’, and ‘speed’</p></li>
<li><p><strong>mapType</strong> (<em>str</em><em>, </em><em>optional</em><em>, </em><em>default 'rate'</em>) – If ‘rate’ then the binned up spikes are divided by varType. Otherwise return
binned up position. Options are ‘rate’ or ‘pos’</p></li>
<li><p><strong>smoothing</strong> (<em>bool</em><em>, </em><em>optional</em><em>, </em><em>default True</em>) – Whether to smooth the data or not</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>binned_data, binned_pos</strong> – This is either a 2-tuple or a 3-tuple depening on whether binned pos
(mapType is ‘pos’) or binned spikes (mapType is ‘rate’) is asked for,
respectively</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.binning.RateMap.inCms">
<em class="property">property </em><code class="sig-name descname">inCms</code><a class="headerlink" href="#ephysiopy.ephys_generic.binning.RateMap.inCms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.binning.RateMap.pixelsPerBin">
<em class="property">property </em><code class="sig-name descname">pixelsPerBin</code><a class="headerlink" href="#ephysiopy.ephys_generic.binning.RateMap.pixelsPerBin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.binning.RateMap.pos_weights">
<em class="property">property </em><code class="sig-name descname">pos_weights</code><a class="headerlink" href="#ephysiopy.ephys_generic.binning.RateMap.pos_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>The ‘weights’ used as an argument to np.histogram* for binning up position
Mostly this is just an array of 1’s equal to the length of the pos
data, but usefully can be adjusted when masking data in the trial
by</p>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.binning.RateMap.ppm">
<em class="property">property </em><code class="sig-name descname">ppm</code><a class="headerlink" href="#ephysiopy.ephys_generic.binning.RateMap.ppm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.binning.RateMap.smooth_sz">
<em class="property">property </em><code class="sig-name descname">smooth_sz</code><a class="headerlink" href="#ephysiopy.ephys_generic.binning.RateMap.smooth_sz" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.binning.RateMap.smoothingType">
<em class="property">property </em><code class="sig-name descname">smoothingType</code><a class="headerlink" href="#ephysiopy.ephys_generic.binning.RateMap.smoothingType" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-ephysiopy.ephys_generic.eegcalcs">
<span id="ephysiopy-ephys-generic-eegcalcs-module"></span><h2>ephysiopy.ephys_generic.eegcalcs module<a class="headerlink" href="#module-ephysiopy.ephys_generic.eegcalcs" title="Permalink to this headline">¶</a></h2>
<p>LFP-type analysis limmited at the moment to Axona file formats I think</p>
<dl class="class">
<dt id="ephysiopy.ephys_generic.eegcalcs.EEGCalcs">
<em class="property">class </em><code class="sig-prename descclassname">ephysiopy.ephys_generic.eegcalcs.</code><code class="sig-name descname">EEGCalcs</code><span class="sig-paren">(</span><em class="sig-param">fname, eegType='eeg', thetaRange=[7, 11], pad2pow=nan, smthKernelWidth=2, smthKernelSigma=0.1875, sn2Width=2, maxFreq=125, ymax=None, xmax=25</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.eegcalcs.EEGCalcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ephysiopy.dacq2py.html#ephysiopy.dacq2py.axonaIO.EEG" title="ephysiopy.dacq2py.axonaIO.EEG"><code class="xref py py-class docutils literal notranslate"><span class="pre">ephysiopy.dacq2py.axonaIO.EEG</span></code></a></p>
<p>Has some useful methods in particularly to do with theta-gamma phase coupling</p>
<dl class="method">
<dt id="ephysiopy.ephys_generic.eegcalcs.EEGCalcs.chisquare_inv">
<code class="sig-name descname">chisquare_inv</code><span class="sig-paren">(</span><em class="sig-param">P</em>, <em class="sig-param">V</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.eegcalcs.EEGCalcs.chisquare_inv" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.eegcalcs.EEGCalcs.chisquare_solve">
<code class="sig-name descname">chisquare_solve</code><span class="sig-paren">(</span><em class="sig-param">XGUESS</em>, <em class="sig-param">P</em>, <em class="sig-param">V</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.eegcalcs.EEGCalcs.chisquare_solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.eegcalcs.EEGCalcs.eeg_instant_freq_power">
<code class="sig-name descname">eeg_instant_freq_power</code><span class="sig-paren">(</span><em class="sig-param">eeg=None</em>, <em class="sig-param">plot=True</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.eegcalcs.EEGCalcs.eeg_instant_freq_power" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.eegcalcs.EEGCalcs.eeg_power_spectra">
<code class="sig-name descname">eeg_power_spectra</code><span class="sig-paren">(</span><em class="sig-param">eeg=None</em>, <em class="sig-param">pos2use='all'</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.eegcalcs.EEGCalcs.eeg_power_spectra" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.eegcalcs.EEGCalcs.filterForLaser">
<code class="sig-name descname">filterForLaser</code><span class="sig-paren">(</span><em class="sig-param">E=None</em>, <em class="sig-param">width=0.125</em>, <em class="sig-param">dip=15.0</em>, <em class="sig-param">stimFreq=6.66</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.eegcalcs.EEGCalcs.filterForLaser" title="Permalink to this definition">¶</a></dt>
<dd><p>In some of the optogenetic experiments I ran the frequency of laser
stimulation was at 6.66Hz - this method attempts to filter those
frequencies out</p>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.eegcalcs.EEGCalcs.filterWithButter">
<code class="sig-name descname">filterWithButter</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">low</em>, <em class="sig-param">high</em>, <em class="sig-param">fs</em>, <em class="sig-param">order=5</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.eegcalcs.EEGCalcs.filterWithButter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.eegcalcs.EEGCalcs.ifftFilter">
<code class="sig-name descname">ifftFilter</code><span class="sig-paren">(</span><em class="sig-param">sig</em>, <em class="sig-param">freqs</em>, <em class="sig-param">fs=250</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.eegcalcs.EEGCalcs.ifftFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the dft of signal and filters out the frequencies in
freqs from the result and reconstructs the original signal using
the inverse fft without those frequencies</p>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.eegcalcs.EEGCalcs.intrinsic_freq_autoCorr">
<code class="sig-name descname">intrinsic_freq_autoCorr</code><span class="sig-paren">(</span><em class="sig-param">spkTimes=None</em>, <em class="sig-param">posMask=None</em>, <em class="sig-param">maxFreq=25</em>, <em class="sig-param">acBinSize=0.002</em>, <em class="sig-param">acWindow=0.5</em>, <em class="sig-param">plot=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.eegcalcs.EEGCalcs.intrinsic_freq_autoCorr" title="Permalink to this definition">¶</a></dt>
<dd><p>Be careful that if you’ve called dacq2py.Tetrode.getSpkTS()
that they are divided by
96000 to get into seconds before using here</p>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.eegcalcs.EEGCalcs.modulationindex">
<code class="sig-name descname">modulationindex</code><span class="sig-paren">(</span><em class="sig-param">eeg=None, nbins=20, forder=2, thetaband=[4, 8], gammaband=[30, 80], plot=True, **kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.eegcalcs.EEGCalcs.modulationindex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.eegcalcs.EEGCalcs.plv">
<code class="sig-name descname">plv</code><span class="sig-paren">(</span><em class="sig-param">eeg=None, forder=2, thetaband=[4, 8], gammaband=[30, 80], plot=True, **kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.eegcalcs.EEGCalcs.plv" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the phase-amplitude coupling (PAC) of nested oscillations. More
specifically this is the phase-locking value (PLV) between two nested
oscillations in EEG data, in this case theta (default between 4-8Hz)
and gamma (defaults to 30-80Hz). A PLV of unity indicates perfect phase
locking (here PAC) and a value of zero indicates no locking (no PAC)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eeg</strong> (<em>numpy array</em>) – the eeg data itself. This is a 1-d array which can be masked or not</p></li>
<li><p><strong>forder</strong> (<em>int</em>) – the order of the filter(s) applied to the eeg data</p></li>
<li><p><strong>gammaband</strong> (<em>thetaband/</em>) – the range of values to bandpass filter for for the theta and gamma
ranges</p></li>
<li><p><strong>plot</strong> (<em>bool</em><em> (</em><em>default True</em><em>)</em>) – whether to plot the resulting binned up polar plot which shows the
amplitude of the gamma oscillation found at different phases of the
theta oscillation</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>plv</strong> – the value of the phase-amplitude coupling</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.eegcalcs.EEGCalcs.power_spectrum">
<code class="sig-name descname">power_spectrum</code><span class="sig-paren">(</span><em class="sig-param">eeg=None</em>, <em class="sig-param">plot=True</em>, <em class="sig-param">binWidthSecs=None</em>, <em class="sig-param">maxFreq=None</em>, <em class="sig-param">pad2pow=None</em>, <em class="sig-param">ymax=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.eegcalcs.EEGCalcs.power_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Method used by eeg_power_spectra and intrinsic_freq_autoCorr
Signal in must be mean normalised already</p>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.eegcalcs.EEGCalcs.wave_bases">
<code class="sig-name descname">wave_bases</code><span class="sig-paren">(</span><em class="sig-param">mother</em>, <em class="sig-param">k</em>, <em class="sig-param">scale</em>, <em class="sig-param">param</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.eegcalcs.EEGCalcs.wave_bases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.eegcalcs.EEGCalcs.wave_signif">
<code class="sig-name descname">wave_signif</code><span class="sig-paren">(</span><em class="sig-param">Y</em>, <em class="sig-param">dt</em>, <em class="sig-param">scale</em>, <em class="sig-param">sigtest=-1</em>, <em class="sig-param">lag1=-1</em>, <em class="sig-param">siglvl=-1</em>, <em class="sig-param">dof=-1</em>, <em class="sig-param">mother=-1</em>, <em class="sig-param">param=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.eegcalcs.EEGCalcs.wave_signif" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.eegcalcs.EEGCalcs.wavelet">
<code class="sig-name descname">wavelet</code><span class="sig-paren">(</span><em class="sig-param">Y</em>, <em class="sig-param">dt</em>, <em class="sig-param">pad=0</em>, <em class="sig-param">dj=-1</em>, <em class="sig-param">s0=-1</em>, <em class="sig-param">J1=-1</em>, <em class="sig-param">mother=-1</em>, <em class="sig-param">param=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.eegcalcs.EEGCalcs.wavelet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-ephysiopy.ephys_generic.ephys_generic">
<span id="ephysiopy-ephys-generic-ephys-generic-module"></span><h2>ephysiopy.ephys_generic.ephys_generic module<a class="headerlink" href="#module-ephysiopy.ephys_generic.ephys_generic" title="Permalink to this headline">¶</a></h2>
<p>The classes contained in this module are supposed to be agnostic to recording format
and encapsulate some generic mechanisms for producing things like spike timing
autocorrelograms, power spectrum calculation and so on</p>
<dl class="class">
<dt id="ephysiopy.ephys_generic.ephys_generic.EEGCalcsGeneric">
<em class="property">class </em><code class="sig-prename descclassname">ephysiopy.ephys_generic.ephys_generic.</code><code class="sig-name descname">EEGCalcsGeneric</code><span class="sig-paren">(</span><em class="sig-param">sig</em>, <em class="sig-param">fs</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.EEGCalcsGeneric" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Generic class for processing and analysis of EEG data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sig</strong> (<em>array_like</em>) – The signal (of the LFP data)</p></li>
<li><p><strong>fs</strong> (<em>float</em>) – The sample rate</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.EEGCalcsGeneric.butterFilter">
<code class="sig-name descname">butterFilter</code><span class="sig-paren">(</span><em class="sig-param">low: float</em>, <em class="sig-param">high: float</em>, <em class="sig-param">order: int = 5</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray<a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.EEGCalcsGeneric.butterFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Filters self.sig with a butterworth filter with a bandpass filter
defined by low and high</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>high</strong> (<em>low</em><em>,</em>) – The lower and upper bounds of the bandpass filter</p></li>
<li><p><strong>order</strong> (<em>int</em>) – The order of the filter</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>filt</strong> – The filtered signal</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The signal is filtered in both the forward and reverse directions (scipy.signal.filtfilt)</p>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.EEGCalcsGeneric.calcEEGPowerSpectrum">
<code class="sig-name descname">calcEEGPowerSpectrum</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.EEGCalcsGeneric.calcEEGPowerSpectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the power spectrum of self.sig</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>None</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>freqs<span class="classifier">array_like</span></dt><dd><p>The frequencies at which the spectrogram was calculated</p>
</dd>
<dt>power<span class="classifier">array_like</span></dt><dd><p>The power at the frequencies defined above</p>
</dd>
<dt>sm_power<span class="classifier">array_like</span></dt><dd><p>The smoothed power</p>
</dd>
<dt>bandmaxpower<span class="classifier">float</span></dt><dd><p>The maximum power in the theta band</p>
</dd>
<dt>freqatbandmaxpower<span class="classifier">float</span></dt><dd><p>The frequency at which the power is maximum</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Nothing. Sets a bunch of instance variables for the first time including</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.EEGCalcsGeneric.plotEventEEG">
<code class="sig-name descname">plotEventEEG</code><span class="sig-paren">(</span><em class="sig-param">event_ts</em>, <em class="sig-param">event_window=(-0.05</em>, <em class="sig-param">0.1)</em>, <em class="sig-param">stim_width=0.01</em>, <em class="sig-param">sample_rate=30000.0</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.EEGCalcsGeneric.plotEventEEG" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the mean eeg +- std. dev centred on event timestamps</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>event_ts</strong> (<em>array_like</em>) – The event timestamps in seconds</p></li>
<li><p><strong>event_window</strong> (<em>2-tuple</em><em>, </em><em>default =</em><em> (</em><em>-0.05</em><em>, </em><em>0.1</em><em>)</em>) – The pre- and post-stimulus window to examine. In seconds.
Defaults to the previous 50ms and the subsequent 100ms</p></li>
<li><p><strong>stim_width</strong> (<em>float</em>) – The duration of the stimulus. Used for plotting</p></li>
<li><p><strong>sample_rate</strong> (<em>float</em>) – The sample rate of the events</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.EEGCalcsGeneric.plotPowerSpectrum">
<code class="sig-name descname">plotPowerSpectrum</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.EEGCalcsGeneric.plotPowerSpectrum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ephysiopy.ephys_generic.ephys_generic.FieldCalcs">
<em class="property">class </em><code class="sig-prename descclassname">ephysiopy.ephys_generic.ephys_generic.</code><code class="sig-name descname">FieldCalcs</code><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.FieldCalcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This class differs from MapCalcsGeneric in that this one is mostly concerned with
treating rate maps as images as opposed to using the spiking information contained
within them. It therefore mostly deals with spatial rate maps of place and grid cells.</p>
<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.FieldCalcs.calc_angs">
<code class="sig-name descname">calc_angs</code><span class="sig-paren">(</span><em class="sig-param">points</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.FieldCalcs.calc_angs" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the angles for all triangles in a delaunay tesselation of
the peak points in the ratemap</p>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.FieldCalcs.coherence">
<code class="sig-name descname">coherence</code><span class="sig-paren">(</span><em class="sig-param">smthd_rate</em>, <em class="sig-param">unsmthd_rate</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.FieldCalcs.coherence" title="Permalink to this definition">¶</a></dt>
<dd><p>calculates coherence of receptive field via correlation of smoothed
and unsmoothed ratemaps</p>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.FieldCalcs.corr_maps">
<code class="sig-name descname">corr_maps</code><span class="sig-paren">(</span><em class="sig-param">map1</em>, <em class="sig-param">map2</em>, <em class="sig-param">maptype='normal'</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.FieldCalcs.corr_maps" title="Permalink to this definition">¶</a></dt>
<dd><p>correlates two ratemaps together ignoring areas that have zero sampling</p>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.FieldCalcs.getBorderScore">
<code class="sig-name descname">getBorderScore</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">B=None</em>, <em class="sig-param">shape='square'</em>, <em class="sig-param">fieldThresh=0.3</em>, <em class="sig-param">smthKernSig=3</em>, <em class="sig-param">circumPrc=0.2</em>, <em class="sig-param">binSize=3.0</em>, <em class="sig-param">minArea=200</em>, <em class="sig-param">debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.FieldCalcs.getBorderScore" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates a border score totally dis-similar to that calculated in Solstad et al
(2008)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>array_like</em>) – Should be the ratemap</p></li>
<li><p><strong>B</strong> (<em>array_like</em>) – This should be a boolean mask where True (1)
is equivalent to the presence of a border and False (0)
is equivalent to ‘open space’. Naievely this will be the
edges of the ratemap but could be used to take account of
boundary insertions/ creations to check tuning to multiple
environmental boundaries. Default None: when the mask is
None then a mask is created that has 1’s at the edges of the
ratemap i.e. it is assumed that occupancy = environmental
shape</p></li>
<li><p><strong>shape</strong> (<em>str</em>) – description of environment shape. Currently
only ‘square’ or ‘circle’ accepted. Used to calculate the
proportion of the environmental boundaries to examine for
firing</p></li>
<li><p><strong>fieldThresh</strong> (<em>float</em>) – Between 0 and 1 this is the percentage
amount of the maximum firing rate
to remove from the ratemap (i.e. to remove noise)</p></li>
<li><p><strong>smthKernSig</strong> (<em>float</em>) – the sigma value used in smoothing the ratemap
(again!) with a gaussian kernel</p></li>
<li><p><strong>circumPrc</strong> (<em>float</em>) – The percentage amount of the circumference
of the environment that the field needs to be to count
as long enough to make it through</p></li>
<li><p><strong>binSize</strong> (<em>float</em>) – bin size in cm</p></li>
<li><p><strong>minArea</strong> (<em>float</em>) – min area for a field to be considered</p></li>
<li><p><strong>debug</strong> (<em>bool</em>) – If True then some plots and text will be output</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>float</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>the border score</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If the cell is a border cell (BVC) then we know that it should
fire at a fixed distance from a given boundary (possibly more
than one). In essence this algorithm estimates the amount of
variance in this distance i.e. if the cell is a border cell this
number should be small. This is achieved by first doing a bunch of
morphological operations to isolate individual fields in the
ratemap (similar to the code used in phasePrecession.py - see
the partitionFields method therein). These partitioned fields are then
thinned out (using skimage’s skeletonize) to a single pixel
wide field which will lie more or less in the middle of the
(highly smoothed) sub-field. It is the variance in distance from the
nearest boundary along this pseudo-iso-line that is the boundary measure</p>
<p>Other things to note are that the pixel-wide field has to have some minimum
length. In the case of a circular environment this is set to
20% of the circumference; in the case of a square environment markers
this is at least half the length of the longest side</p>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.FieldCalcs.get_field_props">
<code class="sig-name descname">get_field_props</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">min_dist=5</em>, <em class="sig-param">neighbours=2</em>, <em class="sig-param">prc=50</em>, <em class="sig-param">plot=False</em>, <em class="sig-param">ax=None</em>, <em class="sig-param">tri=False</em>, <em class="sig-param">verbose=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.FieldCalcs.get_field_props" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dictionary of properties of the field(s) in a ratemap A</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>array_like</em>) – a ratemap (but could be any image)</p></li>
<li><p><strong>min_dist</strong> (<em>float</em>) – the separation (in bins) between fields for measures
such as field distance to make sense. Used to
partition the image into separate fields in the call to
skimage.feature.peak_local_max</p></li>
<li><p><strong>neighbours</strong> (<em>int</em>) – the number of fields to consider as neighbours to
any given field. Defaults to 2</p></li>
<li><p><strong>prc</strong> (<em>float</em>) – percent of fields to consider</p></li>
<li><p><strong>ax</strong> (<em>matplotlib.Axes</em>) – user supplied axis. If None a new figure window is created</p></li>
<li><p><strong>tri</strong> (<em>bool</em>) – whether to do Delaunay triangulation between fields
and add to plot</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – dumps the properties to the console</p></li>
<li><p><strong>plot</strong> (<em>bool</em>) – whether to plot some output - currently consists of the
ratemap A, the fields of which are outline in a black
contour. Default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The properties of the field(s) in the input ratemap A</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.FieldCalcs.global_threshold">
<code class="sig-name descname">global_threshold</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">prc=50</em>, <em class="sig-param">min_dist=5</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.FieldCalcs.global_threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Globally thresholds a ratemap and counts number of fields found</p>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.FieldCalcs.kldiv">
<code class="sig-name descname">kldiv</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">pvect1</em>, <em class="sig-param">pvect2</em>, <em class="sig-param">variant=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.FieldCalcs.kldiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the Kullback-Leibler or Jensen-Shannon divergence between two distributions.</p>
<p>kldiv(X,P1,P2) returns the Kullback-Leibler divergence between two
distributions specified over the M variable values in vector X.  P1 is a
length-M vector of probabilities representing distribution 1, and P2 is a
length-M vector of probabilities representing distribution 2.  Thus, the
probability of value X(i) is P1(i) for distribution 1 and P2(i) for
distribution 2.  The Kullback-Leibler divergence is given by:</p>
<div class="math notranslate nohighlight">
\[KL(P1(x),P2(x)) = sum_[P1(x).log(P1(x)/P2(x))]\]</div>
<p>If X contains duplicate values, there will be an warning message, and these
values will be treated as distinct values.  (I.e., the actual values do
not enter into the computation, but the probabilities for the two
duplicate values will be considered as probabilities corresponding to
two unique values.)  The elements of probability vectors P1 and P2 must
each sum to 1 +/- .00001.</p>
<p>kldiv(X,P1,P2,’sym’) returns a symmetric variant of the Kullback-Leibler
divergence, given by [KL(P1,P2)+KL(P2,P1)]/2</p>
<p>kldiv(X,P1,P2,’js’) returns the Jensen-Shannon divergence, given by
[KL(P1,Q)+KL(P2,Q)]/2, where Q = (P1+P2)/2.  See the Wikipedia article
for “Kullback–Leibler divergence”.  This is equal to 1/2 the so-called
“Jeffrey divergence.”</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Cover, T.M. and J.A. Thomas. “Elements of Information Theory,” Wiley, 1991.</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence">https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence</a></p>
</div>
<p class="rubric">Notes</p>
<p>This function is taken from one on the Mathworks file exchange</p>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.FieldCalcs.kldiv_dir">
<code class="sig-name descname">kldiv_dir</code><span class="sig-paren">(</span><em class="sig-param">polarPlot</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.FieldCalcs.kldiv_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a kl divergence for directional firing: measure of directionality.
Calculates kl diveregence between a smoothed ratemap (probably should be smoothed
otherwise information theoretic measures don’t ‘care’ about position of bins relative to
one another) and a pure circular distribution. The larger the divergence the more
tendancy the cell has to fire when the animal faces a specific direction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>polarPlot</strong> (<em>1D-array</em>) – The binned and smoothed directional ratemap</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>klDivergence</strong> – The divergence from circular of the 1D-array from a uniform circular
distribution</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.FieldCalcs.limit_to_one">
<code class="sig-name descname">limit_to_one</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">prc=50</em>, <em class="sig-param">min_dist=5</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.FieldCalcs.limit_to_one" title="Permalink to this definition">¶</a></dt>
<dd><p>Processes a multi-peaked ratemap (ie grid cell) and returns a matrix
where the multi-peaked ratemap consist of a single peaked field that is
a) not connected to the border and b) close to the middle of the ratemap</p>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.FieldCalcs.local_threshold">
<code class="sig-name descname">local_threshold</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">prc=50</em>, <em class="sig-param">min_dist=5</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.FieldCalcs.local_threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Locally thresholds a ratemap to take only the surrounding prc amount
around any local peak</p>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.FieldCalcs.skaggsInfo">
<code class="sig-name descname">skaggsInfo</code><span class="sig-paren">(</span><em class="sig-param">ratemap</em>, <em class="sig-param">dwelltimes</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.FieldCalcs.skaggsInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates Skaggs information measure</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ratemap</strong> (<em>array_like</em>) – The binned up ratemap</p></li>
<li><p><strong>dwelltimes</strong> (<em>array_like</em>) – Must be same size as ratemap</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>bits_per_spike</strong> – Skaggs information score</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>THIS DATA SHOULD UNDERGO ADAPTIVE BINNING - See adaptiveBin in binning class above</p>
<p>Returns Skaggs et al’s estimate of spatial information in bits per spike:</p>
<div class="math notranslate nohighlight">
\[I = sum_{x} p(x).r(x).log(r(x)/r)\]</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric">
<em class="property">class </em><code class="sig-prename descclassname">ephysiopy.ephys_generic.ephys_generic.</code><code class="sig-name descname">MapCalcsGeneric</code><span class="sig-paren">(</span><em class="sig-param">xy</em>, <em class="sig-param">hdir</em>, <em class="sig-param">speed</em>, <em class="sig-param">pos_ts</em>, <em class="sig-param">spk_ts</em>, <em class="sig-param">plot_type='map'</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Produces graphical output including but not limited to spatial
analysis of data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xy</strong> (<em>array_like</em>) – The positional data usually as a 2D numpy array</p></li>
<li><p><strong>hdir</strong> (<em>array_like</em>) – The head direction data usually a 1D numpy array</p></li>
<li><p><strong>pos_ts</strong> (<em>array_like</em>) – 1D array of timestamps in seconds</p></li>
<li><p><strong>spk_ts</strong> (<em>array_like</em>) – 1D array of timestamps in seconds</p></li>
<li><p><strong>plot_type</strong> (<em>str</em><em> or </em><em>list</em>) – Determines the plots produced. Legal values:
[‘map’,’path’,’hdir’,’sac’, ‘speed’]</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Output possible:
* ratemaps (xy)
* polar plots (heading direction)
* grid cell spatial autocorrelograms
* speed vs rate plots</p>
<p>It is possible to iterate through instances of this class as it has a yield
method defined</p>
<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.good_clusters">
<em class="property">property </em><code class="sig-name descname">good_clusters</code><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.good_clusters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.makeHDPlot">
<code class="sig-name descname">makeHDPlot</code><span class="sig-paren">(</span><em class="sig-param">cluster</em>, <em class="sig-param">ax</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.makeHDPlot" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.makeRateMap">
<code class="sig-name descname">makeRateMap</code><span class="sig-paren">(</span><em class="sig-param">cluster</em>, <em class="sig-param">ax=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.makeRateMap" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.makeSpeedVsHeadDirectionPlot">
<code class="sig-name descname">makeSpeedVsHeadDirectionPlot</code><span class="sig-paren">(</span><em class="sig-param">cluster</em>, <em class="sig-param">ax</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.makeSpeedVsHeadDirectionPlot" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.makeSpeedVsRatePlot">
<code class="sig-name descname">makeSpeedVsRatePlot</code><span class="sig-paren">(</span><em class="sig-param">cluster</em>, <em class="sig-param">minSpeed=0.0</em>, <em class="sig-param">maxSpeed=40.0</em>, <em class="sig-param">sigma=3.0</em>, <em class="sig-param">ax=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.makeSpeedVsRatePlot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the instantaneous firing rate of a cell against running speed
Also outputs a couple of measures as with Kropff et al., 2015; the
Pearsons correlation and the depth of modulation (dom) - see below for
details</p>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.makeSpikePathPlot">
<code class="sig-name descname">makeSpikePathPlot</code><span class="sig-paren">(</span><em class="sig-param">cluster</em>, <em class="sig-param">ax</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.makeSpikePathPlot" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.plotAll">
<code class="sig-name descname">plotAll</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.plotAll" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots rate maps and other graphical output</p>
<p class="rubric">Notes</p>
<p>This method uses the data provided to the class instance to plot
various maps into a single figure window for each cluster. The things
to plot are given in self.plot_type and the list of clusters in self.good_clusters</p>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.ppm">
<em class="property">property </em><code class="sig-name descname">ppm</code><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.ppm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.spk_clusters">
<em class="property">property </em><code class="sig-name descname">spk_clusters</code><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.spk_clusters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric">
<em class="property">class </em><code class="sig-prename descclassname">ephysiopy.ephys_generic.ephys_generic.</code><code class="sig-name descname">PosCalcsGeneric</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">y</em>, <em class="sig-param">ppm</em>, <em class="sig-param">cm=True</em>, <em class="sig-param">jumpmax=100</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Generic class for post-processing of position data
Uses numpys masked arrays for dealing with bad positions, filtering etc</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y</strong> (<em>x</em><em>,</em>) – The x and y positions.</p></li>
<li><p><strong>ppm</strong> (<em>int</em>) – Pixels per metre</p></li>
<li><p><strong>cm</strong> (<em>boolean</em>) – Whether everything is converted into cms or not</p></li>
<li><p><strong>jumpmax</strong> (<em>int</em>) – Jumps in position (pixel coords) greater than this are bad</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The positional data (x,y) is turned into a numpy masked array once this
class is initialised - that mask is then modified through various
functions (postprocesspos being the main one).</p>
<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.calcSpeed">
<code class="sig-name descname">calcSpeed</code><span class="sig-paren">(</span><em class="sig-param">xy</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.calcSpeed" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates speed</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>xy</strong> (<em>np.ma.MaskedArray</em>) – The xy positional data</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Nothing. Sets self.speed</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.interpnans">
<code class="sig-name descname">interpnans</code><span class="sig-paren">(</span><em class="sig-param">xy</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.interpnans" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.postprocesspos">
<code class="sig-name descname">postprocesspos</code><span class="sig-paren">(</span><em class="sig-param">tracker_params</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span> &#x2192; tuple<a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.postprocesspos" title="Permalink to this definition">¶</a></dt>
<dd><p>Post-process position data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>tracker_params</strong> (<em>dict</em>) – Same dict as created in OEKiloPhy.Settings.parsePos
(from module openephys2py)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>xy, hdir</strong> – The post-processed position data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ma.MaskedArray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Several internal functions are called here: speefilter, interpnans, smoothPos
and calcSpeed. Some internal state/ instance variables are set as well. The
mask of the positional data (an instance of numpy masked array) is modified
throughout this method.</p>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.smoothPos">
<code class="sig-name descname">smoothPos</code><span class="sig-paren">(</span><em class="sig-param">xy</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.smoothPos" title="Permalink to this definition">¶</a></dt>
<dd><p>Smooths position data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>xy</strong> (<em>np.ma.MaskedArray</em>) – The xy data</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>xy</strong> – The smoothed positional data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.speedfilter">
<code class="sig-name descname">speedfilter</code><span class="sig-paren">(</span><em class="sig-param">xy</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.speedfilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Filters speed</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>xy</strong> (<em>np.ma.MaskedArray</em>) – The xy data</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>xy</strong> – The xy data with speeds &gt; self.jumpmax masked</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ma.MaskedArray</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.upsamplePos">
<code class="sig-name descname">upsamplePos</code><span class="sig-paren">(</span><em class="sig-param">xy</em>, <em class="sig-param">upsample_rate=50</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.upsamplePos" title="Permalink to this definition">¶</a></dt>
<dd><p>Upsamples position data from 30 to upsample_rate</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xy</strong> (<em>np.ma.MaskedArray</em>) – The xy positional data</p></li>
<li><p><strong>upsample_rate</strong> (<em>int</em>) – The rate to upsample to</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>new_xy</strong> – The upsampled xy positional data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ma.MaskedArray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This is mostly to get pos data recorded using PosTracker at 30Hz
into Axona format 50Hz data</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric">
<em class="property">class </em><code class="sig-prename descclassname">ephysiopy.ephys_generic.ephys_generic.</code><code class="sig-name descname">SpikeCalcsGeneric</code><span class="sig-paren">(</span><em class="sig-param">spike_times</em>, <em class="sig-param">waveforms=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Deals with the processing and analysis of spike timing data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>spike_times</strong> (<em>array_like</em>) – the times of ‘spikes’ in the trial
this should be all spikes as the cluster identity vector _spk_clusters
is used to pick out the right spikes</p></li>
<li><p><strong>waveforms</strong> (<em>np.array</em><em>, </em><em>optional</em>) – not sure on shape yet but will be something like a
a 4 x nSpikes x nSamples (4 for tetrode-based analysis)</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Units for time are provided as per the sample rate but converted internally to milliseconds</p>
<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.calculatePSTH">
<code class="sig-name descname">calculatePSTH</code><span class="sig-paren">(</span><em class="sig-param">cluster_id</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.calculatePSTH" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the PSTH of event_ts against the spiking of a cell</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>cluster_id</strong> (<em>int</em>) – The cluster for which to calculate the psth</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>x, y</strong> – The list of time differences between the spikes of the cluster
and the events (x) and the trials (y)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.duration">
<em class="property">property </em><code class="sig-name descname">duration</code><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.duration" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.event_ts">
<em class="property">property </em><code class="sig-name descname">event_ts</code><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.event_ts" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.event_window">
<em class="property">property </em><code class="sig-name descname">event_window</code><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.event_window" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.mean_isi_range">
<code class="sig-name descname">mean_isi_range</code><span class="sig-paren">(</span><em class="sig-param">cluster: int</em>, <em class="sig-param">n: int</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.mean_isi_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the mean of the autocorrelation from 0 to n milliseconds
Used to help classify a neruons type (principal, interneuron etc)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cluster</strong> (<em>int</em>) – The cluster to analyse</p></li>
<li><p><strong>n</strong> (<em>int</em>) – The range in milliseconds to calculate the mean over</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mean_isi_range</strong> – The mean of the autocorrelogram between 0 and n milliseconds</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.n_spikes">
<code class="sig-name descname">n_spikes</code><span class="sig-paren">(</span><em class="sig-param">cluster=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.n_spikes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.plotAllXCorrs">
<code class="sig-name descname">plotAllXCorrs</code><span class="sig-paren">(</span><em class="sig-param">clusters</em>, <em class="sig-param">fig=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.plotAllXCorrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots all xcorrs in a single figure window</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>clusters</strong> (<em>list</em>) – The clusters to plot</p></li>
<li><p><strong>fig</strong> (<em>matplotlib.figure instance</em><em>, </em><em>optional</em><em>, </em><em>default None</em>) – If provided the figure will contain all the axes</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.plotPSTH">
<code class="sig-name descname">plotPSTH</code><span class="sig-paren">(</span><em class="sig-param">cluster</em>, <em class="sig-param">fig=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.plotPSTH" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the PSTH for a cluster</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>cluster</strong> (<em>int</em>) – The cluster to examine</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>cluster, i</strong> – The cluster and a junk variable (not sure why for now)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.sample_rate">
<em class="property">property </em><code class="sig-name descname">sample_rate</code><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.sample_rate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.spk_clusters">
<em class="property">property </em><code class="sig-name descname">spk_clusters</code><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.spk_clusters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.stim_width">
<em class="property">property </em><code class="sig-name descname">stim_width</code><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.stim_width" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.trial_mean_fr">
<code class="sig-name descname">trial_mean_fr</code><span class="sig-paren">(</span><em class="sig-param">cluster: int</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.trial_mean_fr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.xcorr">
<code class="sig-name descname">xcorr</code><span class="sig-paren">(</span><em class="sig-param">x1: numpy.ndarray</em>, <em class="sig-param">x2=None</em>, <em class="sig-param">Trange=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray<a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.xcorr" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the histogram of the ISIs in x1 or x1 vs x2</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x2</strong> (<em>x1</em><em>,</em>) – The times of the spikes emitted by the cluster(s)
NB must be signed int to accomodate negative times</p></li>
<li><p><strong>Trange</strong> (<em>array_like</em>) – Range of times to bin up. Defaults to [-500, +500] in ms</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong> – The time differences between spike times in x1 over the range
of times defined Trange</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsProbe">
<em class="property">class </em><code class="sig-prename descclassname">ephysiopy.ephys_generic.ephys_generic.</code><code class="sig-name descname">SpikeCalcsProbe</code><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsProbe" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric" title="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric"><code class="xref py py-class docutils literal notranslate"><span class="pre">ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric</span></code></a></p>
<p>Encapsulates methods specific to probe-based recordings</p>
</dd></dl>

<dl class="class">
<dt id="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsTetrode">
<em class="property">class </em><code class="sig-prename descclassname">ephysiopy.ephys_generic.ephys_generic.</code><code class="sig-name descname">SpikeCalcsTetrode</code><a class="headerlink" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsTetrode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric" title="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric"><code class="xref py py-class docutils literal notranslate"><span class="pre">ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric</span></code></a></p>
<p>Encapsulates methods specific to the geometry inherent in tetrode-based
recordings</p>
</dd></dl>

</div>
<div class="section" id="module-ephysiopy.ephys_generic.gridcell">
<span id="ephysiopy-ephys-generic-gridcell-module"></span><h2>ephysiopy.ephys_generic.gridcell module<a class="headerlink" href="#module-ephysiopy.ephys_generic.gridcell" title="Permalink to this headline">¶</a></h2>
<p>Calculation of the various metrics for quantifying the behaviour of grid cells
and some graphical output etc</p>
<dl class="class">
<dt id="ephysiopy.ephys_generic.gridcell.SAC">
<em class="property">class </em><code class="sig-prename descclassname">ephysiopy.ephys_generic.gridcell.</code><code class="sig-name descname">SAC</code><a class="headerlink" href="#ephysiopy.ephys_generic.gridcell.SAC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Spatial AutoCorrelation (SAC) class</p>
<dl class="method">
<dt id="ephysiopy.ephys_generic.gridcell.SAC.autoCorr2D">
<code class="sig-name descname">autoCorr2D</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">nodwell</em>, <em class="sig-param">tol=1e-10</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.gridcell.SAC.autoCorr2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a spatial autocorrelation on the array A</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>array_like</em>) – Either 2 or 3D. In the former it is simply the binned up ratemap
where the two dimensions correspond to x and y.
If 3D then the first two dimensions are x
and y and the third (last dimension) is ‘stack’ of ratemaps</p></li>
<li><p><strong>nodwell</strong> (<em>array_like</em>) – A boolean array corresponding the bins in the ratemap that
weren’t visited. See Notes below.</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Values below this are set to zero to deal with v small values
thrown up by the fft. Default 1e-10</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>sac</strong> – The spatial autocorrelation in the relevant dimensionality</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The nodwell input can usually be generated by:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nodwell</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.gridcell.SAC.crossCorr2D">
<code class="sig-name descname">crossCorr2D</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">B</em>, <em class="sig-param">A_nodwell</em>, <em class="sig-param">B_nodwell</em>, <em class="sig-param">tol=1e-10</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.gridcell.SAC.crossCorr2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a spatial crosscorrelation between the arrays A and B</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>B</strong> (<em>A</em><em>,</em>) – Either 2 or 3D. In the former it is simply the binned up ratemap
where the two dimensions correspond to x and y.
If 3D then the first two dimensions are x
and y and the third (last dimension) is ‘stack’ of ratemaps</p></li>
<li><p><strong>nodwell_B</strong> (<em>nodwell_A</em><em>,</em>) – A boolean array corresponding the bins in the ratemap that
weren’t visited. See Notes below.</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Values below this are set to zero to deal with v small values
thrown up by the fft. Default 1e-10</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>sac</strong> – The spatial crosscorrelation in the relevant dimensionality</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The nodwell input can usually be generated by:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nodwell</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.gridcell.SAC.deformSAC">
<code class="sig-name descname">deformSAC</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">circleXY</em>, <em class="sig-param">ellipseXY</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.gridcell.SAC.deformSAC" title="Permalink to this definition">¶</a></dt>
<dd><p>Deforms a SAC that is non-circular to be more circular</p>
<p>Basically a blatant attempt to improve grid scores, possibly introduced in
a paper by Matt Nolan…</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>array_like</em>) – The SAC</p></li>
<li><p><strong>circleXY</strong> (<em>array_like</em>) – The xy coordinates defining a circle. See Notes</p></li>
<li><p><strong>ellipseXY</strong> (<em>array_like</em>) – The xy coordinates defining an ellipse</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>deformed_sac</strong> – The SAC deformed to be more circular</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-meth docutils literal notranslate"><span class="pre">skimage.transform.AffineTransform()</span></code></dt><dd><p>for calculation of the affine transform</p>
</dd>
<dt><code class="xref py py-meth docutils literal notranslate"><span class="pre">skimage.transform.warp()</span></code></dt><dd><p>for performance of the image warping</p>
</dd>
<dt><code class="xref py py-meth docutils literal notranslate"><span class="pre">skimage.exposure.rescale_intensity()</span></code></dt><dd><p>for rescaling following deformation</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.gridcell.SAC.getMeasures">
<code class="sig-name descname">getMeasures</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">maxima='centroid'</em>, <em class="sig-param">field_extent_method=2</em>, <em class="sig-param">allProps=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.gridcell.SAC.getMeasures" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts various measures from a spatial autocorrelogram</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>array_like</em>) – The spatial autocorrelogram (SAC)</p></li>
<li><p><strong>maxima</strong> (<em>str</em><em>, </em><em>optional</em>) – The method used to detect the peaks in the SAC.
Legal values are ‘single’ and ‘centroid’. Default ‘centroid’</p></li>
<li><p><strong>field_extent_method</strong> (<em>int</em><em>, </em><em>optional</em>) – The method used to delimit the regions of interest in the SAC
Legal values:
* 1 - uses the half height of the ROI peak to limit field extent
* 2 - uses a watershed method to limit field extent
Default 2</p></li>
<li><p><strong>allProps</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to return a dictionary that contains the attempt to fit an
ellipse around the edges of the central size peaks. See below
Default True</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>props</strong> – A dictionary containing measures of the SAC. The keys include things like:
* gridness score
* scale
* orientation
* the coordinates of the peaks (nominally 6) closest to the centre of the SAC
* a binary mask that defines the extent of the 6 central fields around the centre
* values of the rotation procedure used to calculate the gridness score
* ellipse axes and angle (if allProps is True and the procedure worked)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The output from this method can be used as input to the show() method of this class.
When it is the plot produced will be a lot more informative.</p>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.gridcell.SAC.getgridness">
<code class="sig-name descname">getgridness</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">step=30</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.gridcell.SAC.getgridness" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the gridness score in a grid cell spatial autocorrelogram (SAC).</p>
<p>Briefly, the data in <cite>image</cite> is rotated in <cite>step</cite> amounts and each rotated array
is correlated with the original. The maximum of the values at 30, 90 and 150 degrees
is the subtracted from the minimum of the values at 60, 120 and 180 degrees to give the
grid score.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>array_like</em>) – The spatial autocorrelogram</p></li>
<li><p><strong>step</strong> (<em>int</em><em>, </em><em>optional</em>) – The amount to rotate the SAC by in each step of the rotational correlation
procedure</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>gridmeasures</strong> – The gridscore, the correlation values at each <cite>step</cite> and the rotational array</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>3-tuple</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The correlation performed is a Pearsons R. Some rescaling of the values in <cite>image</cite> is
performed following rotation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-meth docutils literal notranslate"><span class="pre">skimage.transform.rotate()</span></code></dt><dd><p>for how the rotation of <cite>image</cite> is done</p>
</dd>
<dt><code class="xref py py-meth docutils literal notranslate"><span class="pre">skimage.exposure.rescale_intensity()</span></code></dt><dd><p>for the resscaling following rotation</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.gridcell.SAC.getorientation">
<code class="sig-name descname">getorientation</code><span class="sig-paren">(</span><em class="sig-param">peakCoords</em>, <em class="sig-param">closestPeakIdx</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.gridcell.SAC.getorientation" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the angle of the peaks working counter-clockwise from 3 o’clock</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>peakCoords</strong> (<em>array_like</em>) – The peak coordinates as pairs of xy</p></li>
<li><p><strong>closestPeakIdx</strong> (<em>array_like</em>) – A 1D array of the indices in peakCoords of the peaks closest to the centre
of the SAC</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>peak_orientations</strong> – An array of the angles of the peaks in the SAC working counter-clockwise
from a line extending from the middle of the SAC to 3 o’clock. The array
is sorted from closest peak to the centre to the most distant</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.gridcell.SAC.show">
<code class="sig-name descname">show</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">inDict</em>, <em class="sig-param">ax=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.gridcell.SAC.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Displays the result of performing a spatial autocorrelation on a grid cell.</p>
<p>Uses the spatial autocorrelogram calculated in autoCorr2D() and the dictionary
populated in getmeasures() to make a pretty picture</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>array_like</em>) – The spatial autocorrelogram</p></li>
<li><p><strong>inDict</strong> (<em>dict</em>) – The dictionary calculated in getmeasures</p></li>
<li><p><strong>ax</strong> (<em>matplotlib.axes._subplots.AxesSubplot</em><em>, </em><em>optional</em>) – If given the plot will get drawn in these axes. Default None</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>ret</strong> – The axes in which the SAC is shown</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>matplotlib.image.AxesImage</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.gridcell.SAC.t_win_SAC">
<code class="sig-name descname">t_win_SAC</code><span class="sig-paren">(</span><em class="sig-param">xy</em>, <em class="sig-param">spkIdx</em>, <em class="sig-param">ppm=365</em>, <em class="sig-param">winSize=10</em>, <em class="sig-param">pos_sample_rate=50</em>, <em class="sig-param">nbins=71</em>, <em class="sig-param">boxcar=5</em>, <em class="sig-param">Pthresh=100</em>, <em class="sig-param">downsampfreq=50</em>, <em class="sig-param">plot=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.gridcell.SAC.t_win_SAC" title="Permalink to this definition">¶</a></dt>
<dd><p>Temporal windowed spatial autocorrelation. For rationale see Notes below</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xy</strong> (<em>array_like</em>) – The position data</p></li>
<li><p><strong>spkIdx</strong> (<em>array_like</em>) – The indices in xy where the cell fired</p></li>
<li><p><strong>ppm</strong> (<em>int</em><em>, </em><em>optional</em>) – The camera pixels per metre. Default 365</p></li>
<li><p><strong>winSize</strong> (<em>int</em><em>, </em><em>optional</em>) – The window size for the temporal search</p></li>
<li><p><strong>pos_sample_rate</strong> (<em>int</em><em>, </em><em>optional</em>) – The rate at which position was sampled. Default 50</p></li>
<li><p><strong>nbins</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of bins for creating the resulting ratemap. Default 71</p></li>
<li><p><strong>boxcar</strong> (<em>int</em><em>, </em><em>optional</em>) – The size of the smoothing kernel to smooth ratemaps. Default 5</p></li>
<li><p><strong>Pthresh</strong> (<em>int</em><em>, </em><em>optional</em>) – The cut=off for values in the ratemap; values &lt; Pthresh become nans.
Default 100</p></li>
<li><p><strong>downsampfreq</strong> (<em>int</em><em>, </em><em>optional</em>) – How much to downsample. Default 50</p></li>
<li><p><strong>plot</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to show a plot of the result. Default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>H</strong> – The temporal windowed SAC</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-ephysiopy.ephys_generic.phaseprecession">
<span id="ephysiopy-ephys-generic-phaseprecession-module"></span><h2>ephysiopy.ephys_generic.phaseprecession module<a class="headerlink" href="#module-ephysiopy.ephys_generic.phaseprecession" title="Permalink to this headline">¶</a></h2>
<p>Mostly a total rip-off of code written by Ali Jeewajee for his paper on
2D phase precession in place and grid cells <a class="footnote-reference brackets" href="#id2" id="id1">1</a></p>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Jeewajee A, Barry C, Douchamps V, Manson D, Lever C, Burgess N. Theta phase
precession of grid and place cell firing in open environments. Philos Trans R Soc
Lond B Biol Sci. 2013 Dec 23;369(1635):20120532. doi: 10.1098/rstb.2012.0532.</p>
</dd>
</dl>
<dl class="class">
<dt id="ephysiopy.ephys_generic.phaseprecession.phasePrecession">
<em class="property">class </em><code class="sig-prename descclassname">ephysiopy.ephys_generic.phaseprecession.</code><code class="sig-name descname">phasePrecession</code><span class="sig-paren">(</span><em class="sig-param">filename_root, psr=50.0, esr=250.0, binsizes=array([0.5, 0.5]), smthKernLen=50, smthKernSig=5, fieldThresh=0.35, areaThresh=nan, binsPerCm=2, allowedminSpkPhase=3.141592653589793, mnPowPrctThresh=0, allowedThetaLen=[20, 42], spdSmoothWindow=15, runMinSpd=2.5, runMinDuration=2, runSmoothWindowFrac=0.3333333333333333, spatialLPCutOff=3, ifr_kernLen=1, ifr_kernSig=0.5, binsPerSec=50</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.phaseprecession.phasePrecession" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Performs phase precession analysis for single unit data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename_root</strong> (<em>str</em>) – The absolute filename with no suffix</p></li>
<li><p><strong>psr</strong> (<em>float</em><em>, </em><em>optional</em>) – The sample rate for position data. Default 50.0</p></li>
<li><p><strong>esr</strong> (<em>float</em><em>, </em><em>optional</em>) – The sample rate for eeg data. Default 250.0</p></li>
<li><p><strong>binsizes</strong> (<em>array_like</em><em>, </em><em>optional</em>) – The binsizes for the rate maps. Default numpy.array([0.5,0.5])</p></li>
<li><p><strong>smthKernLen</strong> (<em>int</em><em>, </em><em>optional</em>) – Kernel length for gaussian field smoothing. Default 50</p></li>
<li><p><strong>smthKernSig</strong> (<em>int</em><em>, </em><em>optional</em>) – Kernel sigma for gaussian field smoothing. Default 5</p></li>
<li><p><strong>fieldThresh</strong> (<em>float</em><em>, </em><em>optional</em>) – Fractional limit of field peak rate to restrict field size. Default 0.35</p></li>
<li><p><strong>areaThresh</strong> (<em>float</em><em>, </em><em>optional</em>) – Fractional limit for reducing fields at environment edge. Default numpy.nan</p></li>
<li><p><strong>binsPerCm</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of bins per cm. Default 2</p></li>
<li><p><strong>allowedminSpkPhase</strong> (<em>float</em><em>, </em><em>optional</em>) – Defines the start / end of theta cycles. Default numpy.pi</p></li>
<li><p><strong>mnPowPrctThresh</strong> (<em>int</em><em>, </em><em>optional</em>) – Percentile power below which theta cycles are rejected. Default 0</p></li>
<li><p><strong>allowedThetaLen</strong> (<em>array_like</em><em>, </em><em>optional</em>) – Bandwidth of theta in bins. Default [20,42]</p></li>
<li><p><strong>spdSmoothWindow</strong> (<em>int</em><em>, </em><em>optional</em>) – Kernel length for boxcar smoothing of speed. Default 15</p></li>
<li><p><strong>runMinSpd</strong> (<em>float</em><em>, </em><em>optional</em>) – Minimum allowed running speed in cm/s. Default 2.5</p></li>
<li><p><strong>runMinDuration</strong> (<em>int</em><em>, </em><em>optional</em>) – Minimum allowed run duration in seconds. Default 2</p></li>
<li><p><strong>runSmoothWindowFrac</strong> (<em>float</em><em>, </em><em>optional</em>) – Instantaneous firing rate smoothing constant. Default 1/3</p></li>
<li><p><strong>spatialLPCutOff</strong> (<em>int</em><em>, </em><em>optional</em>) – Spatial low-pass cutoff frequency. Default 3</p></li>
<li><p><strong>ifr_kernelLen</strong> (<em>int</em><em>, </em><em>optional</em>) – Instantaneous firing rate smoothing kernel length. Default 1</p></li>
<li><p><strong>ifr_kernelSig</strong> (<em>float</em><em>, </em><em>optional</em>) – Instantaneous firing rate smoothing kernel sigma. Default 0.5</p></li>
<li><p><strong>binsPerSec</strong> (<em>int</em><em>, </em><em>optional</em>) – Bins per second for instantaneous firing rate smoothing. Default 50</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="ephysiopy.ephys_generic.phaseprecession.phasePrecession.getPosProps">
<code class="sig-name descname">getPosProps</code><span class="sig-paren">(</span><em class="sig-param">tetrode</em>, <em class="sig-param">cluster</em>, <em class="sig-param">labels</em>, <em class="sig-param">peaksXY</em>, <em class="sig-param">laserEvents=None</em>, <em class="sig-param">plot=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.phaseprecession.phasePrecession.getPosProps" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses the output of partitionFields and returns vectors the same
length as pos.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cluster</strong> (<em>tetrode</em><em>,</em>) – The tetrode / cluster to examine</p></li>
<li><p><strong>peaksXY</strong> (<em>array_like</em>) – The x-y coords of the peaks in the ratemap</p></li>
<li><p><strong>laserEvents</strong> (<em>array_like</em>) – The position indices of on events (laser on)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>pos_dict, run_dict</strong> – Contains a whole bunch of information for the whole trial (pos_dict) and
also on a run-by-run basis (run_dict). See the end of this function for all
the key / value pairs.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.phaseprecession.phasePrecession.getSpikeProps">
<code class="sig-name descname">getSpikeProps</code><span class="sig-paren">(</span><em class="sig-param">tetrode</em>, <em class="sig-param">cluster</em>, <em class="sig-param">runLabel</em>, <em class="sig-param">meanDir</em>, <em class="sig-param">durationInPosBins</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.phaseprecession.phasePrecession.getSpikeProps" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.phaseprecession.phasePrecession.getThetaProps">
<code class="sig-name descname">getThetaProps</code><span class="sig-paren">(</span><em class="sig-param">tetrode</em>, <em class="sig-param">cluster</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.phaseprecession.phasePrecession.getThetaProps" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.phaseprecession.phasePrecession.partitionFields">
<code class="sig-name descname">partitionFields</code><span class="sig-paren">(</span><em class="sig-param">tetrode</em>, <em class="sig-param">cluster</em>, <em class="sig-param">ftype='g'</em>, <em class="sig-param">plot=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.phaseprecession.phasePrecession.partitionFields" title="Permalink to this definition">¶</a></dt>
<dd><p>Partitions fileds.</p>
<p>Partitions spikes into fields by finding the watersheds around the
peaks of a super-smoothed ratemap</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cluster</strong> (<em>tetrode</em><em>,</em>) – The tetrode / cluster to examine</p></li>
<li><p><strong>ftype</strong> (<em>str</em>) – ‘p’ or ‘g’ denoting place or grid cells - not implemented yet</p></li>
<li><p><strong>plot</strong> (<em>boolean</em>) – Whether to produce a debugging plot or not</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>peaksXY</strong> (<em>array_like</em>) – The xy coordinates of the peak rates in each field</p></li>
<li><p><strong>peaksRate</strong> (<em>array_like</em>) – The peak rates in peaksXY</p></li>
<li><p><strong>labels</strong> (<em>numpy.ndarray</em>) – An array of the labels corresponding to each field (indices start at 1)</p></li>
<li><p><strong>rmap</strong> (<em>numpy.ndarray</em>) – The ratemap of the tetrode / cluster</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.phaseprecession.phasePrecession.performRegression">
<code class="sig-name descname">performRegression</code><span class="sig-paren">(</span><em class="sig-param">tetrode</em>, <em class="sig-param">cluster</em>, <em class="sig-param">laserEvents=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.phaseprecession.phasePrecession.performRegression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.phaseprecession.phasePrecession.plotPPRegression">
<code class="sig-name descname">plotPPRegression</code><span class="sig-paren">(</span><em class="sig-param">regressorDict</em>, <em class="sig-param">regressor2plot='pos_d_cum'</em>, <em class="sig-param">ax=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.phaseprecession.phasePrecession.plotPPRegression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.phaseprecession.phasePrecession.thetaMod">
<code class="sig-name descname">thetaMod</code><span class="sig-paren">(</span><em class="sig-param">eeg</em>, <em class="sig-param">spikeTS=None</em>, <em class="sig-param">pos2use=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.phaseprecession.phasePrecession.thetaMod" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates theta modulation properties of cells and EEG</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-ephysiopy.ephys_generic.statscalcs">
<span id="ephysiopy-ephys-generic-statscalcs-module"></span><h2>ephysiopy.ephys_generic.statscalcs module<a class="headerlink" href="#module-ephysiopy.ephys_generic.statscalcs" title="Permalink to this headline">¶</a></h2>
<p>Mostly does circular statistics stuff but has some cool other
stuff</p>
<dl class="class">
<dt id="ephysiopy.ephys_generic.statscalcs.StatsCalcs">
<em class="property">class </em><code class="sig-prename descclassname">ephysiopy.ephys_generic.statscalcs.</code><code class="sig-name descname">StatsCalcs</code><a class="headerlink" href="#ephysiopy.ephys_generic.statscalcs.StatsCalcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="ephysiopy.ephys_generic.statscalcs.StatsCalcs.V_test">
<code class="sig-name descname">V_test</code><span class="sig-paren">(</span><em class="sig-param">angles</em>, <em class="sig-param">test_direction</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.statscalcs.StatsCalcs.V_test" title="Permalink to this definition">¶</a></dt>
<dd><p>The Watson U2 tests whether the observed angles have a tendency to
cluster around a given angle indicating a lack of randomness in the
distribution. Also known as the modified Rayleigh test</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>angles</strong> (<em>array_like</em>) – Vector of angular values in degrees</p></li>
<li><p><strong>test_direction</strong> (<em>int</em>) – A single angular value in degrees</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>float</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>The V statistic</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For grouped data the length of the mean vector must be adjusted,
and for axial data all angles must be doubled.</p>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.statscalcs.StatsCalcs.circ_r">
<code class="sig-name descname">circ_r</code><span class="sig-paren">(</span><em class="sig-param">alpha</em>, <em class="sig-param">w=None</em>, <em class="sig-param">d=0</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.statscalcs.StatsCalcs.circ_r" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the mean resultant vector length for circular data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alpha</strong> (<em>array</em><em> or </em><em>list</em>) – sample of angles in radians</p></li>
<li><p><strong>w</strong> (<em>array</em><em> or </em><em>list</em>) – counts in the case of binned data. Must be same length as alpha</p></li>
<li><p><strong>d</strong> (<em>array</em><em> or </em><em>list</em>) – spacing of bin centres for binned data; if supplied, correction
factor is used to correct for bias in estimation of r, in radians</p></li>
<li><p><strong>axis</strong> (<em>int</em>) – the dimension along which to compute, Default is 0</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>r</strong> – the mean resultant vector length</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.statscalcs.StatsCalcs.duplicates_as_complex">
<code class="sig-name descname">duplicates_as_complex</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">already_sorted=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.statscalcs.StatsCalcs.duplicates_as_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds duplicates in x</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>array_like</em>) – The list to find duplicates in</p></li>
<li><p><strong>already_sorted</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether x is already sorted. Default False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>x</strong> – A complex array where the complex part is the count of the
number of duplicates of the real value</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span>    <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mf">9.9</span><span class="p">,</span> <span class="mf">9.9</span><span class="p">,</span> <span class="mf">12.3</span><span class="p">,</span> <span class="mf">15.2</span><span class="p">,</span> <span class="mf">15.2</span><span class="p">,</span> <span class="mf">15.2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ret</span> <span class="o">=</span> <span class="n">duplicates_as_complex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">print</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
<span class="go">[9.9+0j, 9.9+1j,  12.3+0j, 15.2+0j, 15.2+1j, 15.2+2j]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.statscalcs.StatsCalcs.mean_resultant_vector">
<code class="sig-name descname">mean_resultant_vector</code><span class="sig-paren">(</span><em class="sig-param">angles</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.statscalcs.StatsCalcs.mean_resultant_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the mean resultant length and direction for angles</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>angles</strong> (<em>np.array</em>) – sample of angles in radians</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>r</strong> (<em>float</em>) – the mean resultant vector length</p></li>
<li><p><strong>th</strong> (<em>float</em>) – the mean resultant vector direction</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.statscalcs.StatsCalcs.watsonWilliams">
<code class="sig-name descname">watsonWilliams</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.statscalcs.StatsCalcs.watsonWilliams" title="Permalink to this definition">¶</a></dt>
<dd><p>The Watson-Williams F test tests whether a set of mean directions are
equal given that the concentrations are unknown, but equal, given that
the groups each follow a von Mises distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>b</strong> (<em>a</em><em>,</em>) – The directional samples</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The F-statistic</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.statscalcs.StatsCalcs.watsonsU2">
<code class="sig-name descname">watsonsU2</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.statscalcs.StatsCalcs.watsonsU2" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether two samples from circular observations differ
significantly from each other with regard to mean direction or angular
variance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>b</strong> (<em>a</em><em>,</em>) – The two samples to be tested</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>float</strong> – The test statistic</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>U2</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Both samples must come from a continuous distribution. In the case of
grouping the class interval should not exceed 5.
Taken from ‘100 Statistical Tests’ G.J.Kanji, 2006 Sage Publications</p>
</dd></dl>

<dl class="method">
<dt id="ephysiopy.ephys_generic.statscalcs.StatsCalcs.watsonsU2n">
<code class="sig-name descname">watsonsU2n</code><span class="sig-paren">(</span><em class="sig-param">angles</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.statscalcs.StatsCalcs.watsonsU2n" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether the given distribution fits a random sample of angular values</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>angles</strong> (<em>array_like</em>) – The angular samples</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>float</strong> – The test statistic</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>U2n</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This test is suitable for both unimodal and the multimodal cases.
It can be used as a test for randomness.
Taken from ‘100 Statistical Tests’ G.J.Kanji, 2006 Sage Publications</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-ephysiopy.ephys_generic.utils">
<span id="ephysiopy-ephys-generic-utils-module"></span><h2>ephysiopy.ephys_generic.utils module<a class="headerlink" href="#module-ephysiopy.ephys_generic.utils" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="ephysiopy.ephys_generic.utils.blur_image">
<code class="sig-prename descclassname">ephysiopy.ephys_generic.utils.</code><code class="sig-name descname">blur_image</code><span class="sig-paren">(</span><em class="sig-param">im</em>, <em class="sig-param">n</em>, <em class="sig-param">ny=None</em>, <em class="sig-param">ftype='boxcar'</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.utils.blur_image" title="Permalink to this definition">¶</a></dt>
<dd><p>blurs the image by convolving with a filter (‘gaussian’ or
‘boxcar’) of
size n. The optional keyword argument ny allows for a different
size in the y direction.</p>
</dd></dl>

<dl class="function">
<dt id="ephysiopy.ephys_generic.utils.count_to">
<code class="sig-prename descclassname">ephysiopy.ephys_generic.utils.</code><code class="sig-name descname">count_to</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">n</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.utils.count_to" title="Permalink to this definition">¶</a></dt>
<dd><p>By example:</p>
<blockquote>
<div><p>#    0  1  2  3  4  5  6  7  8
n = [0, 0, 3, 0, 0, 2, 0, 2, 1]
res = [0, 1, 2, 0, 1, 0, 1, 0]</p>
</div></blockquote>
<p>That is it is equivalent to something like this :</p>
<blockquote>
<div><p>hstack((arange(n_i) for n_i in n))</p>
</div></blockquote>
<p>This version seems quite a bit faster, at least for some
possible inputs, and at any rate it encapsulates a task
in a function.</p>
</dd></dl>

<dl class="function">
<dt id="ephysiopy.ephys_generic.utils.polar">
<code class="sig-prename descclassname">ephysiopy.ephys_generic.utils.</code><code class="sig-name descname">polar</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">y</em>, <em class="sig-param">deg=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.utils.polar" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts from rectangular coordinates to polar ones</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y</strong> (<em>x</em><em>,</em>) – The x and y coordinates</p></li>
<li><p><strong>deg</strong> (<em>int</em>) – radian if deg=0; degree if deg=1</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>p</strong> – The polar version of x and y</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="ephysiopy.ephys_generic.utils.rect">
<code class="sig-prename descclassname">ephysiopy.ephys_generic.utils.</code><code class="sig-name descname">rect</code><span class="sig-paren">(</span><em class="sig-param">r</em>, <em class="sig-param">w</em>, <em class="sig-param">deg=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.utils.rect" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from polar (r,w) to rectangular (x,y)
x = r cos(w)
y = r sin(w)</p>
</dd></dl>

<dl class="function">
<dt id="ephysiopy.ephys_generic.utils.repeat_ind">
<code class="sig-prename descclassname">ephysiopy.ephys_generic.utils.</code><code class="sig-name descname">repeat_ind</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">n</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.utils.repeat_ind" title="Permalink to this definition">¶</a></dt>
<dd><p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">repeat_ind</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
</pre></div>
</div>
<p>That is the input specifies how many times to repeat the given index.</p>
<p>It is equivalent to something like this :</p>
<blockquote>
<div><p>hstack((zeros(n_i,dtype=int)+i for i, n_i in enumerate(n)))</p>
</div></blockquote>
<p>But this version seems to be faster, and probably scales better, at
any rate it encapsulates a task in a function.</p>
</dd></dl>

<dl class="function">
<dt id="ephysiopy.ephys_generic.utils.smooth">
<code class="sig-prename descclassname">ephysiopy.ephys_generic.utils.</code><code class="sig-name descname">smooth</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">window_len=9</em>, <em class="sig-param">window='hanning'</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.utils.smooth" title="Permalink to this definition">¶</a></dt>
<dd><p>Smooth the data using a window with requested size.</p>
<p>This method is based on the convolution of a scaled window with the signal.
The signal is prepared by introducing reflected copies of the signal
(with the window size) in both ends so that transient parts are minimized
in the begining and end part of the output signal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>array_like</em>) – the input signal</p></li>
<li><p><strong>window_len</strong> (<em>int</em>) – The length of the smoothing window</p></li>
<li><p><strong>window</strong> (<em>str</em>) – The type of window from ‘flat’, ‘hanning’, ‘hamming’, ‘bartlett’, ‘blackman’
‘flat’ window will produce a moving average smoothing.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>The smoothed signal</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">=</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">=</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">+</span><span class="n">randn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="o">*</span><span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">=</span><span class="n">smooth</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.hanning()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.hamming()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.bartlett()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.blackman()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.convolve()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.signal.lfilter()</span></code></p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">TODO()</span></code></dt><dd><p>the window parameter could be the window itself if an array instead of a string</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="ephysiopy.ephys_generic.utils.spiral">
<code class="sig-prename descclassname">ephysiopy.ephys_generic.utils.</code><code class="sig-name descname">spiral</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">X</em>, <em class="sig-param">Y</em><span class="sig-paren">)</span><a class="headerlink" href="#ephysiopy.ephys_generic.utils.spiral" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an array of shape X x Y this returns the coordinates needed to step
out from the centre of the array to the edge in a spiral fashion:</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">See()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">for()</span></code></p>
</div>
</dd></dl>

</div>
<div class="section" id="module-ephysiopy.ephys_generic">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-ephysiopy.ephys_generic" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Robin Hayman

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>