<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>ephysiopy.format_converters.OE_Axona API documentation</title>
<meta name="description" content="Created on Fri Sep 27 12:08:10 2019 â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ephysiopy.format_converters.OE_Axona</code></h1>
</header>
<section id="section-intro">
<p>Created on Fri Sep 27 12:08:10 2019</p>
<p>@author: robin</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Fri Sep 27 12:08:10 2019

@author: robin
&#34;&#34;&#34;
import numpy as np
import os
import matplotlib.pylab as plt
from ephysiopy.dacq2py import axonaIO
from ephysiopy.ephys_generic.ephys_generic import PosCalcsGeneric
from ephysiopy.openephys2py import OEKiloPhy, OESettings
from scipy import signal
import h5py

class OE2Axona(object):
        &#34;&#34;&#34;

        &#34;&#34;&#34;
        def __init__(self, filename_root: str):
                self.filename_root = filename_root # &#39;/home/robin/Data/experiment_1.nwb&#39; or whatever
                self.dirname = os.path.dirname(filename_root) # &#39;/home/robin/Data&#39;
                self.experiment_name = os.path.basename(self.filename_root) # &#39;experiment_1.nwb&#39;
                self.recording_name = None # will become &#39;recording1&#39; etc
                self.OE_data = None # will become an instance of OEKiloPhy.OpenEphysNWB
                self._settings = None # will become an instance of OESettings.Settings
                # Create a basename for Axona file names e.g.&#39;/home/robin/Data/experiment_1&#39;
                # that we can append &#39;.pos&#39; or &#39;.eeg&#39; or whatever onto
                self.axona_root_name = os.path.join(self.dirname, os.path.splitext(self.experiment_name)[0])
                self.AxonaData = axonaIO.IO(self.axona_root_name + &#34;.pos&#34;) # need to instantiated now for later
                # THIS IS TEMPORARY AND WILL BE MORE USER-SPECIFIABLE IN THE FUTURE
                # it is used to scale the spikes
                self.hp_gain = 500
                self.lp_gain = 15000
                self.bitvolts = 0.195
                # if left as None some default values for the next 3 params are loaded from top-level __init__.py
                # these are only used in self.__filterLFP__
                self.fs = None
                # if lfp_channel is set to None then the .set file will reflect that no EEG was recorded
                # this should mean that you can load data into Tint without a .eeg file
                self.lfp_channel = 1
                self.lfp_lowcut = None
                self.lfp_highcut = None
                # set the tetrodes to record from
                # defaults to 1 through 4 - see self.makeSetData below
                self.tetrodes = [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;]

        def resample(self, data, src_rate=30, dst_rate=50, axis=0):
                &#39;&#39;&#39;
                Upsamples data using FFT
                &#39;&#39;&#39;
                denom = np.gcd(dst_rate, src_rate)
                new_data = signal.resample_poly(data, dst_rate/denom, src_rate/denom, axis)
                return new_data

        @property
        def settings(self):
                &#39;&#39;&#39;
                Loads the settings data from the settings.xml file
                &#39;&#39;&#39;
                if self._settings is None:
                        self._settings = OESettings.Settings(self.dirname)
                return self._settings

        @settings.setter
        def settings(self, value):
                self._settings = value

        def getOEData(self, filename_root: str, recording_name=&#39;recording1&#39;)-&gt;dict:
                &#39;&#39;&#39;
                Loads the nwb file names in filename_root and returns a dict containing some of the nwb data
                relevant for converting to Axona file formats

                Parameters
                ----------------
                filename_root - fuly qualified name of the nwb file
                recording_name - the name of the recording in the nwb file NB the default has changed in different versions of OE from &#39;recording0&#39; to &#39;recording1&#39;
                &#39;&#39;&#39;
                if os.path.isfile(filename_root):
                        root_filename = os.path.splitext(self.experiment_name)[0]
                        OE_data = OEKiloPhy.OpenEphysNWB(self.dirname)
                        print(&#34;Loading nwb data...&#34;)
                        OE_data.load(pname_root=self.dirname, session_name=self.experiment_name, recording_name=recording_name, loadspikes=True, loadraw=False)
                        print(&#34;Loaded nwb data from: {}&#34;.format(filename_root))
                        # It&#39;s likely that spikes have been collected after the last position sample
                        # due to buffering issues I can&#39;t be bothered to resolve. Get the last pos
                        # timestamps here and check that spikes don&#39;t go beyond this when writing data
                        # out later
                        # Also the pos and spike data timestamps almost never start at 0 as the user
                        # usually acquires data for a while before recording. Grab the first timestamp
                        # here with a view to subtracting this from everything (including the spike data)
                        # and figuring out what to keep later
                        first_pos_ts = OE_data.xyTS[0]
                        last_pos_ts = OE_data.xyTS[-1]
                        self.first_pos_ts = first_pos_ts
                        self.last_pos_ts = last_pos_ts
                        self.recording_name = recording_name
                        self.OE_data = OE_data
                        return OE_data

        def exportSetFile(self, **kwargs):
                &#39;&#39;&#39;
                Wrapper for makeSetData below
                &#39;&#39;&#39;
                print(&#34;Exporting set file data...&#34;)
                self.makeSetData(kwargs)
                print(&#34;Done exporting set file.&#34;)

        def exportPos(self, ppm=300, jumpmax=100, as_text=False):
                #
                # Step 1) Deal with the position data first:
                #
                # Grab the settings of the pos tracker and do some post-processing on the position
                # data (discard jumpy data, do some smoothing etc)
                # settings = OESettings.Settings(os.path.join(self.dirname, &#39;settings.xml&#39;))
                self.settings.parsePos()
                posProcessor = PosCalcsGeneric(self.OE_data.xy[:,0], self.OE_data.xy[:,1], ppm, True, jumpmax)
                print(&#34;Post-processing position data...&#34;)
                xy, _ = posProcessor.postprocesspos(self.settings.tracker_params)
                xy = xy.T
                if as_text is True:
                        print(&#34;Beginning export of position data to text format...&#34;)
                        pos_file_name = self.axona_root_name + &#34;.txt&#34;
                        np.savetxt(pos_file_name, self.OE_data.xy, fmt=&#39;%1.u&#39;)
                        print(&#34;Completed export of position data&#34;)
                        return
                # Do the upsampling of both xy and the timestamps
                print(&#34;Beginning export of position data to Axona format...&#34;)
                axona_pos_file_name = self.axona_root_name + &#34;.pos&#34;
                axona_pos_data = self.convertPosData(xy, self.OE_data.xyTS)
                # make sure pos data length is same as duration * num_samples
                axona_pos_data = axona_pos_data[0:int(self.last_pos_ts - self.first_pos_ts)*50]
                # Create an empty header for the pos data
                pos_header = self.AxonaData.getEmptyHeader(&#34;pos&#34;)
                for key in pos_header.keys():
                        if &#39;min_x&#39; in key:
                                pos_header[key] = str(self.settings.tracker_params[&#39;LeftBorder&#39;])
                        if &#39;min_y&#39; in key:
                                pos_header[key] = str(self.settings.tracker_params[&#39;TopBorder&#39;])
                        if &#39;max_x&#39; in key:
                                pos_header[key] = str(self.settings.tracker_params[&#39;RightBorder&#39;])
                        if &#39;max_y&#39; in key:
                                pos_header[key] = str(self.settings.tracker_params[&#39;BottomBorder&#39;])
                pos_header[&#39;duration&#39;] = str(int(self.last_pos_ts - self.first_pos_ts))
                # Rest of this stuff probably won&#39;t change so should be defaulted in the loaded file
                # (see axonaIO.py)
                pos_header[&#39;num_colours&#39;] = &#39;4&#39;
                pos_header[&#39;sw_version&#39;] = &#39;1.2.2.1&#39;
                pos_header[&#39;timebase&#39;] = &#39;50 hz&#39;
                pos_header[&#39;sample_rate&#39;] = &#39;50.0 hz&#39;
                pos_header[&#39;pos_format&#39;] = &#39;t,x1,y1,x2,y2,numpix1,numpix2&#39;
                pos_header[&#39;bytes_per_coord&#39;] = &#39;2&#39;
                pos_header[&#39;EEG_samples_per_position&#39;] = &#39;5&#39;
                pos_header[&#39;bytes_per_timestamp&#39;] = &#39;4&#39;
                pos_header[&#39;pixels_per_metre&#39;] = str(ppm)
                pos_header[&#39;num_pos_samples&#39;] = str(len(axona_pos_data))
                pos_header[&#39;bearing_colour_1&#39;] = &#39;210&#39;
                pos_header[&#39;bearing_colour_2&#39;] = &#39;30&#39;
                pos_header[&#39;bearing_colour_3&#39;] = &#39;0&#39;
                pos_header[&#39;bearing_colour_4&#39;] = &#39;0&#39;
                pos_header[&#39;pixels_per_metre&#39;] = str(ppm)

                self.writePos2AxonaFormat(pos_header, axona_pos_data)
                print(&#34;Exported position data to Axona format&#34;)

        def exportSpikes(self):
                print(&#34;Beginning conversion of spiking data...&#34;)
                self.convertSpikeData(self.OE_data.nwbData[&#39;acquisition&#39;][&#39;timeseries&#39;][self.recording_name][&#39;spikes&#39;])
                print(&#34;Completed exporting spiking data&#34;)

        def exportLFP(self, channel: int, lfp_type: str, gain: int):
                &#39;&#39;&#39;
                Export LFP data to file

                Parameters
                -----------
                channel - int
                lfp_type - str. Legal values are &#39;egf&#39; or &#39;eeg&#39;
                gain - int. Multiplier for the lfp data
                &#39;&#39;&#39;
                print(&#34;Beginning conversion and exporting of LFP data...&#34;)
                if self.settings.fpga_nodeId is None:
                        self.settings.parse()
                fpgaNode = &#39;processor&#39; + str(self.settings.fpga_nodeId) + &#39;_&#39; + str(self.settings.fpga_nodeId)
                data = self.OE_data.nwbData[&#39;acquisition&#39;][&#39;timeseries&#39;][self.recording_name][&#39;continuous&#39;][fpgaNode][&#39;data&#39;][:, channel]
                self.makeLFPData(data, eeg_type=lfp_type, gain=gain)
                # if the set file has been created then update which channel contains the eeg record so
                # that the gain can be loaded correctly when using dacq2py_util

                print(&#34;Completed exporting LFP data to &#34; + lfp_type + &#34; format&#34;)

        def convertPosData(self, xy: np.array, xy_ts: np.array) -&gt; np.array:
                &#39;&#39;&#39;
                Perform the conversion of the array parts of the data
                NB As well as upsampling the data to the Axona pos sampling rate (50Hz)
                we have to insert some columns into the pos array as Axona format expects it like:
                pos_format: t,x1,y1,x2,y2,numpix1,numpix2
                We can make up some of the info and ignore other bits
                &#39;&#39;&#39;
                n_new_pts = int(np.floor((self.last_pos_ts-self.first_pos_ts) * 50))
                t = xy_ts - self.first_pos_ts
                new_ts = np.linspace(t[0], t[-1], n_new_pts)
                new_x = np.interp(new_ts, t, xy[:, 0])
                new_y = np.interp(new_ts, t, xy[:, 1])
                # Expand the pos bit of the data to be returned to make it look like Axona data
                new_pos = np.vstack([new_x, new_y]).T
                new_pos = np.c_[new_pos, np.ones_like(new_pos) * 1023, np.zeros_like(new_pos), np.zeros_like(new_pos)]
                new_pos[:, 4] = 40 # just made this value up - it&#39;s numpix i think
                new_pos[:, 6] = 40 # same
                # Squeeze this data into Axona pos format array
                dt = self.AxonaData.axona_files[&#39;.pos&#39;]
                new_data = np.zeros(n_new_pts, dtype=dt)
                # Timestamps in Axona are time in seconds * sample_rate
                new_data[&#39;ts&#39;] = new_ts * 50
                new_data[&#39;pos&#39;] = new_pos
                return new_data

        def convertSpikeData(self, hdf5_tetrode_data: h5py._hl.group.Group):
                &#39;&#39;&#39;
                Does the spike conversion from OE Spike Sorter format to Axona format tetrode files

                Parameters
                -----------
                hdf5_tetrode_data - h5py._hl.group.Group - this kind of looks like a dictionary and can, it seems,
                                                                be treated as one more or less (see http://docs.h5py.org/en/stable/high/group.html).
                &#39;&#39;&#39;
                # First lets get the datatype for tetrode files as this will be the same for all tetrodes...
                dt = self.AxonaData.axona_files[&#39;.1&#39;]
                # ... and a basic header for the tetrode file that use for each tetrode file, changing only the num_spikes value
                header = self.AxonaData.getEmptyHeader(&#34;tetrode&#34;)
                header[&#39;duration&#39;] = str(int(self.last_pos_ts-self.first_pos_ts))
                header[&#39;sw_version&#39;] = &#39;1.1.0&#39;
                header[&#39;num_chans&#39;] = &#39;4&#39;
                header[&#39;timebase&#39;] = &#39;96000 hz&#39;
                header[&#39;bytes_per_timestamp&#39;] = &#39;4&#39;
                header[&#39;samples_per_spike&#39;] = &#39;50&#39;
                header[&#39;sample_rate&#39;] = &#39;48000 hz&#39;
                header[&#39;bytes_per_sample&#39;] = &#39;1&#39;
                header[&#39;spike_format&#39;] = &#39;t,ch1,t,ch2,t,ch3,t,ch4&#39;

                for key in hdf5_tetrode_data.keys():
                        spiking_data = np.array(hdf5_tetrode_data[key].get(&#39;data&#39;))
                        timestamps = np.array(hdf5_tetrode_data[key].get(&#39;timestamps&#39;))
                        # check if any of the spiking data is captured before/ after the first/ last bit of position data
                        # if there is then discard this as we potentially have no valid position to align the spike to :(
                        idx = np.logical_or(timestamps &lt; self.first_pos_ts, timestamps &gt; self.last_pos_ts)
                        spiking_data = spiking_data[~idx, :, :]
                        timestamps = timestamps[~idx]
                        # subtract the first pos timestamp from the spiking timestamps
                        timestamps = timestamps - self.first_pos_ts
                        # get the number of spikes here for use below in the header
                        num_spikes = len(timestamps)
                        # repeat the timestamps in tetrode multiples ready for Axona export
                        new_timestamps = np.repeat(timestamps, 4)
                        new_spiking_data = spiking_data.astype(np.float64)
                        # Convert to microvolts...
                        new_spiking_data = new_spiking_data * self.bitvolts
                        # And upsample the spikes...
                        new_spiking_data = self.resample(new_spiking_data, 4, 5, -1)
                        # ... and scale appropriately for Axona and invert as OE seems to be inverted wrt Axona
                        new_spiking_data = new_spiking_data / (self.hp_gain/4/128.0) * (-1)
                        # ... scale them to the gains specified somewhere (not sure where / how to do this yet)
                        shp = new_spiking_data.shape
                        # then reshape them as Axona wants them a bit differently
                        new_spiking_data = np.reshape(new_spiking_data, [shp[0] * shp[1], shp[2]])
                        # Cap any values outside the range of int8
                        new_spiking_data[new_spiking_data &lt; -128] = -128
                        new_spiking_data[new_spiking_data &gt; 127] = 127
                        # create the new array
                        new_tetrode_data = np.zeros(len(new_timestamps), dtype=dt)
                        new_tetrode_data[&#39;ts&#39;] = new_timestamps * 96000
                        new_tetrode_data[&#39;waveform&#39;] = new_spiking_data
                        # change the header num_spikes field
                        header[&#39;num_spikes&#39;] = str(num_spikes)
                        i_tetnum = key.split(&#39;electrode&#39;)[1]
                        print(&#34;Exporting tetrode {}&#34;.format(i_tetnum))
                        self.writeTetrodeData(i_tetnum, header, new_tetrode_data)

        def makeLFPData(self, hdf5_continuous_data: np.array, eeg_type=&#39;eeg&#39;, gain=5000):
                &#39;&#39;&#39;
                Downsamples the data in hdf5_continuous_data and saves the result
                as either an egf or eeg file depending on the choice of either eeg_type which can
                take a value of either &#39;egf&#39; or &#39;eeg&#39;
                gain is the scaling factor

                Parameters
                ----------
                hdf5_continuous_data - np.array with dtype as np.int16
                &#39;&#39;&#39;
                if eeg_type == &#39;eeg&#39;:
                        dt = self.AxonaData.axona_files[&#39;.eeg&#39;]
                        header = self.AxonaData.getEmptyHeader(&#34;eeg&#34;)
                        header[&#39;EEG_samples_per_position&#39;] = &#39;5&#39;
                        header[&#39;sample_rate&#39;] = &#39;250.0 hz&#39;
                        header[&#39;bytes_per_sample&#39;] = &#39;1&#39;
                        dst_rate = 250
                        sample_key = &#39;num_EEG_samples&#39;
                elif eeg_type == &#39;egf&#39;:
                        dt = self.AxonaData.axona_files[&#39;.egf&#39;]
                        header = self.AxonaData.getEmptyHeader(&#34;egf&#34;)
                        header[&#39;sample_rate&#39;] = &#39;4800 hz&#39;
                        header[&#39;bytes_per_sample&#39;] = &#39;2&#39;
                        dst_rate = 4800
                        sample_key = &#39;num_EGF_samples&#39;
                header[&#39;duration&#39;] = str(int(self.last_pos_ts-self.first_pos_ts))
                header[&#39;sw_version&#39;] = &#39;1.1.0&#39;
                header[&#39;num_chans&#39;] = &#39;1&#39;

                # hdf5_continuous_data = hdf5_continuous_data * (self.bitvolts * 1000) / gain
                lfp_data = self.resample(hdf5_continuous_data, 30000, dst_rate, -1)
                # make sure data is same length as sample_rate * duration
                nsamples = int(dst_rate * int(header[&#39;duration&#39;]))
                lfp_data = lfp_data[0:nsamples]
                lfp_data = self.__filterLFP__(lfp_data, dst_rate)
                # convert the data format
                # lfp_data = lfp_data * self.bitvolts # in microvolts

                if eeg_type == &#39;eeg&#39;:
                        # probably BROKEN
                        lfp_data = lfp_data / 32768. # lfp_data starts out as int16 (see Parameters above)
                        lfp_data = lfp_data * gain
                        # cap the values at either end...
                        lfp_data[lfp_data &lt; -128] = -128
                        lfp_data[lfp_data &gt; 127] = 127
                        # and convert to int8
                        lfp_data = lfp_data.astype(np.int8)

                elif eeg_type == &#39;egf&#39;:
                        # probably works
                        # lfp_data = lfp_data / 256.
                        lfp_data = lfp_data.astype(np.int16)

                header[sample_key] = str(len(lfp_data))
                self.writeLFP2AxonaFormat(header, lfp_data, eeg_type)

        def makeSetData(self, lfp_channel=1, **kwargs):
                if self.OE_data is None:
                        self.getOEData(self.filename_root) # to get the timestamps for duration key
                header = self.AxonaData.getEmptyHeader(&#34;set&#34;)
                # set some reasonable default values
                from ephysiopy import __version__
                header[&#39;sw_version&#39;] = __version__
                header[&#39;ADC_fullscale_mv&#39;] = &#39;0.195&#39;
                header[&#39;tracker_version&#39;] = &#39;1.1.0&#39;

                for k, v in header.items():
                        if &#39;gain&#39; in k:
                                header[k] = str(self.hp_gain)
                        if &#39;collectMask&#39; in k:
                                header[k] = &#39;0&#39;
                        if &#39;EEG_ch_1&#39; in k:
                                if lfp_channel is not None:
                                        header[k] = str(lfp_channel)
                        if &#39;mode_ch_&#39; in k:
                                header[k] = &#39;0&#39;
                # iterate again to make sure lfp gain set correctly
                for k, v in header.items():
                        if lfp_channel is not None:
                                if k == &#39;gain_ch_&#39; + str(lfp_channel):
                                        header[k] = str(self.lp_gain)

                # Based on the data in the electrodes dict of the OESettings instance (self.settings - see __init__)
                # determine which tetrodes we can let Tint load
                # make sure we&#39;ve parsed the electrodes
                self.settings.parseSpikeSorter()
                if self.settings.electrodes:
                        for k, v in self.settings.electrodes.items():
                                header[&#39;collectMask_&#39; + str(k)] = &#39;1&#39;
                if self.lfp_channel is not None:
                        for chan in self.tetrodes:
                                key = &#39;collectMask_&#39; + str(chan)
                                header[key] = &#39;1&#39;
                header[&#39;colactive_1&#39;] = &#39;1&#39;
                header[&#39;colactive_2&#39;] = &#39;0&#39;
                header[&#39;colactive_3&#39;] = &#39;0&#39;
                header[&#39;colactive_4&#39;] = &#39;0&#39;
                header[&#39;colmap_algorithm&#39;] = &#39;1&#39;
                header[&#39;duration&#39;] = str(int(self.last_pos_ts-self.first_pos_ts))
                self.writeSetData(header)

        def __filterLFP__(self, data: np.array, sample_rate: int):
                from scipy.signal import firwin, filtfilt
                if self.fs is None:
                        from ephysiopy import fs
                        self.fs = fs
                if self.lfp_lowcut is None:
                        from ephysiopy import lfp_lowcut
                        self.lfp_lowcut = lfp_lowcut
                if self.lfp_highcut is None:
                        from ephysiopy import lfp_highcut
                        self.lfp_highcut = lfp_highcut
                nyq = sample_rate / 2.
                lowcut = self.lfp_lowcut / nyq
                highcut = self.lfp_highcut / nyq
                if highcut &gt;= 1.0:
                        highcut = 1.0 - np.finfo(float).eps
                if lowcut &lt;= 0.0:
                        lowcut = np.finfo(float).eps
                b = firwin(sample_rate+1, [lowcut, highcut], window=&#39;black&#39;, pass_zero=False)
                y = filtfilt(b, [1], data.ravel(), padtype=&#39;odd&#39;)
                return y

        def writeLFP2AxonaFormat(self, header: dict, data: np.array, eeg_type=&#39;eeg&#39;):
                self.AxonaData.setHeader(self.axona_root_name + &#34;.&#34; + eeg_type, header)
                self.AxonaData.setData(self.axona_root_name + &#34;.&#34; + eeg_type, data)

        def writePos2AxonaFormat(self, header:  dict, data: np.array):
                self.AxonaData.setHeader(self.axona_root_name + &#34;.pos&#34;, header)
                self.AxonaData.setData(self.axona_root_name + &#34;.pos&#34;, data)

        def writeTetrodeData(self, tetnum: str, header: dict, data: np.array):
                self.AxonaData.setHeader(self.axona_root_name + &#34;.&#34; + tetnum, header)
                self.AxonaData.setData(self.axona_root_name + &#34;.&#34; + tetnum, data)

        def writeSetData(self, header: dict):
                self.AxonaData.setHeader(self.axona_root_name + &#34;.set&#34;, header)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ephysiopy.format_converters.OE_Axona.OE2Axona"><code class="flex name class">
<span>class <span class="ident">OE2Axona</span></span>
<span>(</span><span>filename_root)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OE2Axona(object):
        &#34;&#34;&#34;

        &#34;&#34;&#34;
        def __init__(self, filename_root: str):
                self.filename_root = filename_root # &#39;/home/robin/Data/experiment_1.nwb&#39; or whatever
                self.dirname = os.path.dirname(filename_root) # &#39;/home/robin/Data&#39;
                self.experiment_name = os.path.basename(self.filename_root) # &#39;experiment_1.nwb&#39;
                self.recording_name = None # will become &#39;recording1&#39; etc
                self.OE_data = None # will become an instance of OEKiloPhy.OpenEphysNWB
                self._settings = None # will become an instance of OESettings.Settings
                # Create a basename for Axona file names e.g.&#39;/home/robin/Data/experiment_1&#39;
                # that we can append &#39;.pos&#39; or &#39;.eeg&#39; or whatever onto
                self.axona_root_name = os.path.join(self.dirname, os.path.splitext(self.experiment_name)[0])
                self.AxonaData = axonaIO.IO(self.axona_root_name + &#34;.pos&#34;) # need to instantiated now for later
                # THIS IS TEMPORARY AND WILL BE MORE USER-SPECIFIABLE IN THE FUTURE
                # it is used to scale the spikes
                self.hp_gain = 500
                self.lp_gain = 15000
                self.bitvolts = 0.195
                # if left as None some default values for the next 3 params are loaded from top-level __init__.py
                # these are only used in self.__filterLFP__
                self.fs = None
                # if lfp_channel is set to None then the .set file will reflect that no EEG was recorded
                # this should mean that you can load data into Tint without a .eeg file
                self.lfp_channel = 1
                self.lfp_lowcut = None
                self.lfp_highcut = None
                # set the tetrodes to record from
                # defaults to 1 through 4 - see self.makeSetData below
                self.tetrodes = [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;]

        def resample(self, data, src_rate=30, dst_rate=50, axis=0):
                &#39;&#39;&#39;
                Upsamples data using FFT
                &#39;&#39;&#39;
                denom = np.gcd(dst_rate, src_rate)
                new_data = signal.resample_poly(data, dst_rate/denom, src_rate/denom, axis)
                return new_data

        @property
        def settings(self):
                &#39;&#39;&#39;
                Loads the settings data from the settings.xml file
                &#39;&#39;&#39;
                if self._settings is None:
                        self._settings = OESettings.Settings(self.dirname)
                return self._settings

        @settings.setter
        def settings(self, value):
                self._settings = value

        def getOEData(self, filename_root: str, recording_name=&#39;recording1&#39;)-&gt;dict:
                &#39;&#39;&#39;
                Loads the nwb file names in filename_root and returns a dict containing some of the nwb data
                relevant for converting to Axona file formats

                Parameters
                ----------------
                filename_root - fuly qualified name of the nwb file
                recording_name - the name of the recording in the nwb file NB the default has changed in different versions of OE from &#39;recording0&#39; to &#39;recording1&#39;
                &#39;&#39;&#39;
                if os.path.isfile(filename_root):
                        root_filename = os.path.splitext(self.experiment_name)[0]
                        OE_data = OEKiloPhy.OpenEphysNWB(self.dirname)
                        print(&#34;Loading nwb data...&#34;)
                        OE_data.load(pname_root=self.dirname, session_name=self.experiment_name, recording_name=recording_name, loadspikes=True, loadraw=False)
                        print(&#34;Loaded nwb data from: {}&#34;.format(filename_root))
                        # It&#39;s likely that spikes have been collected after the last position sample
                        # due to buffering issues I can&#39;t be bothered to resolve. Get the last pos
                        # timestamps here and check that spikes don&#39;t go beyond this when writing data
                        # out later
                        # Also the pos and spike data timestamps almost never start at 0 as the user
                        # usually acquires data for a while before recording. Grab the first timestamp
                        # here with a view to subtracting this from everything (including the spike data)
                        # and figuring out what to keep later
                        first_pos_ts = OE_data.xyTS[0]
                        last_pos_ts = OE_data.xyTS[-1]
                        self.first_pos_ts = first_pos_ts
                        self.last_pos_ts = last_pos_ts
                        self.recording_name = recording_name
                        self.OE_data = OE_data
                        return OE_data

        def exportSetFile(self, **kwargs):
                &#39;&#39;&#39;
                Wrapper for makeSetData below
                &#39;&#39;&#39;
                print(&#34;Exporting set file data...&#34;)
                self.makeSetData(kwargs)
                print(&#34;Done exporting set file.&#34;)

        def exportPos(self, ppm=300, jumpmax=100, as_text=False):
                #
                # Step 1) Deal with the position data first:
                #
                # Grab the settings of the pos tracker and do some post-processing on the position
                # data (discard jumpy data, do some smoothing etc)
                # settings = OESettings.Settings(os.path.join(self.dirname, &#39;settings.xml&#39;))
                self.settings.parsePos()
                posProcessor = PosCalcsGeneric(self.OE_data.xy[:,0], self.OE_data.xy[:,1], ppm, True, jumpmax)
                print(&#34;Post-processing position data...&#34;)
                xy, _ = posProcessor.postprocesspos(self.settings.tracker_params)
                xy = xy.T
                if as_text is True:
                        print(&#34;Beginning export of position data to text format...&#34;)
                        pos_file_name = self.axona_root_name + &#34;.txt&#34;
                        np.savetxt(pos_file_name, self.OE_data.xy, fmt=&#39;%1.u&#39;)
                        print(&#34;Completed export of position data&#34;)
                        return
                # Do the upsampling of both xy and the timestamps
                print(&#34;Beginning export of position data to Axona format...&#34;)
                axona_pos_file_name = self.axona_root_name + &#34;.pos&#34;
                axona_pos_data = self.convertPosData(xy, self.OE_data.xyTS)
                # make sure pos data length is same as duration * num_samples
                axona_pos_data = axona_pos_data[0:int(self.last_pos_ts - self.first_pos_ts)*50]
                # Create an empty header for the pos data
                pos_header = self.AxonaData.getEmptyHeader(&#34;pos&#34;)
                for key in pos_header.keys():
                        if &#39;min_x&#39; in key:
                                pos_header[key] = str(self.settings.tracker_params[&#39;LeftBorder&#39;])
                        if &#39;min_y&#39; in key:
                                pos_header[key] = str(self.settings.tracker_params[&#39;TopBorder&#39;])
                        if &#39;max_x&#39; in key:
                                pos_header[key] = str(self.settings.tracker_params[&#39;RightBorder&#39;])
                        if &#39;max_y&#39; in key:
                                pos_header[key] = str(self.settings.tracker_params[&#39;BottomBorder&#39;])
                pos_header[&#39;duration&#39;] = str(int(self.last_pos_ts - self.first_pos_ts))
                # Rest of this stuff probably won&#39;t change so should be defaulted in the loaded file
                # (see axonaIO.py)
                pos_header[&#39;num_colours&#39;] = &#39;4&#39;
                pos_header[&#39;sw_version&#39;] = &#39;1.2.2.1&#39;
                pos_header[&#39;timebase&#39;] = &#39;50 hz&#39;
                pos_header[&#39;sample_rate&#39;] = &#39;50.0 hz&#39;
                pos_header[&#39;pos_format&#39;] = &#39;t,x1,y1,x2,y2,numpix1,numpix2&#39;
                pos_header[&#39;bytes_per_coord&#39;] = &#39;2&#39;
                pos_header[&#39;EEG_samples_per_position&#39;] = &#39;5&#39;
                pos_header[&#39;bytes_per_timestamp&#39;] = &#39;4&#39;
                pos_header[&#39;pixels_per_metre&#39;] = str(ppm)
                pos_header[&#39;num_pos_samples&#39;] = str(len(axona_pos_data))
                pos_header[&#39;bearing_colour_1&#39;] = &#39;210&#39;
                pos_header[&#39;bearing_colour_2&#39;] = &#39;30&#39;
                pos_header[&#39;bearing_colour_3&#39;] = &#39;0&#39;
                pos_header[&#39;bearing_colour_4&#39;] = &#39;0&#39;
                pos_header[&#39;pixels_per_metre&#39;] = str(ppm)

                self.writePos2AxonaFormat(pos_header, axona_pos_data)
                print(&#34;Exported position data to Axona format&#34;)

        def exportSpikes(self):
                print(&#34;Beginning conversion of spiking data...&#34;)
                self.convertSpikeData(self.OE_data.nwbData[&#39;acquisition&#39;][&#39;timeseries&#39;][self.recording_name][&#39;spikes&#39;])
                print(&#34;Completed exporting spiking data&#34;)

        def exportLFP(self, channel: int, lfp_type: str, gain: int):
                &#39;&#39;&#39;
                Export LFP data to file

                Parameters
                -----------
                channel - int
                lfp_type - str. Legal values are &#39;egf&#39; or &#39;eeg&#39;
                gain - int. Multiplier for the lfp data
                &#39;&#39;&#39;
                print(&#34;Beginning conversion and exporting of LFP data...&#34;)
                if self.settings.fpga_nodeId is None:
                        self.settings.parse()
                fpgaNode = &#39;processor&#39; + str(self.settings.fpga_nodeId) + &#39;_&#39; + str(self.settings.fpga_nodeId)
                data = self.OE_data.nwbData[&#39;acquisition&#39;][&#39;timeseries&#39;][self.recording_name][&#39;continuous&#39;][fpgaNode][&#39;data&#39;][:, channel]
                self.makeLFPData(data, eeg_type=lfp_type, gain=gain)
                # if the set file has been created then update which channel contains the eeg record so
                # that the gain can be loaded correctly when using dacq2py_util

                print(&#34;Completed exporting LFP data to &#34; + lfp_type + &#34; format&#34;)

        def convertPosData(self, xy: np.array, xy_ts: np.array) -&gt; np.array:
                &#39;&#39;&#39;
                Perform the conversion of the array parts of the data
                NB As well as upsampling the data to the Axona pos sampling rate (50Hz)
                we have to insert some columns into the pos array as Axona format expects it like:
                pos_format: t,x1,y1,x2,y2,numpix1,numpix2
                We can make up some of the info and ignore other bits
                &#39;&#39;&#39;
                n_new_pts = int(np.floor((self.last_pos_ts-self.first_pos_ts) * 50))
                t = xy_ts - self.first_pos_ts
                new_ts = np.linspace(t[0], t[-1], n_new_pts)
                new_x = np.interp(new_ts, t, xy[:, 0])
                new_y = np.interp(new_ts, t, xy[:, 1])
                # Expand the pos bit of the data to be returned to make it look like Axona data
                new_pos = np.vstack([new_x, new_y]).T
                new_pos = np.c_[new_pos, np.ones_like(new_pos) * 1023, np.zeros_like(new_pos), np.zeros_like(new_pos)]
                new_pos[:, 4] = 40 # just made this value up - it&#39;s numpix i think
                new_pos[:, 6] = 40 # same
                # Squeeze this data into Axona pos format array
                dt = self.AxonaData.axona_files[&#39;.pos&#39;]
                new_data = np.zeros(n_new_pts, dtype=dt)
                # Timestamps in Axona are time in seconds * sample_rate
                new_data[&#39;ts&#39;] = new_ts * 50
                new_data[&#39;pos&#39;] = new_pos
                return new_data

        def convertSpikeData(self, hdf5_tetrode_data: h5py._hl.group.Group):
                &#39;&#39;&#39;
                Does the spike conversion from OE Spike Sorter format to Axona format tetrode files

                Parameters
                -----------
                hdf5_tetrode_data - h5py._hl.group.Group - this kind of looks like a dictionary and can, it seems,
                                                                be treated as one more or less (see http://docs.h5py.org/en/stable/high/group.html).
                &#39;&#39;&#39;
                # First lets get the datatype for tetrode files as this will be the same for all tetrodes...
                dt = self.AxonaData.axona_files[&#39;.1&#39;]
                # ... and a basic header for the tetrode file that use for each tetrode file, changing only the num_spikes value
                header = self.AxonaData.getEmptyHeader(&#34;tetrode&#34;)
                header[&#39;duration&#39;] = str(int(self.last_pos_ts-self.first_pos_ts))
                header[&#39;sw_version&#39;] = &#39;1.1.0&#39;
                header[&#39;num_chans&#39;] = &#39;4&#39;
                header[&#39;timebase&#39;] = &#39;96000 hz&#39;
                header[&#39;bytes_per_timestamp&#39;] = &#39;4&#39;
                header[&#39;samples_per_spike&#39;] = &#39;50&#39;
                header[&#39;sample_rate&#39;] = &#39;48000 hz&#39;
                header[&#39;bytes_per_sample&#39;] = &#39;1&#39;
                header[&#39;spike_format&#39;] = &#39;t,ch1,t,ch2,t,ch3,t,ch4&#39;

                for key in hdf5_tetrode_data.keys():
                        spiking_data = np.array(hdf5_tetrode_data[key].get(&#39;data&#39;))
                        timestamps = np.array(hdf5_tetrode_data[key].get(&#39;timestamps&#39;))
                        # check if any of the spiking data is captured before/ after the first/ last bit of position data
                        # if there is then discard this as we potentially have no valid position to align the spike to :(
                        idx = np.logical_or(timestamps &lt; self.first_pos_ts, timestamps &gt; self.last_pos_ts)
                        spiking_data = spiking_data[~idx, :, :]
                        timestamps = timestamps[~idx]
                        # subtract the first pos timestamp from the spiking timestamps
                        timestamps = timestamps - self.first_pos_ts
                        # get the number of spikes here for use below in the header
                        num_spikes = len(timestamps)
                        # repeat the timestamps in tetrode multiples ready for Axona export
                        new_timestamps = np.repeat(timestamps, 4)
                        new_spiking_data = spiking_data.astype(np.float64)
                        # Convert to microvolts...
                        new_spiking_data = new_spiking_data * self.bitvolts
                        # And upsample the spikes...
                        new_spiking_data = self.resample(new_spiking_data, 4, 5, -1)
                        # ... and scale appropriately for Axona and invert as OE seems to be inverted wrt Axona
                        new_spiking_data = new_spiking_data / (self.hp_gain/4/128.0) * (-1)
                        # ... scale them to the gains specified somewhere (not sure where / how to do this yet)
                        shp = new_spiking_data.shape
                        # then reshape them as Axona wants them a bit differently
                        new_spiking_data = np.reshape(new_spiking_data, [shp[0] * shp[1], shp[2]])
                        # Cap any values outside the range of int8
                        new_spiking_data[new_spiking_data &lt; -128] = -128
                        new_spiking_data[new_spiking_data &gt; 127] = 127
                        # create the new array
                        new_tetrode_data = np.zeros(len(new_timestamps), dtype=dt)
                        new_tetrode_data[&#39;ts&#39;] = new_timestamps * 96000
                        new_tetrode_data[&#39;waveform&#39;] = new_spiking_data
                        # change the header num_spikes field
                        header[&#39;num_spikes&#39;] = str(num_spikes)
                        i_tetnum = key.split(&#39;electrode&#39;)[1]
                        print(&#34;Exporting tetrode {}&#34;.format(i_tetnum))
                        self.writeTetrodeData(i_tetnum, header, new_tetrode_data)

        def makeLFPData(self, hdf5_continuous_data: np.array, eeg_type=&#39;eeg&#39;, gain=5000):
                &#39;&#39;&#39;
                Downsamples the data in hdf5_continuous_data and saves the result
                as either an egf or eeg file depending on the choice of either eeg_type which can
                take a value of either &#39;egf&#39; or &#39;eeg&#39;
                gain is the scaling factor

                Parameters
                ----------
                hdf5_continuous_data - np.array with dtype as np.int16
                &#39;&#39;&#39;
                if eeg_type == &#39;eeg&#39;:
                        dt = self.AxonaData.axona_files[&#39;.eeg&#39;]
                        header = self.AxonaData.getEmptyHeader(&#34;eeg&#34;)
                        header[&#39;EEG_samples_per_position&#39;] = &#39;5&#39;
                        header[&#39;sample_rate&#39;] = &#39;250.0 hz&#39;
                        header[&#39;bytes_per_sample&#39;] = &#39;1&#39;
                        dst_rate = 250
                        sample_key = &#39;num_EEG_samples&#39;
                elif eeg_type == &#39;egf&#39;:
                        dt = self.AxonaData.axona_files[&#39;.egf&#39;]
                        header = self.AxonaData.getEmptyHeader(&#34;egf&#34;)
                        header[&#39;sample_rate&#39;] = &#39;4800 hz&#39;
                        header[&#39;bytes_per_sample&#39;] = &#39;2&#39;
                        dst_rate = 4800
                        sample_key = &#39;num_EGF_samples&#39;
                header[&#39;duration&#39;] = str(int(self.last_pos_ts-self.first_pos_ts))
                header[&#39;sw_version&#39;] = &#39;1.1.0&#39;
                header[&#39;num_chans&#39;] = &#39;1&#39;

                # hdf5_continuous_data = hdf5_continuous_data * (self.bitvolts * 1000) / gain
                lfp_data = self.resample(hdf5_continuous_data, 30000, dst_rate, -1)
                # make sure data is same length as sample_rate * duration
                nsamples = int(dst_rate * int(header[&#39;duration&#39;]))
                lfp_data = lfp_data[0:nsamples]
                lfp_data = self.__filterLFP__(lfp_data, dst_rate)
                # convert the data format
                # lfp_data = lfp_data * self.bitvolts # in microvolts

                if eeg_type == &#39;eeg&#39;:
                        # probably BROKEN
                        lfp_data = lfp_data / 32768. # lfp_data starts out as int16 (see Parameters above)
                        lfp_data = lfp_data * gain
                        # cap the values at either end...
                        lfp_data[lfp_data &lt; -128] = -128
                        lfp_data[lfp_data &gt; 127] = 127
                        # and convert to int8
                        lfp_data = lfp_data.astype(np.int8)

                elif eeg_type == &#39;egf&#39;:
                        # probably works
                        # lfp_data = lfp_data / 256.
                        lfp_data = lfp_data.astype(np.int16)

                header[sample_key] = str(len(lfp_data))
                self.writeLFP2AxonaFormat(header, lfp_data, eeg_type)

        def makeSetData(self, lfp_channel=1, **kwargs):
                if self.OE_data is None:
                        self.getOEData(self.filename_root) # to get the timestamps for duration key
                header = self.AxonaData.getEmptyHeader(&#34;set&#34;)
                # set some reasonable default values
                from ephysiopy import __version__
                header[&#39;sw_version&#39;] = __version__
                header[&#39;ADC_fullscale_mv&#39;] = &#39;0.195&#39;
                header[&#39;tracker_version&#39;] = &#39;1.1.0&#39;

                for k, v in header.items():
                        if &#39;gain&#39; in k:
                                header[k] = str(self.hp_gain)
                        if &#39;collectMask&#39; in k:
                                header[k] = &#39;0&#39;
                        if &#39;EEG_ch_1&#39; in k:
                                if lfp_channel is not None:
                                        header[k] = str(lfp_channel)
                        if &#39;mode_ch_&#39; in k:
                                header[k] = &#39;0&#39;
                # iterate again to make sure lfp gain set correctly
                for k, v in header.items():
                        if lfp_channel is not None:
                                if k == &#39;gain_ch_&#39; + str(lfp_channel):
                                        header[k] = str(self.lp_gain)

                # Based on the data in the electrodes dict of the OESettings instance (self.settings - see __init__)
                # determine which tetrodes we can let Tint load
                # make sure we&#39;ve parsed the electrodes
                self.settings.parseSpikeSorter()
                if self.settings.electrodes:
                        for k, v in self.settings.electrodes.items():
                                header[&#39;collectMask_&#39; + str(k)] = &#39;1&#39;
                if self.lfp_channel is not None:
                        for chan in self.tetrodes:
                                key = &#39;collectMask_&#39; + str(chan)
                                header[key] = &#39;1&#39;
                header[&#39;colactive_1&#39;] = &#39;1&#39;
                header[&#39;colactive_2&#39;] = &#39;0&#39;
                header[&#39;colactive_3&#39;] = &#39;0&#39;
                header[&#39;colactive_4&#39;] = &#39;0&#39;
                header[&#39;colmap_algorithm&#39;] = &#39;1&#39;
                header[&#39;duration&#39;] = str(int(self.last_pos_ts-self.first_pos_ts))
                self.writeSetData(header)

        def __filterLFP__(self, data: np.array, sample_rate: int):
                from scipy.signal import firwin, filtfilt
                if self.fs is None:
                        from ephysiopy import fs
                        self.fs = fs
                if self.lfp_lowcut is None:
                        from ephysiopy import lfp_lowcut
                        self.lfp_lowcut = lfp_lowcut
                if self.lfp_highcut is None:
                        from ephysiopy import lfp_highcut
                        self.lfp_highcut = lfp_highcut
                nyq = sample_rate / 2.
                lowcut = self.lfp_lowcut / nyq
                highcut = self.lfp_highcut / nyq
                if highcut &gt;= 1.0:
                        highcut = 1.0 - np.finfo(float).eps
                if lowcut &lt;= 0.0:
                        lowcut = np.finfo(float).eps
                b = firwin(sample_rate+1, [lowcut, highcut], window=&#39;black&#39;, pass_zero=False)
                y = filtfilt(b, [1], data.ravel(), padtype=&#39;odd&#39;)
                return y

        def writeLFP2AxonaFormat(self, header: dict, data: np.array, eeg_type=&#39;eeg&#39;):
                self.AxonaData.setHeader(self.axona_root_name + &#34;.&#34; + eeg_type, header)
                self.AxonaData.setData(self.axona_root_name + &#34;.&#34; + eeg_type, data)

        def writePos2AxonaFormat(self, header:  dict, data: np.array):
                self.AxonaData.setHeader(self.axona_root_name + &#34;.pos&#34;, header)
                self.AxonaData.setData(self.axona_root_name + &#34;.pos&#34;, data)

        def writeTetrodeData(self, tetnum: str, header: dict, data: np.array):
                self.AxonaData.setHeader(self.axona_root_name + &#34;.&#34; + tetnum, header)
                self.AxonaData.setData(self.axona_root_name + &#34;.&#34; + tetnum, data)

        def writeSetData(self, header: dict):
                self.AxonaData.setHeader(self.axona_root_name + &#34;.set&#34;, header)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="ephysiopy.format_converters.OE_Axona.OE2Axona.settings"><code class="name">var <span class="ident">settings</span></code></dt>
<dd>
<section class="desc"><p>Loads the settings data from the settings.xml file</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def settings(self):
        &#39;&#39;&#39;
        Loads the settings data from the settings.xml file
        &#39;&#39;&#39;
        if self._settings is None:
                self._settings = OESettings.Settings(self.dirname)
        return self._settings</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ephysiopy.format_converters.OE_Axona.OE2Axona.convertPosData"><code class="name flex">
<span>def <span class="ident">convertPosData</span></span>(<span>self, xy, xy_ts)</span>
</code></dt>
<dd>
<section class="desc"><p>Perform the conversion of the array parts of the data
NB As well as upsampling the data to the Axona pos sampling rate (50Hz)
we have to insert some columns into the pos array as Axona format expects it like:
pos_format: t,x1,y1,x2,y2,numpix1,numpix2
We can make up some of the info and ignore other bits</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convertPosData(self, xy: np.array, xy_ts: np.array) -&gt; np.array:
        &#39;&#39;&#39;
        Perform the conversion of the array parts of the data
        NB As well as upsampling the data to the Axona pos sampling rate (50Hz)
        we have to insert some columns into the pos array as Axona format expects it like:
        pos_format: t,x1,y1,x2,y2,numpix1,numpix2
        We can make up some of the info and ignore other bits
        &#39;&#39;&#39;
        n_new_pts = int(np.floor((self.last_pos_ts-self.first_pos_ts) * 50))
        t = xy_ts - self.first_pos_ts
        new_ts = np.linspace(t[0], t[-1], n_new_pts)
        new_x = np.interp(new_ts, t, xy[:, 0])
        new_y = np.interp(new_ts, t, xy[:, 1])
        # Expand the pos bit of the data to be returned to make it look like Axona data
        new_pos = np.vstack([new_x, new_y]).T
        new_pos = np.c_[new_pos, np.ones_like(new_pos) * 1023, np.zeros_like(new_pos), np.zeros_like(new_pos)]
        new_pos[:, 4] = 40 # just made this value up - it&#39;s numpix i think
        new_pos[:, 6] = 40 # same
        # Squeeze this data into Axona pos format array
        dt = self.AxonaData.axona_files[&#39;.pos&#39;]
        new_data = np.zeros(n_new_pts, dtype=dt)
        # Timestamps in Axona are time in seconds * sample_rate
        new_data[&#39;ts&#39;] = new_ts * 50
        new_data[&#39;pos&#39;] = new_pos
        return new_data</code></pre>
</details>
</dd>
<dt id="ephysiopy.format_converters.OE_Axona.OE2Axona.convertSpikeData"><code class="name flex">
<span>def <span class="ident">convertSpikeData</span></span>(<span>self, hdf5_tetrode_data)</span>
</code></dt>
<dd>
<section class="desc"><p>Does the spike conversion from OE Spike Sorter format to Axona format tetrode files</p>
<h2 id="parameters">Parameters</h2>
<p>hdf5_tetrode_data - h5py._hl.group.Group - this kind of looks like a dictionary and can, it seems,
be treated as one more or less (see <a href="http://docs.h5py.org/en/stable/high/group.html">http://docs.h5py.org/en/stable/high/group.html</a>).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convertSpikeData(self, hdf5_tetrode_data: h5py._hl.group.Group):
        &#39;&#39;&#39;
        Does the spike conversion from OE Spike Sorter format to Axona format tetrode files

        Parameters
        -----------
        hdf5_tetrode_data - h5py._hl.group.Group - this kind of looks like a dictionary and can, it seems,
                                                        be treated as one more or less (see http://docs.h5py.org/en/stable/high/group.html).
        &#39;&#39;&#39;
        # First lets get the datatype for tetrode files as this will be the same for all tetrodes...
        dt = self.AxonaData.axona_files[&#39;.1&#39;]
        # ... and a basic header for the tetrode file that use for each tetrode file, changing only the num_spikes value
        header = self.AxonaData.getEmptyHeader(&#34;tetrode&#34;)
        header[&#39;duration&#39;] = str(int(self.last_pos_ts-self.first_pos_ts))
        header[&#39;sw_version&#39;] = &#39;1.1.0&#39;
        header[&#39;num_chans&#39;] = &#39;4&#39;
        header[&#39;timebase&#39;] = &#39;96000 hz&#39;
        header[&#39;bytes_per_timestamp&#39;] = &#39;4&#39;
        header[&#39;samples_per_spike&#39;] = &#39;50&#39;
        header[&#39;sample_rate&#39;] = &#39;48000 hz&#39;
        header[&#39;bytes_per_sample&#39;] = &#39;1&#39;
        header[&#39;spike_format&#39;] = &#39;t,ch1,t,ch2,t,ch3,t,ch4&#39;

        for key in hdf5_tetrode_data.keys():
                spiking_data = np.array(hdf5_tetrode_data[key].get(&#39;data&#39;))
                timestamps = np.array(hdf5_tetrode_data[key].get(&#39;timestamps&#39;))
                # check if any of the spiking data is captured before/ after the first/ last bit of position data
                # if there is then discard this as we potentially have no valid position to align the spike to :(
                idx = np.logical_or(timestamps &lt; self.first_pos_ts, timestamps &gt; self.last_pos_ts)
                spiking_data = spiking_data[~idx, :, :]
                timestamps = timestamps[~idx]
                # subtract the first pos timestamp from the spiking timestamps
                timestamps = timestamps - self.first_pos_ts
                # get the number of spikes here for use below in the header
                num_spikes = len(timestamps)
                # repeat the timestamps in tetrode multiples ready for Axona export
                new_timestamps = np.repeat(timestamps, 4)
                new_spiking_data = spiking_data.astype(np.float64)
                # Convert to microvolts...
                new_spiking_data = new_spiking_data * self.bitvolts
                # And upsample the spikes...
                new_spiking_data = self.resample(new_spiking_data, 4, 5, -1)
                # ... and scale appropriately for Axona and invert as OE seems to be inverted wrt Axona
                new_spiking_data = new_spiking_data / (self.hp_gain/4/128.0) * (-1)
                # ... scale them to the gains specified somewhere (not sure where / how to do this yet)
                shp = new_spiking_data.shape
                # then reshape them as Axona wants them a bit differently
                new_spiking_data = np.reshape(new_spiking_data, [shp[0] * shp[1], shp[2]])
                # Cap any values outside the range of int8
                new_spiking_data[new_spiking_data &lt; -128] = -128
                new_spiking_data[new_spiking_data &gt; 127] = 127
                # create the new array
                new_tetrode_data = np.zeros(len(new_timestamps), dtype=dt)
                new_tetrode_data[&#39;ts&#39;] = new_timestamps * 96000
                new_tetrode_data[&#39;waveform&#39;] = new_spiking_data
                # change the header num_spikes field
                header[&#39;num_spikes&#39;] = str(num_spikes)
                i_tetnum = key.split(&#39;electrode&#39;)[1]
                print(&#34;Exporting tetrode {}&#34;.format(i_tetnum))
                self.writeTetrodeData(i_tetnum, header, new_tetrode_data)</code></pre>
</details>
</dd>
<dt id="ephysiopy.format_converters.OE_Axona.OE2Axona.exportLFP"><code class="name flex">
<span>def <span class="ident">exportLFP</span></span>(<span>self, channel, lfp_type, gain)</span>
</code></dt>
<dd>
<section class="desc"><p>Export LFP data to file</p>
<h2 id="parameters">Parameters</h2>
<p>channel - int
lfp_type - str. Legal values are 'egf' or 'eeg'
gain - int. Multiplier for the lfp data</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exportLFP(self, channel: int, lfp_type: str, gain: int):
        &#39;&#39;&#39;
        Export LFP data to file

        Parameters
        -----------
        channel - int
        lfp_type - str. Legal values are &#39;egf&#39; or &#39;eeg&#39;
        gain - int. Multiplier for the lfp data
        &#39;&#39;&#39;
        print(&#34;Beginning conversion and exporting of LFP data...&#34;)
        if self.settings.fpga_nodeId is None:
                self.settings.parse()
        fpgaNode = &#39;processor&#39; + str(self.settings.fpga_nodeId) + &#39;_&#39; + str(self.settings.fpga_nodeId)
        data = self.OE_data.nwbData[&#39;acquisition&#39;][&#39;timeseries&#39;][self.recording_name][&#39;continuous&#39;][fpgaNode][&#39;data&#39;][:, channel]
        self.makeLFPData(data, eeg_type=lfp_type, gain=gain)
        # if the set file has been created then update which channel contains the eeg record so
        # that the gain can be loaded correctly when using dacq2py_util

        print(&#34;Completed exporting LFP data to &#34; + lfp_type + &#34; format&#34;)</code></pre>
</details>
</dd>
<dt id="ephysiopy.format_converters.OE_Axona.OE2Axona.exportPos"><code class="name flex">
<span>def <span class="ident">exportPos</span></span>(<span>self, ppm=300, jumpmax=100, as_text=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exportPos(self, ppm=300, jumpmax=100, as_text=False):
        #
        # Step 1) Deal with the position data first:
        #
        # Grab the settings of the pos tracker and do some post-processing on the position
        # data (discard jumpy data, do some smoothing etc)
        # settings = OESettings.Settings(os.path.join(self.dirname, &#39;settings.xml&#39;))
        self.settings.parsePos()
        posProcessor = PosCalcsGeneric(self.OE_data.xy[:,0], self.OE_data.xy[:,1], ppm, True, jumpmax)
        print(&#34;Post-processing position data...&#34;)
        xy, _ = posProcessor.postprocesspos(self.settings.tracker_params)
        xy = xy.T
        if as_text is True:
                print(&#34;Beginning export of position data to text format...&#34;)
                pos_file_name = self.axona_root_name + &#34;.txt&#34;
                np.savetxt(pos_file_name, self.OE_data.xy, fmt=&#39;%1.u&#39;)
                print(&#34;Completed export of position data&#34;)
                return
        # Do the upsampling of both xy and the timestamps
        print(&#34;Beginning export of position data to Axona format...&#34;)
        axona_pos_file_name = self.axona_root_name + &#34;.pos&#34;
        axona_pos_data = self.convertPosData(xy, self.OE_data.xyTS)
        # make sure pos data length is same as duration * num_samples
        axona_pos_data = axona_pos_data[0:int(self.last_pos_ts - self.first_pos_ts)*50]
        # Create an empty header for the pos data
        pos_header = self.AxonaData.getEmptyHeader(&#34;pos&#34;)
        for key in pos_header.keys():
                if &#39;min_x&#39; in key:
                        pos_header[key] = str(self.settings.tracker_params[&#39;LeftBorder&#39;])
                if &#39;min_y&#39; in key:
                        pos_header[key] = str(self.settings.tracker_params[&#39;TopBorder&#39;])
                if &#39;max_x&#39; in key:
                        pos_header[key] = str(self.settings.tracker_params[&#39;RightBorder&#39;])
                if &#39;max_y&#39; in key:
                        pos_header[key] = str(self.settings.tracker_params[&#39;BottomBorder&#39;])
        pos_header[&#39;duration&#39;] = str(int(self.last_pos_ts - self.first_pos_ts))
        # Rest of this stuff probably won&#39;t change so should be defaulted in the loaded file
        # (see axonaIO.py)
        pos_header[&#39;num_colours&#39;] = &#39;4&#39;
        pos_header[&#39;sw_version&#39;] = &#39;1.2.2.1&#39;
        pos_header[&#39;timebase&#39;] = &#39;50 hz&#39;
        pos_header[&#39;sample_rate&#39;] = &#39;50.0 hz&#39;
        pos_header[&#39;pos_format&#39;] = &#39;t,x1,y1,x2,y2,numpix1,numpix2&#39;
        pos_header[&#39;bytes_per_coord&#39;] = &#39;2&#39;
        pos_header[&#39;EEG_samples_per_position&#39;] = &#39;5&#39;
        pos_header[&#39;bytes_per_timestamp&#39;] = &#39;4&#39;
        pos_header[&#39;pixels_per_metre&#39;] = str(ppm)
        pos_header[&#39;num_pos_samples&#39;] = str(len(axona_pos_data))
        pos_header[&#39;bearing_colour_1&#39;] = &#39;210&#39;
        pos_header[&#39;bearing_colour_2&#39;] = &#39;30&#39;
        pos_header[&#39;bearing_colour_3&#39;] = &#39;0&#39;
        pos_header[&#39;bearing_colour_4&#39;] = &#39;0&#39;
        pos_header[&#39;pixels_per_metre&#39;] = str(ppm)

        self.writePos2AxonaFormat(pos_header, axona_pos_data)
        print(&#34;Exported position data to Axona format&#34;)</code></pre>
</details>
</dd>
<dt id="ephysiopy.format_converters.OE_Axona.OE2Axona.exportSetFile"><code class="name flex">
<span>def <span class="ident">exportSetFile</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Wrapper for makeSetData below</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exportSetFile(self, **kwargs):
        &#39;&#39;&#39;
        Wrapper for makeSetData below
        &#39;&#39;&#39;
        print(&#34;Exporting set file data...&#34;)
        self.makeSetData(kwargs)
        print(&#34;Done exporting set file.&#34;)</code></pre>
</details>
</dd>
<dt id="ephysiopy.format_converters.OE_Axona.OE2Axona.exportSpikes"><code class="name flex">
<span>def <span class="ident">exportSpikes</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exportSpikes(self):
        print(&#34;Beginning conversion of spiking data...&#34;)
        self.convertSpikeData(self.OE_data.nwbData[&#39;acquisition&#39;][&#39;timeseries&#39;][self.recording_name][&#39;spikes&#39;])
        print(&#34;Completed exporting spiking data&#34;)</code></pre>
</details>
</dd>
<dt id="ephysiopy.format_converters.OE_Axona.OE2Axona.getOEData"><code class="name flex">
<span>def <span class="ident">getOEData</span></span>(<span>self, filename_root, recording_name='recording1')</span>
</code></dt>
<dd>
<section class="desc"><p>Loads the nwb file names in filename_root and returns a dict containing some of the nwb data
relevant for converting to Axona file formats</p>
<h2 id="parameters">Parameters</h2>
<p>filename_root - fuly qualified name of the nwb file
recording_name - the name of the recording in the nwb file NB the default has changed in different versions of OE from 'recording0' to 'recording1'</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getOEData(self, filename_root: str, recording_name=&#39;recording1&#39;)-&gt;dict:
        &#39;&#39;&#39;
        Loads the nwb file names in filename_root and returns a dict containing some of the nwb data
        relevant for converting to Axona file formats

        Parameters
        ----------------
        filename_root - fuly qualified name of the nwb file
        recording_name - the name of the recording in the nwb file NB the default has changed in different versions of OE from &#39;recording0&#39; to &#39;recording1&#39;
        &#39;&#39;&#39;
        if os.path.isfile(filename_root):
                root_filename = os.path.splitext(self.experiment_name)[0]
                OE_data = OEKiloPhy.OpenEphysNWB(self.dirname)
                print(&#34;Loading nwb data...&#34;)
                OE_data.load(pname_root=self.dirname, session_name=self.experiment_name, recording_name=recording_name, loadspikes=True, loadraw=False)
                print(&#34;Loaded nwb data from: {}&#34;.format(filename_root))
                # It&#39;s likely that spikes have been collected after the last position sample
                # due to buffering issues I can&#39;t be bothered to resolve. Get the last pos
                # timestamps here and check that spikes don&#39;t go beyond this when writing data
                # out later
                # Also the pos and spike data timestamps almost never start at 0 as the user
                # usually acquires data for a while before recording. Grab the first timestamp
                # here with a view to subtracting this from everything (including the spike data)
                # and figuring out what to keep later
                first_pos_ts = OE_data.xyTS[0]
                last_pos_ts = OE_data.xyTS[-1]
                self.first_pos_ts = first_pos_ts
                self.last_pos_ts = last_pos_ts
                self.recording_name = recording_name
                self.OE_data = OE_data
                return OE_data</code></pre>
</details>
</dd>
<dt id="ephysiopy.format_converters.OE_Axona.OE2Axona.makeLFPData"><code class="name flex">
<span>def <span class="ident">makeLFPData</span></span>(<span>self, hdf5_continuous_data, eeg_type='eeg', gain=5000)</span>
</code></dt>
<dd>
<section class="desc"><p>Downsamples the data in hdf5_continuous_data and saves the result
as either an egf or eeg file depending on the choice of either eeg_type which can
take a value of either 'egf' or 'eeg'
gain is the scaling factor</p>
<h2 id="parameters">Parameters</h2>
<p>hdf5_continuous_data - np.array with dtype as np.int16</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makeLFPData(self, hdf5_continuous_data: np.array, eeg_type=&#39;eeg&#39;, gain=5000):
        &#39;&#39;&#39;
        Downsamples the data in hdf5_continuous_data and saves the result
        as either an egf or eeg file depending on the choice of either eeg_type which can
        take a value of either &#39;egf&#39; or &#39;eeg&#39;
        gain is the scaling factor

        Parameters
        ----------
        hdf5_continuous_data - np.array with dtype as np.int16
        &#39;&#39;&#39;
        if eeg_type == &#39;eeg&#39;:
                dt = self.AxonaData.axona_files[&#39;.eeg&#39;]
                header = self.AxonaData.getEmptyHeader(&#34;eeg&#34;)
                header[&#39;EEG_samples_per_position&#39;] = &#39;5&#39;
                header[&#39;sample_rate&#39;] = &#39;250.0 hz&#39;
                header[&#39;bytes_per_sample&#39;] = &#39;1&#39;
                dst_rate = 250
                sample_key = &#39;num_EEG_samples&#39;
        elif eeg_type == &#39;egf&#39;:
                dt = self.AxonaData.axona_files[&#39;.egf&#39;]
                header = self.AxonaData.getEmptyHeader(&#34;egf&#34;)
                header[&#39;sample_rate&#39;] = &#39;4800 hz&#39;
                header[&#39;bytes_per_sample&#39;] = &#39;2&#39;
                dst_rate = 4800
                sample_key = &#39;num_EGF_samples&#39;
        header[&#39;duration&#39;] = str(int(self.last_pos_ts-self.first_pos_ts))
        header[&#39;sw_version&#39;] = &#39;1.1.0&#39;
        header[&#39;num_chans&#39;] = &#39;1&#39;

        # hdf5_continuous_data = hdf5_continuous_data * (self.bitvolts * 1000) / gain
        lfp_data = self.resample(hdf5_continuous_data, 30000, dst_rate, -1)
        # make sure data is same length as sample_rate * duration
        nsamples = int(dst_rate * int(header[&#39;duration&#39;]))
        lfp_data = lfp_data[0:nsamples]
        lfp_data = self.__filterLFP__(lfp_data, dst_rate)
        # convert the data format
        # lfp_data = lfp_data * self.bitvolts # in microvolts

        if eeg_type == &#39;eeg&#39;:
                # probably BROKEN
                lfp_data = lfp_data / 32768. # lfp_data starts out as int16 (see Parameters above)
                lfp_data = lfp_data * gain
                # cap the values at either end...
                lfp_data[lfp_data &lt; -128] = -128
                lfp_data[lfp_data &gt; 127] = 127
                # and convert to int8
                lfp_data = lfp_data.astype(np.int8)

        elif eeg_type == &#39;egf&#39;:
                # probably works
                # lfp_data = lfp_data / 256.
                lfp_data = lfp_data.astype(np.int16)

        header[sample_key] = str(len(lfp_data))
        self.writeLFP2AxonaFormat(header, lfp_data, eeg_type)</code></pre>
</details>
</dd>
<dt id="ephysiopy.format_converters.OE_Axona.OE2Axona.makeSetData"><code class="name flex">
<span>def <span class="ident">makeSetData</span></span>(<span>self, lfp_channel=1, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makeSetData(self, lfp_channel=1, **kwargs):
        if self.OE_data is None:
                self.getOEData(self.filename_root) # to get the timestamps for duration key
        header = self.AxonaData.getEmptyHeader(&#34;set&#34;)
        # set some reasonable default values
        from ephysiopy import __version__
        header[&#39;sw_version&#39;] = __version__
        header[&#39;ADC_fullscale_mv&#39;] = &#39;0.195&#39;
        header[&#39;tracker_version&#39;] = &#39;1.1.0&#39;

        for k, v in header.items():
                if &#39;gain&#39; in k:
                        header[k] = str(self.hp_gain)
                if &#39;collectMask&#39; in k:
                        header[k] = &#39;0&#39;
                if &#39;EEG_ch_1&#39; in k:
                        if lfp_channel is not None:
                                header[k] = str(lfp_channel)
                if &#39;mode_ch_&#39; in k:
                        header[k] = &#39;0&#39;
        # iterate again to make sure lfp gain set correctly
        for k, v in header.items():
                if lfp_channel is not None:
                        if k == &#39;gain_ch_&#39; + str(lfp_channel):
                                header[k] = str(self.lp_gain)

        # Based on the data in the electrodes dict of the OESettings instance (self.settings - see __init__)
        # determine which tetrodes we can let Tint load
        # make sure we&#39;ve parsed the electrodes
        self.settings.parseSpikeSorter()
        if self.settings.electrodes:
                for k, v in self.settings.electrodes.items():
                        header[&#39;collectMask_&#39; + str(k)] = &#39;1&#39;
        if self.lfp_channel is not None:
                for chan in self.tetrodes:
                        key = &#39;collectMask_&#39; + str(chan)
                        header[key] = &#39;1&#39;
        header[&#39;colactive_1&#39;] = &#39;1&#39;
        header[&#39;colactive_2&#39;] = &#39;0&#39;
        header[&#39;colactive_3&#39;] = &#39;0&#39;
        header[&#39;colactive_4&#39;] = &#39;0&#39;
        header[&#39;colmap_algorithm&#39;] = &#39;1&#39;
        header[&#39;duration&#39;] = str(int(self.last_pos_ts-self.first_pos_ts))
        self.writeSetData(header)</code></pre>
</details>
</dd>
<dt id="ephysiopy.format_converters.OE_Axona.OE2Axona.resample"><code class="name flex">
<span>def <span class="ident">resample</span></span>(<span>self, data, src_rate=30, dst_rate=50, axis=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Upsamples data using FFT</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resample(self, data, src_rate=30, dst_rate=50, axis=0):
        &#39;&#39;&#39;
        Upsamples data using FFT
        &#39;&#39;&#39;
        denom = np.gcd(dst_rate, src_rate)
        new_data = signal.resample_poly(data, dst_rate/denom, src_rate/denom, axis)
        return new_data</code></pre>
</details>
</dd>
<dt id="ephysiopy.format_converters.OE_Axona.OE2Axona.writeLFP2AxonaFormat"><code class="name flex">
<span>def <span class="ident">writeLFP2AxonaFormat</span></span>(<span>self, header, data, eeg_type='eeg')</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writeLFP2AxonaFormat(self, header: dict, data: np.array, eeg_type=&#39;eeg&#39;):
        self.AxonaData.setHeader(self.axona_root_name + &#34;.&#34; + eeg_type, header)
        self.AxonaData.setData(self.axona_root_name + &#34;.&#34; + eeg_type, data)</code></pre>
</details>
</dd>
<dt id="ephysiopy.format_converters.OE_Axona.OE2Axona.writePos2AxonaFormat"><code class="name flex">
<span>def <span class="ident">writePos2AxonaFormat</span></span>(<span>self, header, data)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writePos2AxonaFormat(self, header:  dict, data: np.array):
        self.AxonaData.setHeader(self.axona_root_name + &#34;.pos&#34;, header)
        self.AxonaData.setData(self.axona_root_name + &#34;.pos&#34;, data)</code></pre>
</details>
</dd>
<dt id="ephysiopy.format_converters.OE_Axona.OE2Axona.writeSetData"><code class="name flex">
<span>def <span class="ident">writeSetData</span></span>(<span>self, header)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writeSetData(self, header: dict):
        self.AxonaData.setHeader(self.axona_root_name + &#34;.set&#34;, header)</code></pre>
</details>
</dd>
<dt id="ephysiopy.format_converters.OE_Axona.OE2Axona.writeTetrodeData"><code class="name flex">
<span>def <span class="ident">writeTetrodeData</span></span>(<span>self, tetnum, header, data)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writeTetrodeData(self, tetnum: str, header: dict, data: np.array):
        self.AxonaData.setHeader(self.axona_root_name + &#34;.&#34; + tetnum, header)
        self.AxonaData.setData(self.axona_root_name + &#34;.&#34; + tetnum, data)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ephysiopy.format_converters" href="index.html">ephysiopy.format_converters</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ephysiopy.format_converters.OE_Axona.OE2Axona" href="#ephysiopy.format_converters.OE_Axona.OE2Axona">OE2Axona</a></code></h4>
<ul class="">
<li><code><a title="ephysiopy.format_converters.OE_Axona.OE2Axona.convertPosData" href="#ephysiopy.format_converters.OE_Axona.OE2Axona.convertPosData">convertPosData</a></code></li>
<li><code><a title="ephysiopy.format_converters.OE_Axona.OE2Axona.convertSpikeData" href="#ephysiopy.format_converters.OE_Axona.OE2Axona.convertSpikeData">convertSpikeData</a></code></li>
<li><code><a title="ephysiopy.format_converters.OE_Axona.OE2Axona.exportLFP" href="#ephysiopy.format_converters.OE_Axona.OE2Axona.exportLFP">exportLFP</a></code></li>
<li><code><a title="ephysiopy.format_converters.OE_Axona.OE2Axona.exportPos" href="#ephysiopy.format_converters.OE_Axona.OE2Axona.exportPos">exportPos</a></code></li>
<li><code><a title="ephysiopy.format_converters.OE_Axona.OE2Axona.exportSetFile" href="#ephysiopy.format_converters.OE_Axona.OE2Axona.exportSetFile">exportSetFile</a></code></li>
<li><code><a title="ephysiopy.format_converters.OE_Axona.OE2Axona.exportSpikes" href="#ephysiopy.format_converters.OE_Axona.OE2Axona.exportSpikes">exportSpikes</a></code></li>
<li><code><a title="ephysiopy.format_converters.OE_Axona.OE2Axona.getOEData" href="#ephysiopy.format_converters.OE_Axona.OE2Axona.getOEData">getOEData</a></code></li>
<li><code><a title="ephysiopy.format_converters.OE_Axona.OE2Axona.makeLFPData" href="#ephysiopy.format_converters.OE_Axona.OE2Axona.makeLFPData">makeLFPData</a></code></li>
<li><code><a title="ephysiopy.format_converters.OE_Axona.OE2Axona.makeSetData" href="#ephysiopy.format_converters.OE_Axona.OE2Axona.makeSetData">makeSetData</a></code></li>
<li><code><a title="ephysiopy.format_converters.OE_Axona.OE2Axona.resample" href="#ephysiopy.format_converters.OE_Axona.OE2Axona.resample">resample</a></code></li>
<li><code><a title="ephysiopy.format_converters.OE_Axona.OE2Axona.settings" href="#ephysiopy.format_converters.OE_Axona.OE2Axona.settings">settings</a></code></li>
<li><code><a title="ephysiopy.format_converters.OE_Axona.OE2Axona.writeLFP2AxonaFormat" href="#ephysiopy.format_converters.OE_Axona.OE2Axona.writeLFP2AxonaFormat">writeLFP2AxonaFormat</a></code></li>
<li><code><a title="ephysiopy.format_converters.OE_Axona.OE2Axona.writePos2AxonaFormat" href="#ephysiopy.format_converters.OE_Axona.OE2Axona.writePos2AxonaFormat">writePos2AxonaFormat</a></code></li>
<li><code><a title="ephysiopy.format_converters.OE_Axona.OE2Axona.writeSetData" href="#ephysiopy.format_converters.OE_Axona.OE2Axona.writeSetData">writeSetData</a></code></li>
<li><code><a title="ephysiopy.format_converters.OE_Axona.OE2Axona.writeTetrodeData" href="#ephysiopy.format_converters.OE_Axona.OE2Axona.writeTetrodeData">writeTetrodeData</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>