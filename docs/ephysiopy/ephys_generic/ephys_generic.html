<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>ephysiopy.ephys_generic.ephys_generic API documentation</title>
<meta name="description" content="Created on Thu Nov
9 17:04:38 2017 â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ephysiopy.ephys_generic.ephys_generic</code></h1>
</header>
<section id="section-intro">
<p>Created on Thu Nov
9 17:04:38 2017</p>
<p>@author: robin</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Thu Nov  9 17:04:38 2017

@author: robin
&#34;&#34;&#34;
import numpy as np
from scipy import signal
import warnings
import matplotlib
import matplotlib.pylab as plt
import matplotlib.cm as cm
from mpl_toolkits.axes_grid1 import make_axes_locatable
import matplotlib.transforms as transforms
from matplotlib.patches import Rectangle
from ephysiopy.ephys_generic import binning
from ephysiopy.dacq2py import tintcolours as tcols

class SpikeCalcsGeneric(object):
    &#34;&#34;&#34;
    Generic class for processing and analysis of spiking data

    Parameters
    ----------
    spike_times : array_like
        the times of &#39;spikes&#39; in the trial
        this should be all spikes as the cluster identity vector _spk_clusters
        is used to pick out the right spikes
    waveforms : np.array
        not sure on shape yet but will be something like a
        a 4 x nSpikes x nSamples (4 for tetrode-based analysis)

    Notes
    -----
    Units for time are provided as per the sample rate but converted internally to milliseconds
    &#34;&#34;&#34;
    def __init__(self, spike_times, waveforms=None, **kwargs):
        self.spike_times = spike_times
        self.waveforms = waveforms
        self._event_ts = None # the times that events occured i.e. the laser came on
        self._spk_clusters = None # vector of cluster ids, same length as spike_times
        self._event_window = np.array((-0.050, 0.100)) # window, in seconds, either side of the stimulus, to examine
        self._stim_width = None # the width, in ms, of the stimulus
        self._secs_per_bin = 0.001 # used to increase / decrease size of bins in psth
        self._sample_rate = 30000
        self._duration = None

    @property
    def sample_rate(self):
        return self._sample_rate

    @sample_rate.setter
    def sample_rate(self, value):
        self._sample_rate = value

    def n_spikes(self, cluster=None):
        if cluster is None:
            return len(self.spike_times)
        else:
            if self.spk_clusters is None:
                warnings.warn(&#34;No clusters available, please load some into me.&#34;)
                return
            else:
                return np.count_nonzero(self._spk_clusters==cluster)

    @property
    def event_ts(self):
        return self._event_ts

    @event_ts.setter
    def event_ts(self, value):
        self._event_ts = value

    @property
    def duration(self):
        return self._duration

    @duration.setter
    def duration(self, value):
        self._duration = value

    @property
    def spk_clusters(self):
        return self._spk_clusters

    @spk_clusters.setter
    def spk_clusters(self, value):
        self._spk_clusters = value

    @property
    def event_window(self):
        return self._event_window

    @event_window.setter
    def event_window(self, value):
        self._event_window = value

    @property
    def stim_width(self):
        return self._stim_width

    @stim_width.setter
    def stim_width(self, value):
        self._stim_width = value

    @property
    def _secs_per_bin(self):
        return self.__secs_per_bin

    @_secs_per_bin.setter
    def _secs_per_bin(self, value):
        self.__secs_per_bin = value

    def trial_mean_fr(self, cluster: int)-&gt;float:
        # Returns the trial mean firing rate for the cluster
        if self.duration is None:
            warnings.warn(&#34;No duration provided, give me one!&#34;)
            return
        return self.n_spikes(cluster) / self.duration

    def mean_isi_range(self, cluster: int, n: int)-&gt;float:
        &#34;&#34;&#34;
        Calculates the mean of the autocorrelation from 0 to n milliseconds
        Used to help classify a neruons type (principal, interneuron etc)

        Parameters
        ----------
        cluster : int
            The cluster to analyse
        n : int
            The range in milliseconds to calculate the mean over

        Returns
        -------
        mean_isi_range : float
            The mean of the autocorrelogram between 0 and n milliseconds
        &#34;&#34;&#34;
        if cluster not in self.spk_clusters:
            warnings.warn(&#34;Cluster not available&#34;)
            return
        bins = 201
        trange = np.array((-500, 500))
        t = self.spike_times[self.spk_clusters==cluster]
        y = self.xcorr(t, Trange=trange)
        y = y.astype(np.int64) # See xcorr docs
        counts, bins = np.histogram(y[y!=0], bins=bins, range=trange)
        mask = np.logical_and(bins&gt;0, bins&lt;n)
        return np.mean(counts[mask[1:]])

    def xcorr(self, x1: np.array, x2=None, Trange=None, **kwargs)-&gt;np.ndarray:
        &#34;&#34;&#34;
        Calculates the histogram of the ISIs in x1 or x1 vs x2

        Parameters
        ----------
        x1, x2 : array_like
            The times of the spikes emitted by the cluster(s)
            NB must be signed int to accomodate negative times
        Trange : array_like
            Range of times to bin up. Defaults to [-500, +500] in ms

        Returns
        -------
        y : np.ndarray
            The time differences between spike times in x1 over the range
            of times defined Trange
        &#34;&#34;&#34;
        if x2 is None:
            x2 = x1.copy()
        if Trange is None:
            Trange = np.array([-500, 500])
        if type(Trange) == tuple:
            Trange = np.array(Trange)
        y = []
        irange = x1[:, np.newaxis] + Trange[np.newaxis, :]
        dts = np.searchsorted(x2, irange)
        for i, t in enumerate(dts):
            y.extend(x2[t[0]:t[1]] - x1[i])
        y = np.array(y, dtype=float)
        return y

    def calculatePSTH(self, cluster_id, **kwargs):
        &#34;&#34;&#34;
        Calculate the PSTH of event_ts against the spiking of a cell

        Parameters
        ----------
        cluster_id : int
            The cluster for which to calculate the psth

        Returns
        -------
        x, y : list
            The list of time differences between the spikes of the cluster
            and the events (x) and the trials (y)
        &#34;&#34;&#34;
        if self._event_ts is None:
            raise Exception(&#34;Need some event timestamps! Aborting&#34;)
        if self._spk_clusters is None:
            raise Exception(&#34;Need cluster identities! Aborting&#34;)
        event_ts = self.event_ts
        event_ts.sort()
        if type(event_ts) == list:
            event_ts = np.array(event_ts)

        spike_times = self.spike_times[self.spk_clusters == cluster_id]
        irange = event_ts[:, np.newaxis] + self.event_window[np.newaxis, :]
        dts = np.searchsorted(spike_times, irange)
        x = []
        y = []
        for i, t in enumerate(dts):
            tmp = spike_times[t[0]:t[1]] - event_ts[i]
            x.extend(tmp)
            y.extend(np.repeat(i,len(tmp)))
        return x, y

    def plotPSTH(self, cluster, fig=None):
        &#34;&#34;&#34;
        Plots the PSTH for a cluster

        Parameters
        ----------
        cluster : int
            The cluster to examine

        Returns
        -------
        cluster, i : int
            The cluster and a junk variable (not sure why for now)
        &#34;&#34;&#34;
        x, y = self.calculatePSTH(cluster)
        show = False # used below to show the figure or leave this to the caller
        if fig is None:
            fig = plt.figure(figsize=(4.0,7.0))
            show = True
        scatter_ax = fig.add_subplot(111)
        scatter_ax.scatter(x, y, marker=&#39;.&#39;, s=2, rasterized=False)
        divider = make_axes_locatable(scatter_ax)
        scatter_ax.set_xticks((self.event_window[0], 0, self.event_window[1]))
        scatter_ax.set_xticklabels((str(self.event_window[0]), &#39;0&#39;, str(self.event_window[1])))
        hist_ax = divider.append_axes(&#34;top&#34;, 0.95, pad=0.2, sharex=scatter_ax,
                                      transform=scatter_ax.transAxes)
        scattTrans = transforms.blended_transform_factory(scatter_ax.transData,
                                                          scatter_ax.transAxes)
        if self.stim_width is not None:
            scatter_ax.add_patch(Rectangle((0, 0), width=self.stim_width, height=1,
                        transform=scattTrans,
                        color=[0, 0, 1], alpha=0.5))
            histTrans = transforms.blended_transform_factory(hist_ax.transData,
                                                             hist_ax.transAxes)
            hist_ax.add_patch(Rectangle((0, 0), width=self.stim_width, height=1,
                              transform=histTrans,
                              color=[0, 0, 1], alpha=0.5))
        scatter_ax.set_ylabel(&#39;Laser stimulation events&#39;, labelpad=-18.5)
        scatter_ax.set_xlabel(&#39;Time to stimulus onset(secs)&#39;)
        nStms = int(len(self.event_ts))
        scatter_ax.set_ylim(0, nStms)
        # Label only the min and max of the y-axis
        ylabels = scatter_ax.get_yticklabels()
        for i in range(1, len(ylabels)-1):
            ylabels[i].set_visible(False)
        yticks = scatter_ax.get_yticklines()
        for i in range(1, len(yticks)-1):
            yticks[i].set_visible(False)
        histColor = [192/255.0,192/255.0,192/255.0]
        histX = hist_ax.hist(x, bins=np.arange(self.event_window[0], self.event_window[1] + self._secs_per_bin, self._secs_per_bin),
                             color=histColor, alpha=0.6, range=self.event_window, rasterized=True, histtype=&#39;stepfilled&#39;)
        hist_ax.set_ylabel(&#34;Spike count&#34;, labelpad=-2.5)
        plt.setp(hist_ax.get_xticklabels(), visible=False)
        # Label only the min and max of the y-axis
        ylabels = hist_ax.get_yticklabels()
        for i in range(1, len(ylabels)-1):
            ylabels[i].set_visible(False)
        yticks = hist_ax.get_yticklines()
        for i in range(1, len(yticks)-1):
            yticks[i].set_visible(False)
        hist_ax.set_xlim(self.event_window)
        scatter_ax.set_xlim(self.event_window)
        if show:
            plt.show()
        yield cluster, 1

    def plotAllXCorrs(self, clusters, fig=None):
        &#39;&#39;&#39;
        Plots all scorrs in a single figure window
        &#39;&#39;&#39;
        from ephysiopy.dacq2py import spikecalcs
        SpkCalcs = spikecalcs.SpikeCalcs()
        if fig is None:
            fig = plt.figure(figsize=(10,20))

        nrows = np.ceil(np.sqrt(len(clusters))).astype(int)
        fig.subplots_adjust(wspace=0.25,hspace=0.25)
        for i, cluster in enumerate(clusters):
            cluster_idx = np.nonzero(self.spk_clusters == cluster)[0]
            cluster_ts = np.ravel(self.spike_times[cluster_idx])
            ax = fig.add_subplot(nrows,nrows,i+1)
            y = SpkCalcs.xcorr(cluster_ts.T / float(self.sample_rate / 1000)) # ms
            ax.hist(y[y != 0], bins=201, range=[-500, 500], color=&#39;k&#39;, histtype=&#39;stepfilled&#39;)
            ax.set_xlim(-500,500)
            ax.set_xticks((-500, 0, 500))
            ax.set_xticklabels((str(-500), &#39;0&#39;, str(500)),fontweight=&#39;normal&#39;, size=8)
            ax.tick_params(axis=&#39;both&#39;, which=&#39;both&#39;, left=False, right=False,
                            bottom=False, top=False)
            ax.set_yticklabels(&#39;&#39;)
            ax.spines[&#39;right&#39;].set_visible(False)
            ax.spines[&#39;top&#39;].set_visible(False)
            ax.spines[&#39;left&#39;].set_visible(False)
            ax.xaxis.set_ticks_position(&#39;bottom&#39;)
            ax.set_title(cluster, fontweight=&#39;bold&#39;, size=10, pad=1)
        plt.show()

class SpikeCalcsTetrode(SpikeCalcsGeneric):
    &#34;&#34;&#34;
    Encapsulates methods specific to the geometry inherent in tetrode-based
    recordings
    &#34;&#34;&#34;
    def __init__(self):
        pass

class SpikeCalcsProbe(SpikeCalcsGeneric):
    &#34;&#34;&#34;
    Encapsulates methods specific to probe-based recordings
    &#34;&#34;&#34;
    def __init__(self):
        pass

class EEGCalcsGeneric(object):
    &#34;&#34;&#34;
    Generic class for processing and analysis of EEG data

    Parameters
    ----------
    sig : array_like
        The signal (of the LFP data)
    fs  : float
        The sample rate
    &#34;&#34;&#34;
    def __init__(self, sig, fs):
        self.sig = sig
        self.fs = fs
        self.thetaRange = [6,12]
        self.outsideRange = [3,125]
        # for smoothing and plotting of power spectrum
        self.smthKernelWidth = 2
        self.smthKernelSigma = 0.1875
        self.sn2Width = 2
        self.maxFreq = 125
        self.maxPow = None

    def _nextpow2(self, val : int):
        &#34;&#34;&#34;
        Calculates the next power of 2 that will hold val
        &#34;&#34;&#34;
        val = val - 1
        val = (val &gt;&gt; 1) | val
        val = (val &gt;&gt; 2) | val
        val = (val &gt;&gt; 4) | val
        val = (val &gt;&gt; 8) | val
        val = (val &gt;&gt; 16) | val
        val = (val &gt;&gt; 32) | val
        return np.log2(val + 1)

    def butterFilter(self, low: float, high: float, order: int=5)-&gt;np.ndarray:
        &#34;&#34;&#34;
        Filters self.sig with a butterworth filter with a bandpass filter
        defined by low and high

        Parameters
        ----------
        low, high : float
            The lower and upper bounds of the bandpass filter
        order : int
            The order of the filter

        Returns
        -------
        filt : np.ndarray
            The filtered signal

        Notes
        -----
        The signal is filtered in both the forward and reverse directions (scipy.signal.filtfilt)
        &#34;&#34;&#34;
        nyqlim = self.fs / 2
        lowcut = low / nyqlim
        highcut = high / nyqlim
        b, a = signal.butter(order, [lowcut, highcut], btype=&#39;band&#39;)
        return signal.filtfilt(b, a, self.sig)

    def calcEEGPowerSpectrum(self, **kwargs):
        &#34;&#34;&#34;
        Calculates the power spectrum of self.sig

        Parameters
        ----------
        None

        Returns
        -------
        Nothing. Sets a bunch of instance variables for the first time including
            freqs : array_like
                The frequencies at which the spectrogram was calculated
            power : array_like
                The power at the frequencies defined above
            sm_power : array_like
                The smoothed power
            bandmaxpower : float
                The maximum power in the theta band
            freqatbandmaxpower : float
                The frequency at which the power is maximum
        &#34;&#34;&#34;
        nqlim = self.fs / 2
        origlen = len(self.sig)
        fftlen = 2 ** self._nextpow2(origlen).astype(int)
        freqs, power = signal.periodogram(self.sig, self.fs, return_onesided=True, nfft=fftlen)
        ffthalflen = fftlen / 2+1
        binsperhz = (ffthalflen-1) / nqlim
        kernelsigma = self.smthKernelSigma * binsperhz
        smthkernelsigma = 2 * int(4.0 * kernelsigma + 0.5) + 1
        gausswin = signal.gaussian(smthkernelsigma, kernelsigma)
        sm_power = signal.fftconvolve(power, gausswin, &#39;same&#39;)
        sm_power = sm_power / np.sqrt(len(sm_power))
        spectrummaskband = np.logical_and(freqs &gt; self.thetaRange[0], freqs &lt; self.thetaRange[1])
        bandmaxpower = np.max(sm_power[spectrummaskband])
        maxbininband = np.argmax(sm_power[spectrummaskband])
        bandfreqs = freqs[spectrummaskband]
        freqatbandmaxpower = bandfreqs[maxbininband]
        self.freqs = freqs
        self.power = power
        self.sm_power = sm_power
        self.bandmaxpower = bandmaxpower
        self.freqatbandmaxpower = freqatbandmaxpower

    def plotPowerSpectrum(self, **kwargs):
        # calculate
        self.calcEEGPowerSpectrum()
        # plotting
        import matplotlib.pylab as plt
        plt.figure()
        ax = plt.gca()
        freqs = self.freqs[0::50]
        power = self.power[0::50]
        sm_power = self.sm_power[0::50]
        ax.plot(freqs, power, alpha=0.5, color=[0.8627, 0.8627, 0.8627])
        ax.plot(freqs, sm_power)
        ax.set_xlim(0, self.maxFreq)
        if &#39;ylim&#39; in kwargs.keys():
            ylim = kwargs[&#39;ylim&#39;]
        else:
            ylim = [0, self.bandmaxpower / 0.8]

        ax.set_ylim(ylim)
        ax.set_ylabel(&#39;Power&#39;)
        ax.set_xlabel(&#39;Frequency&#39;)
        ax.text(x=self.thetaRange[1] / 0.9, y=self.bandmaxpower, s=str(self.freqatbandmaxpower)[0:4], fontsize=20)
        from matplotlib.patches import Rectangle
        r = Rectangle((self.thetaRange[0],0), width=np.diff(self.thetaRange)[0], height=np.diff(ax.get_ylim())[0], alpha=0.25, color=&#39;r&#39;, ec=&#39;none&#39;)
        ax.add_patch(r)
        plt.show()

    def plotEventEEG(self, event_ts, event_window=(-0.05, 0.1), stim_width=0.01, sample_rate=3e4):
        &#39;&#39;&#39;
        Plots the mean eeg +- std. dev centred on event timestamps

        &#39;&#39;&#39;
        # bandpass filter the raw data first
        from scipy import signal
        nyq = sample_rate / 2
        highlim = 500 / nyq
        b, a = signal.butter(5, highlim, btype=&#39;lowpass&#39;)
        sig = signal.filtfilt(b, a, self.sig)

        event_idx = np.round(event_ts*sample_rate).astype(int)
        event_window = np.array(event_window)

        max_samples = np.ptp(event_window*sample_rate).astype(int)
        num_events = len(event_ts)
        eeg_array = np.zeros([num_events, max_samples])
        st = int(event_window[0]*sample_rate)
        en = int(event_window[1]*sample_rate)
        for i, eeg_idx in enumerate(event_idx):
            eeg_array[i, :] = sig[eeg_idx+st:eeg_idx+en]
        mn = np.mean(eeg_array, 0)
        se = np.std(eeg_array, 0) / np.sqrt(num_events)
        import matplotlib.pylab as plt
        # from mpl_toolkits.axes_grid1 import make_axes_locatable
        import matplotlib.transforms as transforms
        from matplotlib.patches import Rectangle
        fig = plt.figure()
        ax = fig.add_subplot(111)
        ax.errorbar(np.linspace(event_window[0], event_window[1], len(mn)), mn, yerr=se, rasterized=False)
        ax.set_xlim(event_window)
        axTrans = transforms.blended_transform_factory(ax.transData,
                                                           ax.transAxes)
        ax.add_patch(Rectangle((0, 0), width=stim_width, height=1,
                             transform=axTrans,
                             color=[1, 1, 0], alpha=0.5))
        ax.set_ylabel(&#39;LFP ($\mu$V)&#39;)
        ax.set_xlabel(&#39;Time(s)&#39;)
        plt.show()

class PosCalcsGeneric(object):
    &#34;&#34;&#34;
    Generic class for post-processing of position data
    Uses numpys masked arrays for dealing with bad positions, filtering etc

    Parameters
    ----------
    x, y : array_like
        The x and y positions.
    ppm : int
        Pixels per metre
    cm : boolean
        Whether everything is converted into cms or not
    jumpmax : int
        Jumps in position (pixel coords) greater than this are bad

    Notes
    -----
    The positional data (x,y) is turned into a numpy masked array once this
    class is initialised - that mask is then modified through various
    functions (postprocesspos being the main one).
    &#34;&#34;&#34;
    def __init__(self, x, y, ppm, cm=True, jumpmax=100):
        assert np.shape(x) == np.shape(y)
        self.xy = np.ma.MaskedArray([x, y])
        self.dir = np.ma.MaskedArray(np.zeros_like(x))
        self.speed = None
        self.ppm = ppm
        self.cm = cm
        self.jumpmax = jumpmax
        self.nleds = np.ndim(x)
        self.npos = len(x)
        self.tracker_params = None
        self.sample_rate = None

    def postprocesspos(self, tracker_params, **kwargs)-&gt;tuple:
        &#34;&#34;&#34;
        Post-process position data

        Parameters
        ----------
        tracker_params : dict
            Same dict as created in OEKiloPhy.Settings.parsePos
            (from module openephys2py)

        Returns
        -------
        xy, hdir : np.ma.MaskedArray
            The post-processed position data

        Notes
        -----
        Several internal functions are called here: speefilter, interpnans, smoothPos
        and calcSpeed. Some internal state/ instance variables are set as well. The
        mask of the positional data (an instance of numpy masked array) is modified
        throughout this method.

        &#34;&#34;&#34;
        xy = self.xy
        xy = np.ma.MaskedArray(xy, dtype=np.int32)
        x_zero = xy[:, 0] &lt; 0
        y_zero = xy[:, 1] &lt; 0
        xy[np.logical_or(x_zero, y_zero), :] = np.ma.masked

        self.tracker_params = tracker_params
        if &#39;LeftBorder&#39; in tracker_params:
            min_x = tracker_params[&#39;LeftBorder&#39;]
            xy[:, xy[0,:] &lt;= min_x] = np.ma.masked
        if &#39;TopBorder&#39; in tracker_params:
            min_y = tracker_params[&#39;TopBorder&#39;] # y origin at top
            xy[:, xy[1,:] &lt;= min_y] = np.ma.masked
        if &#39;RightBorder&#39; in tracker_params:
            max_x = tracker_params[&#39;RightBorder&#39;]
            xy[:, xy[0,:] &gt;= max_x] = np.ma.masked
        if &#39;BottomBorder&#39; in tracker_params:
            max_y = tracker_params[&#39;BottomBorder&#39;]
            xy[:, xy[1,:] &gt;= max_y] = np.ma.masked
        if &#39;SampleRate&#39; in tracker_params.keys():
            self.sample_rate = int(tracker_params[&#39;SampleRate&#39;])
        else:
            self.sample_rate = 30

        xy = xy.T
        xy = self.speedfilter(xy)
        xy = self.interpnans(xy) # ADJUST THIS SO NP.MASKED ARE INTERPOLATED OVER
        xy = self.smoothPos(xy)
        self.calcSpeed(xy)

        import math
        pos2 = np.arange(0, self.npos-1)
        xy_f = xy.astype(np.float)
        self.dir[pos2] = np.mod(((180/math.pi) * (np.arctan2(-xy_f[1, pos2+1] + xy_f[1,pos2],+xy_f[0,pos2+1]-xy_f[0,pos2]))), 360)
        self.dir[-1] = self.dir[-2]

        hdir = self.dir

        return xy, hdir

    def speedfilter(self, xy):
        &#34;&#34;&#34;
        Filters speed

        Parameters
        ----------
        xy : np.ma.MaskedArray
            The xy data

        Returns
        -------
        xy : np.ma.MaskedArray
            The xy data with speeds &gt; self.jumpmax masked
        &#34;&#34;&#34;
        df = np.diff(xy, axis=0)
        disp = np.hypot(df[:,0], df[:,1])
        disp = np.insert(disp, -1, 0)
        xy[disp &gt; self.jumpmax, :] = np.ma.masked
        return xy

    def interpnans(self, xy):
        for i in range(0,np.shape(xy)[-1],2):
            missing = xy.mask.any(axis=-1)
            ok = np.logical_not(missing)
            ok_idx = np.ravel(np.nonzero(np.ravel(ok))[0])#gets the indices of ok poses
            missing_idx = np.ravel(np.nonzero(np.ravel(missing))[0])#get the indices of missing poses
            if len(missing_idx) &gt; 0:
                try:
                    good_data = np.ravel(xy.data[ok_idx,i])
                    good_data1 = np.ravel(xy.data[ok_idx,i+1])
                    xy.data[missing_idx,i] = np.interp(missing_idx,ok_idx,good_data)#,left=np.min(good_data),right=np.max(good_data)
                    xy.data[missing_idx,i+1] = np.interp(missing_idx,ok_idx,good_data1)
                except ValueError as e:
                    pass
                    # print(e)
        xy.mask = 0
        print(&#34;{} bad/ jumpy positions were interpolated over&#34;.format(len(missing_idx)))#this is wrong i think
        return xy

    def smoothPos(self, xy):
        &#39;&#39;&#39;
        Smooths position data

        Parameters
        ----------
        xy : np.ma.MaskedArray
            The xy data

        Returns
        -------
        xy : array_like
            The smoothed positional data
        &#39;&#39;&#39;
        # Extract boundaries of window used in recording

        x = xy[:,0].astype(np.float64)
        y = xy[:,1].astype(np.float64)

        from ephysiopy.dacq2py import smoothdata
        # TODO: calculate window_len from pos sampling rate
        # 11 is roughly equal to 400ms at 30Hz (window_len needs to be odd)
        sm_x = smoothdata.smooth(x, window_len=11, window=&#39;flat&#39;)
        sm_y = smoothdata.smooth(y, window_len=11, window=&#39;flat&#39;)
        return np.array([sm_x, sm_y])

    def calcSpeed(self, xy):
        &#34;&#34;&#34;
        Calculates speed

        Paramters
        ---------
        xy : np.ma.MaskedArray
            The xy positional data

        Returns
        -------
        Nothing. Sets self.speed
        &#34;&#34;&#34;
        speed = np.sqrt(np.sum(np.power(np.diff(xy),2),0))
        speed = np.append(speed, speed[-1])
        if self.cm:
            self.speed = speed * (100 * self.sample_rate / self.ppm) # in cm/s now
        else:
            self.speed = speed

    def upsamplePos(self, xy, upsample_rate=50):
        &#34;&#34;&#34;
        Upsamples position data from 30 to upsample_rate

        Paramters
        ---------
        xy : np.ma.MaskedArray
            The xy positional data

        upsample_rate : int
            The rate to upsample to

        Returns
        -------
        new_xy : np.ma.MaskedArray
            The upsampled xy positional data

        Notes
        -----
        This is mostly to get pos data recorded using PosTracker at 30Hz
        into Axona format 50Hz data
        &#34;&#34;&#34;
        from scipy import signal
        denom = np.gcd(upsample_rate, 30)
        new_xy = signal.resample_poly(xy, upsample_rate/denom, 30/denom)
        return new_xy

class MapCalcsGeneric(object):
    &#34;&#34;&#34;
    Produces graphical output including but not limited to spatial
    analysis of data i.e. ratemaps (xy, heading dir)ection, grid cell
    spatial autocorrelograms, speed vs rate plots etc

    It is possible to iterate through instances of this class as it has a yield
    method defined
    &#34;&#34;&#34;
    def __init__(self, xy, hdir, speed, pos_ts, spk_ts, plot_type=&#39;map&#39;, **kwargs):
        &#34;&#34;&#34;
        Parameters
        ----------
        xy : np.ndarray
            2D numpy array
        hdir : np.ndarray
        pos_ts : np.ndarray
            1D array of timestamps in seconds
        spk_ts : np.ndarray
            1D array of timestamps in seconds
        plot_type : str or list
            Determines the plots produced. Legal values:
            [&#39;map&#39;,&#39;path&#39;,&#39;hdir&#39;,&#39;sac&#39;, &#39;speed&#39;]
        &#34;&#34;&#34;
        if (np.argmin(np.shape(xy)) == 1):
            xy = xy.T
        self.xy = xy
        self.hdir = hdir
        self.speed = speed
        self.pos_ts = pos_ts
        if (spk_ts.ndim == 2):
            spk_ts = np.ravel(spk_ts)
        self.spk_ts = spk_ts
        self.plot_type = plot_type
        self.spk_pos_idx = self.__interpSpkPosTimes()
        self.__good_clusters = None
        self.__spk_clusters = None
        self.save_grid_output_location = None
        if ( &#39;ppm&#39; in kwargs.keys() ):
            self.__ppm = kwargs[&#39;ppm&#39;]
        else:
            self.__ppm = 400
        if &#39;pos_sample_rate&#39; in kwargs.keys():
            self.pos_sample_rate = kwargs[&#39;pos_sample_rate&#39;]
        else:
            self.pos_sample_rate = 30
        if &#39;save_grid_summary_location&#39; in kwargs.keys():
            self.save_grid_output_location = kwargs[&#39;save_grid_summary_location&#39;]

    def __interpSpkPosTimes(self):
        &#39;&#39;&#39;
        Interpolates spike times into indices of position data
        NB Assumes pos times have been zeroed correctly - see comments in
        OEKiloPhy.OpenEphysNWB function __alignTimeStamps__()
        &#39;&#39;&#39;
        idx = np.searchsorted(self.pos_ts, self.spk_ts)
        idx[idx==len(self.pos_ts)] = len(self.pos_ts) - 1
        return idx

    @property
    def good_clusters(self):
        return self.__good_clusters

    @good_clusters.setter
    def good_clusters(self, value):
        self.__good_clusters = value

    @property
    def spk_clusters(self):
        return self.__spk_clusters

    @spk_clusters.setter
    def spk_clusters(self, value):
        self.__spk_clusters = value

    @property
    def ppm(self):
        return self.__ppm

    @ppm.setter
    def ppm(self, value):
        self.__ppm = value

    def plotAll(self):
        if &#39;all&#39; in self.plot_type:
            what_to_plot = [&#39;map&#39;,&#39;path&#39;,&#39;hdir&#39;,&#39;sac&#39;,&#39;speed&#39;, &#39;sp_hd&#39;]
            fig = plt.figure(figsize=(20,10))
        else:
            what_to_plot = list(self.plot_type)
            if len(what_to_plot) &gt; 1:
                fig = plt.figure(figsize=(20,10))
            else:
                fig = plt.figure(figsize=(20,10))#, constrained_layout=True)
        if &#39;sac&#39; in what_to_plot:
            from ephysiopy.dacq2py import gridcell
            S = gridcell.SAC()
            print(gridcell.__file__)
        import matplotlib.gridspec as gridspec
        nrows = np.ceil(np.sqrt(len(self.good_clusters))).astype(int)
        outer = gridspec.GridSpec(nrows, nrows, figure=fig)

        inner_ncols = int(np.ceil(len(what_to_plot) / 2)) # max 2 cols
        if len(what_to_plot) == 1:
            inner_nrows = 1
        else:
            inner_nrows = 2
        first_sub_axis = what_to_plot[0]
        for i, cluster in enumerate(self.good_clusters):
            inner = gridspec.GridSpecFromSubplotSpec(inner_nrows,inner_ncols, subplot_spec=outer[i])
            for plot_type_idx, plot_type in enumerate(what_to_plot):
                if &#39;hdir&#39; in plot_type:
                    ax = fig.add_subplot(inner[plot_type_idx],projection=&#39;polar&#39;)
                else:
                    ax = fig.add_subplot(inner[plot_type_idx])

                if &#39;path&#39; in plot_type:
                    self.makeSpikePathPlot(cluster, ax)
                if &#39;map&#39; in plot_type:
                    rmap = self.makeRateMap(cluster, ax)
                if &#39;hdir&#39; in plot_type:
                    self.makeHDPlot(cluster, ax, add_mrv=True)
                if &#39;sac&#39; in plot_type:
                    rmap = self.makeRateMap(cluster)
                    nodwell = ~np.isfinite(rmap[0])
                    sac = S.autoCorr2D(rmap[0], nodwell)
                    d = S.getMeasures(sac)
                    S.show(sac,d,ax)
                if &#39;speed&#39; in plot_type:
                    self.makeSpeedVsRatePlot(cluster, 0.0, 40.0, 3.0, ax)
                if &#39;sp_hd&#39; in plot_type:
                    self.makeSpeedVsHeadDirectionPlot(cluster, ax)
                # if first_sub_axis in plot_type: # label the first sub-axis only
                    # ax = fig.add_subplot(inner[plot_type_idx])
                ax.set_title(cluster, fontweight=&#39;bold&#39;, size=8)
        plt.show()

    def __iter__(self):
        if &#39;all&#39; in self.plot_type:
            from ephysiopy.dacq2py import gridcell
            S = gridcell.SAC()

        for cluster in self.good_clusters:
            print(&#34;Cluster {}&#34;.format(cluster))
            if &#39;map&#39; in self.plot_type:
                fig = plt.figure()
                ax = plt.gca()
                self.makeRateMap(cluster, ax)
                fig.show()
            elif &#39;path&#39; in self.plot_type:
                plt.figure()
                ax = plt.gca()
                self.makeSpikePathPlot(cluster, ax)
                plt.show()
            elif &#39;hdir&#39; in self.plot_type:
                fig = plt.figure()
                ax = fig.add_subplot(111, projection=&#39;polar&#39;)
                self.makeHDPlot(cluster, ax)
                plt.show()
            elif &#39;both&#39; in self.plot_type:
                fig, (ax1, ax0) = plt.subplots(1,2)
                # ratemap
                self.makeRateMap(cluster, ax0)
                # path / spikes
                self.makeSpikePathPlot(cluster, ax1)
                plt.show()
            elif &#39;speed&#39; in self.plot_type:
                fig = plt.figure()
                ax = fig.add_subplot(111)
                self.makeSpeedVsRatePlot(cluster, 0.0, 40.0, 3.0, ax)
            elif &#39;sp_hd&#39; in self.plot_type:
                fig = plt.figure()
                ax = fig.add_subplot(111)
                self.makeSpeedVsHeadDirectionPlot(cluster, ax)
            elif &#39;all&#39; in self.plot_type:
                fig = plt.figure(figsize=[9.6, 6.0])
                fig.suptitle(&#34;Cluster {}&#34;.format(cluster))
                ax1 = fig.add_subplot(2, 3, 1)
                self.makeSpikePathPlot(cluster, ax1)
                ax0 = fig.add_subplot(2, 3, 2)
                rmap = self.makeRateMap(cluster, ax0)
                ax2 = fig.add_subplot(2, 3, 3)
                nodwell = ~np.isfinite(rmap[0])
                sac = S.autoCorr2D(rmap[0], nodwell)
                d = S.getMeasures(sac)
                if self.save_grid_output_location:
                    d[&#39;Cluster&#39;] = cluster
                    f = open(self.save_grid_output_location, &#39;w&#39;)
                    f.write(str(d))
                    f.close()
                S.show(sac,d,ax2)
                print(&#34;Gridscore: {:.2f}&#34;.format(d[&#39;gridness&#39;]))
                ax3 = fig.add_subplot(2, 3, 4, projection=&#39;polar&#39;)
                self.makeHDPlot(cluster, ax3, add_mrv=True)
                ax4 = fig.add_subplot(2, 3, 5)
                self.makeSpeedVsRatePlot(cluster, 0.0, 40.0, 3.0, ax4)
                ax5 = fig.add_subplot(2, 3, 6)
                self.makeSpeedVsHeadDirectionPlot(cluster, ax5)
                plt.show()
            yield cluster

    def makeRateMap(self, cluster, ax=None):
        pos_w = np.ones_like(self.pos_ts)
        mapMaker = binning.RateMap(self.xy, None, None, pos_w, ppm=self.ppm)
        spk_w = np.bincount(self.spk_pos_idx, self.spk_clusters==cluster, minlength=self.pos_ts.shape[0])
        # print(&#34;nSpikes: {}&#34;.format(np.sum(spk_w).astype(int)))
        rmap = mapMaker.getMap(spk_w)
        if ax is None:
            return rmap
        ratemap = np.ma.MaskedArray(rmap[0], np.isnan(rmap[0]), copy=True)
        x, y = np.meshgrid(rmap[1][1][0:-1], rmap[1][0][0:-1][::-1])
        vmax = np.max(np.ravel(ratemap))
        ax.pcolormesh(x, y, ratemap, cmap=cm.jet, edgecolors=&#39;face&#39;, vmax=vmax)
        ax.axis([x.min(), x.max(), y.min(), y.max()])
        ax.set_aspect(&#39;equal&#39;)
        plt.setp(ax.get_xticklabels(), visible=False)
        plt.setp(ax.get_yticklabels(), visible=False)
        ax.axes.get_xaxis().set_visible(False)
        ax.axes.get_yaxis().set_visible(False)
        ax.spines[&#39;right&#39;].set_visible(False)
        ax.spines[&#39;top&#39;].set_visible(False)
        ax.spines[&#39;bottom&#39;].set_visible(False)
        ax.spines[&#39;left&#39;].set_visible(False)
        return rmap

    def makeSpikePathPlot(self, cluster, ax):
        ax.plot(self.xy[0], self.xy[1], c=tcols.colours[0], zorder=1)
        ax.set_aspect(&#39;equal&#39;)
        ax.invert_yaxis()
        idx = self.spk_pos_idx[self.spk_clusters==cluster]
        spk_colour = tcols.colours[1]
        ax.plot(self.xy[0,idx], self.xy[1,idx],&#39;s&#39;,ms=1, c=spk_colour,mec=spk_colour)
        plt.setp(ax.get_xticklabels(), visible=False)
        plt.setp(ax.get_yticklabels(), visible=False)
        ax.axes.get_xaxis().set_visible(False)
        ax.axes.get_yaxis().set_visible(False)
        ax.spines[&#39;right&#39;].set_visible(False)
        ax.spines[&#39;top&#39;].set_visible(False)
        ax.spines[&#39;bottom&#39;].set_visible(False)
        ax.spines[&#39;left&#39;].set_visible(False)

    def makeHDPlot(self, cluster, ax, **kwargs):
        pos_w = np.ones_like(self.pos_ts)
        mapMaker = binning.RateMap(self.xy, self.hdir, None, pos_w, ppm=self.ppm)
        spk_w = np.bincount(self.spk_pos_idx, self.spk_clusters==cluster, minlength=self.pos_ts.shape[0])
        rmap = mapMaker.getMap(spk_w, &#39;dir&#39;, &#39;rate&#39;)
        if rmap[0].ndim == 1:
            # polar plot
            if ax is None:
                fig = plt.figure()
                ax = fig.add_subplot(111, projection=&#39;polar&#39;)
            theta = np.deg2rad(rmap[1][0][1:])
            ax.clear()
            ax.plot(theta, rmap[0])
            ax.set_aspect(&#39;equal&#39;)
            ax.tick_params(axis=&#39;both&#39;, which=&#39;both&#39;, bottom=False, left=False, right=False, top=False, labelbottom=False, labelleft=False, labeltop=False, labelright=False)
            ax.set_rticks([])

            # See if we should add the mean resultant vector (mrv)
            if &#39;add_mrv&#39; in kwargs.keys():
                from ephysiopy.dacq2py import statscalcs
                S = statscalcs.StatsCalcs()
                angles = self.hdir[self.spk_pos_idx[self.spk_clusters==cluster]]
                r, th = S.mean_resultant_vector(np.deg2rad(angles))
                # print(&#34;Mean resultant vector:&#34;)
                # print(&#39;\tUnit vector length: {:.3f}\n\tVector angle: {:.2f}&#39;.format(r,np.rad2deg(th)))
                ax.plot([th, th],[0, r*np.max(rmap[0])],&#39;r&#39;)
            ax.set_thetagrids([0, 90, 180, 270])

    def makeSpeedVsRatePlot(self, cluster, minSpeed=0.0, maxSpeed=40.0, sigma=3.0, ax=None, **kwargs):
        &#39;&#39;&#39;
        Plots the instantaneous firing rate of a cell against running speed
        Also outputs a couple of measures as with Kropff et al., 2015; the
        Pearsons correlation and the depth of modulation (dom) - see below for
        details
        &#39;&#39;&#39;
        speed = np.ravel(self.speed)
        if np.nanmax(speed) &lt; maxSpeed:
            maxSpeed = np.nanmax(speed)
        spd_bins = np.arange(minSpeed, maxSpeed, 1.0)
        # Construct the mask
        speed_filt = np.ma.MaskedArray(speed)
        speed_filt = np.ma.masked_where(speed_filt &lt; minSpeed, speed_filt)
        speed_filt = np.ma.masked_where(speed_filt &gt; maxSpeed, speed_filt)
        from ephysiopy.dacq2py import spikecalcs
        S = spikecalcs.SpikeCalcs();
        x1 = self.spk_pos_idx[self.spk_clusters==cluster]
        spk_sm = S.smoothSpikePosCount(x1, self.pos_ts.shape[0], sigma, None)
        spk_sm = np.ma.MaskedArray(spk_sm, mask=np.ma.getmask(speed_filt))
        from scipy import stats
        result = stats.mstats.pearsonr(spk_sm, speed_filt)
        spd_dig  = np.digitize(speed_filt, spd_bins, right=True)
        mn_rate = np.array([np.ma.mean(spk_sm[spd_dig==i]) for i in range(0,len(spd_bins))])
        var = np.array([np.ma.std(spk_sm[spd_dig==i]) for i in range(0,len(spd_bins))])
        count = np.array([np.ma.sum(spk_sm[spd_dig==i]) for i in range(0,len(spd_bins))])
        # se = var / count
        if ax is not None:
            ax.errorbar(spd_bins, mn_rate * self.pos_sample_rate, yerr=var, color=&#39;k&#39;)
            ax.set_xlim(spd_bins[0], spd_bins[-1])
            plt.xticks([spd_bins[0], spd_bins[-1]], [&#39;0&#39;, &#39;{:.2g}&#39;.format(spd_bins[-1])], fontweight=&#39;normal&#39;, size=6)
            plt.yticks([0,np.nanmax(mn_rate)*self.pos_sample_rate], [&#39;0&#39;, &#39;{:.2f}&#39;.format(np.nanmax(mn_rate))], fontweight=&#39;normal&#39;, size=6)
            ax.spines[&#39;right&#39;].set_visible(False)
            ax.spines[&#39;top&#39;].set_visible(False)
            ax.yaxis.set_ticks_position(&#39;left&#39;)
            ax.xaxis.set_ticks_position(&#39;bottom&#39;)

    def makeSpeedVsHeadDirectionPlot(self, cluster, ax):
        idx = self.spk_pos_idx[self.spk_clusters==cluster]
        w = np.bincount(idx, minlength=self.speed.shape[0])
        dir_bins = np.arange(0,360,6)
        spd_bins = np.arange(0,30,1)
        h = np.histogram2d(self.hdir, self.speed, [dir_bins,spd_bins],weights=w)
        b = binning.RateMap()
        im = b.blurImage(h[0],5,ftype=&#39;gaussian&#39;)
        im = np.ma.MaskedArray(im);
        # mask low rates...
        im = np.ma.masked_where(im&lt;=1, im)
        # ... and where less than 0.5% of data is accounted for
        # all_sp_x_hd_binned = np.histogram2d(self.hdir, self.speed, [dir_bins,spd_bins])[0]
        # im = np.ma.masked_where(all_sp_x_hd_binned &lt; (len(self.speed) * 0.005), im)
        x,y = np.meshgrid(dir_bins, spd_bins)
        ax.pcolormesh(x,y,im.T);
        ax.spines[&#39;right&#39;].set_visible(False)
        ax.spines[&#39;top&#39;].set_visible(False)
        plt.xticks([90,180,270], fontweight=&#39;normal&#39;, size=6)
        plt.yticks([10,20], fontweight=&#39;normal&#39;, size=6)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ephysiopy.ephys_generic.ephys_generic.EEGCalcsGeneric"><code class="flex name class">
<span>class <span class="ident">EEGCalcsGeneric</span></span>
<span>(</span><span>sig, fs)</span>
</code></dt>
<dd>
<section class="desc"><p>Generic class for processing and analysis of EEG data</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sig</code></strong> :&ensp;<code>array_like</code></dt>
<dd>The signal (of the LFP data)</dd>
</dl>
<p>fs
: float
The sample rate</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EEGCalcsGeneric(object):
    &#34;&#34;&#34;
    Generic class for processing and analysis of EEG data

    Parameters
    ----------
    sig : array_like
        The signal (of the LFP data)
    fs  : float
        The sample rate
    &#34;&#34;&#34;
    def __init__(self, sig, fs):
        self.sig = sig
        self.fs = fs
        self.thetaRange = [6,12]
        self.outsideRange = [3,125]
        # for smoothing and plotting of power spectrum
        self.smthKernelWidth = 2
        self.smthKernelSigma = 0.1875
        self.sn2Width = 2
        self.maxFreq = 125
        self.maxPow = None

    def _nextpow2(self, val : int):
        &#34;&#34;&#34;
        Calculates the next power of 2 that will hold val
        &#34;&#34;&#34;
        val = val - 1
        val = (val &gt;&gt; 1) | val
        val = (val &gt;&gt; 2) | val
        val = (val &gt;&gt; 4) | val
        val = (val &gt;&gt; 8) | val
        val = (val &gt;&gt; 16) | val
        val = (val &gt;&gt; 32) | val
        return np.log2(val + 1)

    def butterFilter(self, low: float, high: float, order: int=5)-&gt;np.ndarray:
        &#34;&#34;&#34;
        Filters self.sig with a butterworth filter with a bandpass filter
        defined by low and high

        Parameters
        ----------
        low, high : float
            The lower and upper bounds of the bandpass filter
        order : int
            The order of the filter

        Returns
        -------
        filt : np.ndarray
            The filtered signal

        Notes
        -----
        The signal is filtered in both the forward and reverse directions (scipy.signal.filtfilt)
        &#34;&#34;&#34;
        nyqlim = self.fs / 2
        lowcut = low / nyqlim
        highcut = high / nyqlim
        b, a = signal.butter(order, [lowcut, highcut], btype=&#39;band&#39;)
        return signal.filtfilt(b, a, self.sig)

    def calcEEGPowerSpectrum(self, **kwargs):
        &#34;&#34;&#34;
        Calculates the power spectrum of self.sig

        Parameters
        ----------
        None

        Returns
        -------
        Nothing. Sets a bunch of instance variables for the first time including
            freqs : array_like
                The frequencies at which the spectrogram was calculated
            power : array_like
                The power at the frequencies defined above
            sm_power : array_like
                The smoothed power
            bandmaxpower : float
                The maximum power in the theta band
            freqatbandmaxpower : float
                The frequency at which the power is maximum
        &#34;&#34;&#34;
        nqlim = self.fs / 2
        origlen = len(self.sig)
        fftlen = 2 ** self._nextpow2(origlen).astype(int)
        freqs, power = signal.periodogram(self.sig, self.fs, return_onesided=True, nfft=fftlen)
        ffthalflen = fftlen / 2+1
        binsperhz = (ffthalflen-1) / nqlim
        kernelsigma = self.smthKernelSigma * binsperhz
        smthkernelsigma = 2 * int(4.0 * kernelsigma + 0.5) + 1
        gausswin = signal.gaussian(smthkernelsigma, kernelsigma)
        sm_power = signal.fftconvolve(power, gausswin, &#39;same&#39;)
        sm_power = sm_power / np.sqrt(len(sm_power))
        spectrummaskband = np.logical_and(freqs &gt; self.thetaRange[0], freqs &lt; self.thetaRange[1])
        bandmaxpower = np.max(sm_power[spectrummaskband])
        maxbininband = np.argmax(sm_power[spectrummaskband])
        bandfreqs = freqs[spectrummaskband]
        freqatbandmaxpower = bandfreqs[maxbininband]
        self.freqs = freqs
        self.power = power
        self.sm_power = sm_power
        self.bandmaxpower = bandmaxpower
        self.freqatbandmaxpower = freqatbandmaxpower

    def plotPowerSpectrum(self, **kwargs):
        # calculate
        self.calcEEGPowerSpectrum()
        # plotting
        import matplotlib.pylab as plt
        plt.figure()
        ax = plt.gca()
        freqs = self.freqs[0::50]
        power = self.power[0::50]
        sm_power = self.sm_power[0::50]
        ax.plot(freqs, power, alpha=0.5, color=[0.8627, 0.8627, 0.8627])
        ax.plot(freqs, sm_power)
        ax.set_xlim(0, self.maxFreq)
        if &#39;ylim&#39; in kwargs.keys():
            ylim = kwargs[&#39;ylim&#39;]
        else:
            ylim = [0, self.bandmaxpower / 0.8]

        ax.set_ylim(ylim)
        ax.set_ylabel(&#39;Power&#39;)
        ax.set_xlabel(&#39;Frequency&#39;)
        ax.text(x=self.thetaRange[1] / 0.9, y=self.bandmaxpower, s=str(self.freqatbandmaxpower)[0:4], fontsize=20)
        from matplotlib.patches import Rectangle
        r = Rectangle((self.thetaRange[0],0), width=np.diff(self.thetaRange)[0], height=np.diff(ax.get_ylim())[0], alpha=0.25, color=&#39;r&#39;, ec=&#39;none&#39;)
        ax.add_patch(r)
        plt.show()

    def plotEventEEG(self, event_ts, event_window=(-0.05, 0.1), stim_width=0.01, sample_rate=3e4):
        &#39;&#39;&#39;
        Plots the mean eeg +- std. dev centred on event timestamps

        &#39;&#39;&#39;
        # bandpass filter the raw data first
        from scipy import signal
        nyq = sample_rate / 2
        highlim = 500 / nyq
        b, a = signal.butter(5, highlim, btype=&#39;lowpass&#39;)
        sig = signal.filtfilt(b, a, self.sig)

        event_idx = np.round(event_ts*sample_rate).astype(int)
        event_window = np.array(event_window)

        max_samples = np.ptp(event_window*sample_rate).astype(int)
        num_events = len(event_ts)
        eeg_array = np.zeros([num_events, max_samples])
        st = int(event_window[0]*sample_rate)
        en = int(event_window[1]*sample_rate)
        for i, eeg_idx in enumerate(event_idx):
            eeg_array[i, :] = sig[eeg_idx+st:eeg_idx+en]
        mn = np.mean(eeg_array, 0)
        se = np.std(eeg_array, 0) / np.sqrt(num_events)
        import matplotlib.pylab as plt
        # from mpl_toolkits.axes_grid1 import make_axes_locatable
        import matplotlib.transforms as transforms
        from matplotlib.patches import Rectangle
        fig = plt.figure()
        ax = fig.add_subplot(111)
        ax.errorbar(np.linspace(event_window[0], event_window[1], len(mn)), mn, yerr=se, rasterized=False)
        ax.set_xlim(event_window)
        axTrans = transforms.blended_transform_factory(ax.transData,
                                                           ax.transAxes)
        ax.add_patch(Rectangle((0, 0), width=stim_width, height=1,
                             transform=axTrans,
                             color=[1, 1, 0], alpha=0.5))
        ax.set_ylabel(&#39;LFP ($\mu$V)&#39;)
        ax.set_xlabel(&#39;Time(s)&#39;)
        plt.show()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ephysiopy.ephys_generic.ephys_generic.EEGCalcsGeneric.butterFilter"><code class="name flex">
<span>def <span class="ident">butterFilter</span></span>(<span>self, low, high, order=5)</span>
</code></dt>
<dd>
<section class="desc"><p>Filters self.sig with a butterworth filter with a bandpass filter
defined by low and high</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>low</code></strong>, <strong><code>high</code></strong> :&ensp;<code>float</code></dt>
<dd>The lower and upper bounds of the bandpass filter</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>int</code></dt>
<dd>The order of the filter</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>filt</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The filtered signal</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The signal is filtered in both the forward and reverse directions (scipy.signal.filtfilt)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def butterFilter(self, low: float, high: float, order: int=5)-&gt;np.ndarray:
    &#34;&#34;&#34;
    Filters self.sig with a butterworth filter with a bandpass filter
    defined by low and high

    Parameters
    ----------
    low, high : float
        The lower and upper bounds of the bandpass filter
    order : int
        The order of the filter

    Returns
    -------
    filt : np.ndarray
        The filtered signal

    Notes
    -----
    The signal is filtered in both the forward and reverse directions (scipy.signal.filtfilt)
    &#34;&#34;&#34;
    nyqlim = self.fs / 2
    lowcut = low / nyqlim
    highcut = high / nyqlim
    b, a = signal.butter(order, [lowcut, highcut], btype=&#39;band&#39;)
    return signal.filtfilt(b, a, self.sig)</code></pre>
</details>
</dd>
<dt id="ephysiopy.ephys_generic.ephys_generic.EEGCalcsGeneric.calcEEGPowerSpectrum"><code class="name flex">
<span>def <span class="ident">calcEEGPowerSpectrum</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates the power spectrum of self.sig</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Nothing.</code> <code>Sets</code> <code>a</code> <code>bunch</code> of <code>instance</code> <code>variables</code> <code>for</code> <code>the</code> <code>first</code> <code>time</code> <code>including</code></dt>
<dd>freqs : array_like
The frequencies at which the spectrogram was calculated
power : array_like
The power at the frequencies defined above
sm_power : array_like
The smoothed power
bandmaxpower : float
The maximum power in the theta band
freqatbandmaxpower : float
The frequency at which the power is maximum</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calcEEGPowerSpectrum(self, **kwargs):
    &#34;&#34;&#34;
    Calculates the power spectrum of self.sig

    Parameters
    ----------
    None

    Returns
    -------
    Nothing. Sets a bunch of instance variables for the first time including
        freqs : array_like
            The frequencies at which the spectrogram was calculated
        power : array_like
            The power at the frequencies defined above
        sm_power : array_like
            The smoothed power
        bandmaxpower : float
            The maximum power in the theta band
        freqatbandmaxpower : float
            The frequency at which the power is maximum
    &#34;&#34;&#34;
    nqlim = self.fs / 2
    origlen = len(self.sig)
    fftlen = 2 ** self._nextpow2(origlen).astype(int)
    freqs, power = signal.periodogram(self.sig, self.fs, return_onesided=True, nfft=fftlen)
    ffthalflen = fftlen / 2+1
    binsperhz = (ffthalflen-1) / nqlim
    kernelsigma = self.smthKernelSigma * binsperhz
    smthkernelsigma = 2 * int(4.0 * kernelsigma + 0.5) + 1
    gausswin = signal.gaussian(smthkernelsigma, kernelsigma)
    sm_power = signal.fftconvolve(power, gausswin, &#39;same&#39;)
    sm_power = sm_power / np.sqrt(len(sm_power))
    spectrummaskband = np.logical_and(freqs &gt; self.thetaRange[0], freqs &lt; self.thetaRange[1])
    bandmaxpower = np.max(sm_power[spectrummaskband])
    maxbininband = np.argmax(sm_power[spectrummaskband])
    bandfreqs = freqs[spectrummaskband]
    freqatbandmaxpower = bandfreqs[maxbininband]
    self.freqs = freqs
    self.power = power
    self.sm_power = sm_power
    self.bandmaxpower = bandmaxpower
    self.freqatbandmaxpower = freqatbandmaxpower</code></pre>
</details>
</dd>
<dt id="ephysiopy.ephys_generic.ephys_generic.EEGCalcsGeneric.plotEventEEG"><code class="name flex">
<span>def <span class="ident">plotEventEEG</span></span>(<span>self, event_ts, event_window=(-0.05, 0.1), stim_width=0.01, sample_rate=30000.0)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the mean eeg +- std. dev centred on event timestamps</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotEventEEG(self, event_ts, event_window=(-0.05, 0.1), stim_width=0.01, sample_rate=3e4):
    &#39;&#39;&#39;
    Plots the mean eeg +- std. dev centred on event timestamps

    &#39;&#39;&#39;
    # bandpass filter the raw data first
    from scipy import signal
    nyq = sample_rate / 2
    highlim = 500 / nyq
    b, a = signal.butter(5, highlim, btype=&#39;lowpass&#39;)
    sig = signal.filtfilt(b, a, self.sig)

    event_idx = np.round(event_ts*sample_rate).astype(int)
    event_window = np.array(event_window)

    max_samples = np.ptp(event_window*sample_rate).astype(int)
    num_events = len(event_ts)
    eeg_array = np.zeros([num_events, max_samples])
    st = int(event_window[0]*sample_rate)
    en = int(event_window[1]*sample_rate)
    for i, eeg_idx in enumerate(event_idx):
        eeg_array[i, :] = sig[eeg_idx+st:eeg_idx+en]
    mn = np.mean(eeg_array, 0)
    se = np.std(eeg_array, 0) / np.sqrt(num_events)
    import matplotlib.pylab as plt
    # from mpl_toolkits.axes_grid1 import make_axes_locatable
    import matplotlib.transforms as transforms
    from matplotlib.patches import Rectangle
    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.errorbar(np.linspace(event_window[0], event_window[1], len(mn)), mn, yerr=se, rasterized=False)
    ax.set_xlim(event_window)
    axTrans = transforms.blended_transform_factory(ax.transData,
                                                       ax.transAxes)
    ax.add_patch(Rectangle((0, 0), width=stim_width, height=1,
                         transform=axTrans,
                         color=[1, 1, 0], alpha=0.5))
    ax.set_ylabel(&#39;LFP ($\mu$V)&#39;)
    ax.set_xlabel(&#39;Time(s)&#39;)
    plt.show()</code></pre>
</details>
</dd>
<dt id="ephysiopy.ephys_generic.ephys_generic.EEGCalcsGeneric.plotPowerSpectrum"><code class="name flex">
<span>def <span class="ident">plotPowerSpectrum</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotPowerSpectrum(self, **kwargs):
    # calculate
    self.calcEEGPowerSpectrum()
    # plotting
    import matplotlib.pylab as plt
    plt.figure()
    ax = plt.gca()
    freqs = self.freqs[0::50]
    power = self.power[0::50]
    sm_power = self.sm_power[0::50]
    ax.plot(freqs, power, alpha=0.5, color=[0.8627, 0.8627, 0.8627])
    ax.plot(freqs, sm_power)
    ax.set_xlim(0, self.maxFreq)
    if &#39;ylim&#39; in kwargs.keys():
        ylim = kwargs[&#39;ylim&#39;]
    else:
        ylim = [0, self.bandmaxpower / 0.8]

    ax.set_ylim(ylim)
    ax.set_ylabel(&#39;Power&#39;)
    ax.set_xlabel(&#39;Frequency&#39;)
    ax.text(x=self.thetaRange[1] / 0.9, y=self.bandmaxpower, s=str(self.freqatbandmaxpower)[0:4], fontsize=20)
    from matplotlib.patches import Rectangle
    r = Rectangle((self.thetaRange[0],0), width=np.diff(self.thetaRange)[0], height=np.diff(ax.get_ylim())[0], alpha=0.25, color=&#39;r&#39;, ec=&#39;none&#39;)
    ax.add_patch(r)
    plt.show()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric"><code class="flex name class">
<span>class <span class="ident">MapCalcsGeneric</span></span>
<span>(</span><span>xy, hdir, speed, pos_ts, spk_ts, plot_type='map', **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Produces graphical output including but not limited to spatial
analysis of data i.e. ratemaps (xy, heading dir)ection, grid cell
spatial autocorrelograms, speed vs rate plots etc</p>
<p>It is possible to iterate through instances of this class as it has a yield
method defined</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xy</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>2D numpy array</dd>
<dt><strong><code>hdir</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>pos_ts</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>1D array of timestamps in seconds</dd>
<dt><strong><code>spk_ts</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>1D array of timestamps in seconds</dd>
<dt><strong><code>plot_type</code></strong> :&ensp;<code>str</code> or <code>list</code></dt>
<dd>Determines the plots produced. Legal values:
['map','path','hdir','sac', 'speed']</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MapCalcsGeneric(object):
    &#34;&#34;&#34;
    Produces graphical output including but not limited to spatial
    analysis of data i.e. ratemaps (xy, heading dir)ection, grid cell
    spatial autocorrelograms, speed vs rate plots etc

    It is possible to iterate through instances of this class as it has a yield
    method defined
    &#34;&#34;&#34;
    def __init__(self, xy, hdir, speed, pos_ts, spk_ts, plot_type=&#39;map&#39;, **kwargs):
        &#34;&#34;&#34;
        Parameters
        ----------
        xy : np.ndarray
            2D numpy array
        hdir : np.ndarray
        pos_ts : np.ndarray
            1D array of timestamps in seconds
        spk_ts : np.ndarray
            1D array of timestamps in seconds
        plot_type : str or list
            Determines the plots produced. Legal values:
            [&#39;map&#39;,&#39;path&#39;,&#39;hdir&#39;,&#39;sac&#39;, &#39;speed&#39;]
        &#34;&#34;&#34;
        if (np.argmin(np.shape(xy)) == 1):
            xy = xy.T
        self.xy = xy
        self.hdir = hdir
        self.speed = speed
        self.pos_ts = pos_ts
        if (spk_ts.ndim == 2):
            spk_ts = np.ravel(spk_ts)
        self.spk_ts = spk_ts
        self.plot_type = plot_type
        self.spk_pos_idx = self.__interpSpkPosTimes()
        self.__good_clusters = None
        self.__spk_clusters = None
        self.save_grid_output_location = None
        if ( &#39;ppm&#39; in kwargs.keys() ):
            self.__ppm = kwargs[&#39;ppm&#39;]
        else:
            self.__ppm = 400
        if &#39;pos_sample_rate&#39; in kwargs.keys():
            self.pos_sample_rate = kwargs[&#39;pos_sample_rate&#39;]
        else:
            self.pos_sample_rate = 30
        if &#39;save_grid_summary_location&#39; in kwargs.keys():
            self.save_grid_output_location = kwargs[&#39;save_grid_summary_location&#39;]

    def __interpSpkPosTimes(self):
        &#39;&#39;&#39;
        Interpolates spike times into indices of position data
        NB Assumes pos times have been zeroed correctly - see comments in
        OEKiloPhy.OpenEphysNWB function __alignTimeStamps__()
        &#39;&#39;&#39;
        idx = np.searchsorted(self.pos_ts, self.spk_ts)
        idx[idx==len(self.pos_ts)] = len(self.pos_ts) - 1
        return idx

    @property
    def good_clusters(self):
        return self.__good_clusters

    @good_clusters.setter
    def good_clusters(self, value):
        self.__good_clusters = value

    @property
    def spk_clusters(self):
        return self.__spk_clusters

    @spk_clusters.setter
    def spk_clusters(self, value):
        self.__spk_clusters = value

    @property
    def ppm(self):
        return self.__ppm

    @ppm.setter
    def ppm(self, value):
        self.__ppm = value

    def plotAll(self):
        if &#39;all&#39; in self.plot_type:
            what_to_plot = [&#39;map&#39;,&#39;path&#39;,&#39;hdir&#39;,&#39;sac&#39;,&#39;speed&#39;, &#39;sp_hd&#39;]
            fig = plt.figure(figsize=(20,10))
        else:
            what_to_plot = list(self.plot_type)
            if len(what_to_plot) &gt; 1:
                fig = plt.figure(figsize=(20,10))
            else:
                fig = plt.figure(figsize=(20,10))#, constrained_layout=True)
        if &#39;sac&#39; in what_to_plot:
            from ephysiopy.dacq2py import gridcell
            S = gridcell.SAC()
            print(gridcell.__file__)
        import matplotlib.gridspec as gridspec
        nrows = np.ceil(np.sqrt(len(self.good_clusters))).astype(int)
        outer = gridspec.GridSpec(nrows, nrows, figure=fig)

        inner_ncols = int(np.ceil(len(what_to_plot) / 2)) # max 2 cols
        if len(what_to_plot) == 1:
            inner_nrows = 1
        else:
            inner_nrows = 2
        first_sub_axis = what_to_plot[0]
        for i, cluster in enumerate(self.good_clusters):
            inner = gridspec.GridSpecFromSubplotSpec(inner_nrows,inner_ncols, subplot_spec=outer[i])
            for plot_type_idx, plot_type in enumerate(what_to_plot):
                if &#39;hdir&#39; in plot_type:
                    ax = fig.add_subplot(inner[plot_type_idx],projection=&#39;polar&#39;)
                else:
                    ax = fig.add_subplot(inner[plot_type_idx])

                if &#39;path&#39; in plot_type:
                    self.makeSpikePathPlot(cluster, ax)
                if &#39;map&#39; in plot_type:
                    rmap = self.makeRateMap(cluster, ax)
                if &#39;hdir&#39; in plot_type:
                    self.makeHDPlot(cluster, ax, add_mrv=True)
                if &#39;sac&#39; in plot_type:
                    rmap = self.makeRateMap(cluster)
                    nodwell = ~np.isfinite(rmap[0])
                    sac = S.autoCorr2D(rmap[0], nodwell)
                    d = S.getMeasures(sac)
                    S.show(sac,d,ax)
                if &#39;speed&#39; in plot_type:
                    self.makeSpeedVsRatePlot(cluster, 0.0, 40.0, 3.0, ax)
                if &#39;sp_hd&#39; in plot_type:
                    self.makeSpeedVsHeadDirectionPlot(cluster, ax)
                # if first_sub_axis in plot_type: # label the first sub-axis only
                    # ax = fig.add_subplot(inner[plot_type_idx])
                ax.set_title(cluster, fontweight=&#39;bold&#39;, size=8)
        plt.show()

    def __iter__(self):
        if &#39;all&#39; in self.plot_type:
            from ephysiopy.dacq2py import gridcell
            S = gridcell.SAC()

        for cluster in self.good_clusters:
            print(&#34;Cluster {}&#34;.format(cluster))
            if &#39;map&#39; in self.plot_type:
                fig = plt.figure()
                ax = plt.gca()
                self.makeRateMap(cluster, ax)
                fig.show()
            elif &#39;path&#39; in self.plot_type:
                plt.figure()
                ax = plt.gca()
                self.makeSpikePathPlot(cluster, ax)
                plt.show()
            elif &#39;hdir&#39; in self.plot_type:
                fig = plt.figure()
                ax = fig.add_subplot(111, projection=&#39;polar&#39;)
                self.makeHDPlot(cluster, ax)
                plt.show()
            elif &#39;both&#39; in self.plot_type:
                fig, (ax1, ax0) = plt.subplots(1,2)
                # ratemap
                self.makeRateMap(cluster, ax0)
                # path / spikes
                self.makeSpikePathPlot(cluster, ax1)
                plt.show()
            elif &#39;speed&#39; in self.plot_type:
                fig = plt.figure()
                ax = fig.add_subplot(111)
                self.makeSpeedVsRatePlot(cluster, 0.0, 40.0, 3.0, ax)
            elif &#39;sp_hd&#39; in self.plot_type:
                fig = plt.figure()
                ax = fig.add_subplot(111)
                self.makeSpeedVsHeadDirectionPlot(cluster, ax)
            elif &#39;all&#39; in self.plot_type:
                fig = plt.figure(figsize=[9.6, 6.0])
                fig.suptitle(&#34;Cluster {}&#34;.format(cluster))
                ax1 = fig.add_subplot(2, 3, 1)
                self.makeSpikePathPlot(cluster, ax1)
                ax0 = fig.add_subplot(2, 3, 2)
                rmap = self.makeRateMap(cluster, ax0)
                ax2 = fig.add_subplot(2, 3, 3)
                nodwell = ~np.isfinite(rmap[0])
                sac = S.autoCorr2D(rmap[0], nodwell)
                d = S.getMeasures(sac)
                if self.save_grid_output_location:
                    d[&#39;Cluster&#39;] = cluster
                    f = open(self.save_grid_output_location, &#39;w&#39;)
                    f.write(str(d))
                    f.close()
                S.show(sac,d,ax2)
                print(&#34;Gridscore: {:.2f}&#34;.format(d[&#39;gridness&#39;]))
                ax3 = fig.add_subplot(2, 3, 4, projection=&#39;polar&#39;)
                self.makeHDPlot(cluster, ax3, add_mrv=True)
                ax4 = fig.add_subplot(2, 3, 5)
                self.makeSpeedVsRatePlot(cluster, 0.0, 40.0, 3.0, ax4)
                ax5 = fig.add_subplot(2, 3, 6)
                self.makeSpeedVsHeadDirectionPlot(cluster, ax5)
                plt.show()
            yield cluster

    def makeRateMap(self, cluster, ax=None):
        pos_w = np.ones_like(self.pos_ts)
        mapMaker = binning.RateMap(self.xy, None, None, pos_w, ppm=self.ppm)
        spk_w = np.bincount(self.spk_pos_idx, self.spk_clusters==cluster, minlength=self.pos_ts.shape[0])
        # print(&#34;nSpikes: {}&#34;.format(np.sum(spk_w).astype(int)))
        rmap = mapMaker.getMap(spk_w)
        if ax is None:
            return rmap
        ratemap = np.ma.MaskedArray(rmap[0], np.isnan(rmap[0]), copy=True)
        x, y = np.meshgrid(rmap[1][1][0:-1], rmap[1][0][0:-1][::-1])
        vmax = np.max(np.ravel(ratemap))
        ax.pcolormesh(x, y, ratemap, cmap=cm.jet, edgecolors=&#39;face&#39;, vmax=vmax)
        ax.axis([x.min(), x.max(), y.min(), y.max()])
        ax.set_aspect(&#39;equal&#39;)
        plt.setp(ax.get_xticklabels(), visible=False)
        plt.setp(ax.get_yticklabels(), visible=False)
        ax.axes.get_xaxis().set_visible(False)
        ax.axes.get_yaxis().set_visible(False)
        ax.spines[&#39;right&#39;].set_visible(False)
        ax.spines[&#39;top&#39;].set_visible(False)
        ax.spines[&#39;bottom&#39;].set_visible(False)
        ax.spines[&#39;left&#39;].set_visible(False)
        return rmap

    def makeSpikePathPlot(self, cluster, ax):
        ax.plot(self.xy[0], self.xy[1], c=tcols.colours[0], zorder=1)
        ax.set_aspect(&#39;equal&#39;)
        ax.invert_yaxis()
        idx = self.spk_pos_idx[self.spk_clusters==cluster]
        spk_colour = tcols.colours[1]
        ax.plot(self.xy[0,idx], self.xy[1,idx],&#39;s&#39;,ms=1, c=spk_colour,mec=spk_colour)
        plt.setp(ax.get_xticklabels(), visible=False)
        plt.setp(ax.get_yticklabels(), visible=False)
        ax.axes.get_xaxis().set_visible(False)
        ax.axes.get_yaxis().set_visible(False)
        ax.spines[&#39;right&#39;].set_visible(False)
        ax.spines[&#39;top&#39;].set_visible(False)
        ax.spines[&#39;bottom&#39;].set_visible(False)
        ax.spines[&#39;left&#39;].set_visible(False)

    def makeHDPlot(self, cluster, ax, **kwargs):
        pos_w = np.ones_like(self.pos_ts)
        mapMaker = binning.RateMap(self.xy, self.hdir, None, pos_w, ppm=self.ppm)
        spk_w = np.bincount(self.spk_pos_idx, self.spk_clusters==cluster, minlength=self.pos_ts.shape[0])
        rmap = mapMaker.getMap(spk_w, &#39;dir&#39;, &#39;rate&#39;)
        if rmap[0].ndim == 1:
            # polar plot
            if ax is None:
                fig = plt.figure()
                ax = fig.add_subplot(111, projection=&#39;polar&#39;)
            theta = np.deg2rad(rmap[1][0][1:])
            ax.clear()
            ax.plot(theta, rmap[0])
            ax.set_aspect(&#39;equal&#39;)
            ax.tick_params(axis=&#39;both&#39;, which=&#39;both&#39;, bottom=False, left=False, right=False, top=False, labelbottom=False, labelleft=False, labeltop=False, labelright=False)
            ax.set_rticks([])

            # See if we should add the mean resultant vector (mrv)
            if &#39;add_mrv&#39; in kwargs.keys():
                from ephysiopy.dacq2py import statscalcs
                S = statscalcs.StatsCalcs()
                angles = self.hdir[self.spk_pos_idx[self.spk_clusters==cluster]]
                r, th = S.mean_resultant_vector(np.deg2rad(angles))
                # print(&#34;Mean resultant vector:&#34;)
                # print(&#39;\tUnit vector length: {:.3f}\n\tVector angle: {:.2f}&#39;.format(r,np.rad2deg(th)))
                ax.plot([th, th],[0, r*np.max(rmap[0])],&#39;r&#39;)
            ax.set_thetagrids([0, 90, 180, 270])

    def makeSpeedVsRatePlot(self, cluster, minSpeed=0.0, maxSpeed=40.0, sigma=3.0, ax=None, **kwargs):
        &#39;&#39;&#39;
        Plots the instantaneous firing rate of a cell against running speed
        Also outputs a couple of measures as with Kropff et al., 2015; the
        Pearsons correlation and the depth of modulation (dom) - see below for
        details
        &#39;&#39;&#39;
        speed = np.ravel(self.speed)
        if np.nanmax(speed) &lt; maxSpeed:
            maxSpeed = np.nanmax(speed)
        spd_bins = np.arange(minSpeed, maxSpeed, 1.0)
        # Construct the mask
        speed_filt = np.ma.MaskedArray(speed)
        speed_filt = np.ma.masked_where(speed_filt &lt; minSpeed, speed_filt)
        speed_filt = np.ma.masked_where(speed_filt &gt; maxSpeed, speed_filt)
        from ephysiopy.dacq2py import spikecalcs
        S = spikecalcs.SpikeCalcs();
        x1 = self.spk_pos_idx[self.spk_clusters==cluster]
        spk_sm = S.smoothSpikePosCount(x1, self.pos_ts.shape[0], sigma, None)
        spk_sm = np.ma.MaskedArray(spk_sm, mask=np.ma.getmask(speed_filt))
        from scipy import stats
        result = stats.mstats.pearsonr(spk_sm, speed_filt)
        spd_dig  = np.digitize(speed_filt, spd_bins, right=True)
        mn_rate = np.array([np.ma.mean(spk_sm[spd_dig==i]) for i in range(0,len(spd_bins))])
        var = np.array([np.ma.std(spk_sm[spd_dig==i]) for i in range(0,len(spd_bins))])
        count = np.array([np.ma.sum(spk_sm[spd_dig==i]) for i in range(0,len(spd_bins))])
        # se = var / count
        if ax is not None:
            ax.errorbar(spd_bins, mn_rate * self.pos_sample_rate, yerr=var, color=&#39;k&#39;)
            ax.set_xlim(spd_bins[0], spd_bins[-1])
            plt.xticks([spd_bins[0], spd_bins[-1]], [&#39;0&#39;, &#39;{:.2g}&#39;.format(spd_bins[-1])], fontweight=&#39;normal&#39;, size=6)
            plt.yticks([0,np.nanmax(mn_rate)*self.pos_sample_rate], [&#39;0&#39;, &#39;{:.2f}&#39;.format(np.nanmax(mn_rate))], fontweight=&#39;normal&#39;, size=6)
            ax.spines[&#39;right&#39;].set_visible(False)
            ax.spines[&#39;top&#39;].set_visible(False)
            ax.yaxis.set_ticks_position(&#39;left&#39;)
            ax.xaxis.set_ticks_position(&#39;bottom&#39;)

    def makeSpeedVsHeadDirectionPlot(self, cluster, ax):
        idx = self.spk_pos_idx[self.spk_clusters==cluster]
        w = np.bincount(idx, minlength=self.speed.shape[0])
        dir_bins = np.arange(0,360,6)
        spd_bins = np.arange(0,30,1)
        h = np.histogram2d(self.hdir, self.speed, [dir_bins,spd_bins],weights=w)
        b = binning.RateMap()
        im = b.blurImage(h[0],5,ftype=&#39;gaussian&#39;)
        im = np.ma.MaskedArray(im);
        # mask low rates...
        im = np.ma.masked_where(im&lt;=1, im)
        # ... and where less than 0.5% of data is accounted for
        # all_sp_x_hd_binned = np.histogram2d(self.hdir, self.speed, [dir_bins,spd_bins])[0]
        # im = np.ma.masked_where(all_sp_x_hd_binned &lt; (len(self.speed) * 0.005), im)
        x,y = np.meshgrid(dir_bins, spd_bins)
        ax.pcolormesh(x,y,im.T);
        ax.spines[&#39;right&#39;].set_visible(False)
        ax.spines[&#39;top&#39;].set_visible(False)
        plt.xticks([90,180,270], fontweight=&#39;normal&#39;, size=6)
        plt.yticks([10,20], fontweight=&#39;normal&#39;, size=6)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.good_clusters"><code class="name">var <span class="ident">good_clusters</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def good_clusters(self):
    return self.__good_clusters</code></pre>
</details>
</dd>
<dt id="ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.ppm"><code class="name">var <span class="ident">ppm</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ppm(self):
    return self.__ppm</code></pre>
</details>
</dd>
<dt id="ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.spk_clusters"><code class="name">var <span class="ident">spk_clusters</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spk_clusters(self):
    return self.__spk_clusters</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.makeHDPlot"><code class="name flex">
<span>def <span class="ident">makeHDPlot</span></span>(<span>self, cluster, ax, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makeHDPlot(self, cluster, ax, **kwargs):
    pos_w = np.ones_like(self.pos_ts)
    mapMaker = binning.RateMap(self.xy, self.hdir, None, pos_w, ppm=self.ppm)
    spk_w = np.bincount(self.spk_pos_idx, self.spk_clusters==cluster, minlength=self.pos_ts.shape[0])
    rmap = mapMaker.getMap(spk_w, &#39;dir&#39;, &#39;rate&#39;)
    if rmap[0].ndim == 1:
        # polar plot
        if ax is None:
            fig = plt.figure()
            ax = fig.add_subplot(111, projection=&#39;polar&#39;)
        theta = np.deg2rad(rmap[1][0][1:])
        ax.clear()
        ax.plot(theta, rmap[0])
        ax.set_aspect(&#39;equal&#39;)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;both&#39;, bottom=False, left=False, right=False, top=False, labelbottom=False, labelleft=False, labeltop=False, labelright=False)
        ax.set_rticks([])

        # See if we should add the mean resultant vector (mrv)
        if &#39;add_mrv&#39; in kwargs.keys():
            from ephysiopy.dacq2py import statscalcs
            S = statscalcs.StatsCalcs()
            angles = self.hdir[self.spk_pos_idx[self.spk_clusters==cluster]]
            r, th = S.mean_resultant_vector(np.deg2rad(angles))
            # print(&#34;Mean resultant vector:&#34;)
            # print(&#39;\tUnit vector length: {:.3f}\n\tVector angle: {:.2f}&#39;.format(r,np.rad2deg(th)))
            ax.plot([th, th],[0, r*np.max(rmap[0])],&#39;r&#39;)
        ax.set_thetagrids([0, 90, 180, 270])</code></pre>
</details>
</dd>
<dt id="ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.makeRateMap"><code class="name flex">
<span>def <span class="ident">makeRateMap</span></span>(<span>self, cluster, ax=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makeRateMap(self, cluster, ax=None):
    pos_w = np.ones_like(self.pos_ts)
    mapMaker = binning.RateMap(self.xy, None, None, pos_w, ppm=self.ppm)
    spk_w = np.bincount(self.spk_pos_idx, self.spk_clusters==cluster, minlength=self.pos_ts.shape[0])
    # print(&#34;nSpikes: {}&#34;.format(np.sum(spk_w).astype(int)))
    rmap = mapMaker.getMap(spk_w)
    if ax is None:
        return rmap
    ratemap = np.ma.MaskedArray(rmap[0], np.isnan(rmap[0]), copy=True)
    x, y = np.meshgrid(rmap[1][1][0:-1], rmap[1][0][0:-1][::-1])
    vmax = np.max(np.ravel(ratemap))
    ax.pcolormesh(x, y, ratemap, cmap=cm.jet, edgecolors=&#39;face&#39;, vmax=vmax)
    ax.axis([x.min(), x.max(), y.min(), y.max()])
    ax.set_aspect(&#39;equal&#39;)
    plt.setp(ax.get_xticklabels(), visible=False)
    plt.setp(ax.get_yticklabels(), visible=False)
    ax.axes.get_xaxis().set_visible(False)
    ax.axes.get_yaxis().set_visible(False)
    ax.spines[&#39;right&#39;].set_visible(False)
    ax.spines[&#39;top&#39;].set_visible(False)
    ax.spines[&#39;bottom&#39;].set_visible(False)
    ax.spines[&#39;left&#39;].set_visible(False)
    return rmap</code></pre>
</details>
</dd>
<dt id="ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.makeSpeedVsHeadDirectionPlot"><code class="name flex">
<span>def <span class="ident">makeSpeedVsHeadDirectionPlot</span></span>(<span>self, cluster, ax)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makeSpeedVsHeadDirectionPlot(self, cluster, ax):
    idx = self.spk_pos_idx[self.spk_clusters==cluster]
    w = np.bincount(idx, minlength=self.speed.shape[0])
    dir_bins = np.arange(0,360,6)
    spd_bins = np.arange(0,30,1)
    h = np.histogram2d(self.hdir, self.speed, [dir_bins,spd_bins],weights=w)
    b = binning.RateMap()
    im = b.blurImage(h[0],5,ftype=&#39;gaussian&#39;)
    im = np.ma.MaskedArray(im);
    # mask low rates...
    im = np.ma.masked_where(im&lt;=1, im)
    # ... and where less than 0.5% of data is accounted for
    # all_sp_x_hd_binned = np.histogram2d(self.hdir, self.speed, [dir_bins,spd_bins])[0]
    # im = np.ma.masked_where(all_sp_x_hd_binned &lt; (len(self.speed) * 0.005), im)
    x,y = np.meshgrid(dir_bins, spd_bins)
    ax.pcolormesh(x,y,im.T);
    ax.spines[&#39;right&#39;].set_visible(False)
    ax.spines[&#39;top&#39;].set_visible(False)
    plt.xticks([90,180,270], fontweight=&#39;normal&#39;, size=6)
    plt.yticks([10,20], fontweight=&#39;normal&#39;, size=6)</code></pre>
</details>
</dd>
<dt id="ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.makeSpeedVsRatePlot"><code class="name flex">
<span>def <span class="ident">makeSpeedVsRatePlot</span></span>(<span>self, cluster, minSpeed=0.0, maxSpeed=40.0, sigma=3.0, ax=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the instantaneous firing rate of a cell against running speed
Also outputs a couple of measures as with Kropff et al., 2015; the
Pearsons correlation and the depth of modulation (dom) - see below for
details</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makeSpeedVsRatePlot(self, cluster, minSpeed=0.0, maxSpeed=40.0, sigma=3.0, ax=None, **kwargs):
    &#39;&#39;&#39;
    Plots the instantaneous firing rate of a cell against running speed
    Also outputs a couple of measures as with Kropff et al., 2015; the
    Pearsons correlation and the depth of modulation (dom) - see below for
    details
    &#39;&#39;&#39;
    speed = np.ravel(self.speed)
    if np.nanmax(speed) &lt; maxSpeed:
        maxSpeed = np.nanmax(speed)
    spd_bins = np.arange(minSpeed, maxSpeed, 1.0)
    # Construct the mask
    speed_filt = np.ma.MaskedArray(speed)
    speed_filt = np.ma.masked_where(speed_filt &lt; minSpeed, speed_filt)
    speed_filt = np.ma.masked_where(speed_filt &gt; maxSpeed, speed_filt)
    from ephysiopy.dacq2py import spikecalcs
    S = spikecalcs.SpikeCalcs();
    x1 = self.spk_pos_idx[self.spk_clusters==cluster]
    spk_sm = S.smoothSpikePosCount(x1, self.pos_ts.shape[0], sigma, None)
    spk_sm = np.ma.MaskedArray(spk_sm, mask=np.ma.getmask(speed_filt))
    from scipy import stats
    result = stats.mstats.pearsonr(spk_sm, speed_filt)
    spd_dig  = np.digitize(speed_filt, spd_bins, right=True)
    mn_rate = np.array([np.ma.mean(spk_sm[spd_dig==i]) for i in range(0,len(spd_bins))])
    var = np.array([np.ma.std(spk_sm[spd_dig==i]) for i in range(0,len(spd_bins))])
    count = np.array([np.ma.sum(spk_sm[spd_dig==i]) for i in range(0,len(spd_bins))])
    # se = var / count
    if ax is not None:
        ax.errorbar(spd_bins, mn_rate * self.pos_sample_rate, yerr=var, color=&#39;k&#39;)
        ax.set_xlim(spd_bins[0], spd_bins[-1])
        plt.xticks([spd_bins[0], spd_bins[-1]], [&#39;0&#39;, &#39;{:.2g}&#39;.format(spd_bins[-1])], fontweight=&#39;normal&#39;, size=6)
        plt.yticks([0,np.nanmax(mn_rate)*self.pos_sample_rate], [&#39;0&#39;, &#39;{:.2f}&#39;.format(np.nanmax(mn_rate))], fontweight=&#39;normal&#39;, size=6)
        ax.spines[&#39;right&#39;].set_visible(False)
        ax.spines[&#39;top&#39;].set_visible(False)
        ax.yaxis.set_ticks_position(&#39;left&#39;)
        ax.xaxis.set_ticks_position(&#39;bottom&#39;)</code></pre>
</details>
</dd>
<dt id="ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.makeSpikePathPlot"><code class="name flex">
<span>def <span class="ident">makeSpikePathPlot</span></span>(<span>self, cluster, ax)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makeSpikePathPlot(self, cluster, ax):
    ax.plot(self.xy[0], self.xy[1], c=tcols.colours[0], zorder=1)
    ax.set_aspect(&#39;equal&#39;)
    ax.invert_yaxis()
    idx = self.spk_pos_idx[self.spk_clusters==cluster]
    spk_colour = tcols.colours[1]
    ax.plot(self.xy[0,idx], self.xy[1,idx],&#39;s&#39;,ms=1, c=spk_colour,mec=spk_colour)
    plt.setp(ax.get_xticklabels(), visible=False)
    plt.setp(ax.get_yticklabels(), visible=False)
    ax.axes.get_xaxis().set_visible(False)
    ax.axes.get_yaxis().set_visible(False)
    ax.spines[&#39;right&#39;].set_visible(False)
    ax.spines[&#39;top&#39;].set_visible(False)
    ax.spines[&#39;bottom&#39;].set_visible(False)
    ax.spines[&#39;left&#39;].set_visible(False)</code></pre>
</details>
</dd>
<dt id="ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.plotAll"><code class="name flex">
<span>def <span class="ident">plotAll</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotAll(self):
    if &#39;all&#39; in self.plot_type:
        what_to_plot = [&#39;map&#39;,&#39;path&#39;,&#39;hdir&#39;,&#39;sac&#39;,&#39;speed&#39;, &#39;sp_hd&#39;]
        fig = plt.figure(figsize=(20,10))
    else:
        what_to_plot = list(self.plot_type)
        if len(what_to_plot) &gt; 1:
            fig = plt.figure(figsize=(20,10))
        else:
            fig = plt.figure(figsize=(20,10))#, constrained_layout=True)
    if &#39;sac&#39; in what_to_plot:
        from ephysiopy.dacq2py import gridcell
        S = gridcell.SAC()
        print(gridcell.__file__)
    import matplotlib.gridspec as gridspec
    nrows = np.ceil(np.sqrt(len(self.good_clusters))).astype(int)
    outer = gridspec.GridSpec(nrows, nrows, figure=fig)

    inner_ncols = int(np.ceil(len(what_to_plot) / 2)) # max 2 cols
    if len(what_to_plot) == 1:
        inner_nrows = 1
    else:
        inner_nrows = 2
    first_sub_axis = what_to_plot[0]
    for i, cluster in enumerate(self.good_clusters):
        inner = gridspec.GridSpecFromSubplotSpec(inner_nrows,inner_ncols, subplot_spec=outer[i])
        for plot_type_idx, plot_type in enumerate(what_to_plot):
            if &#39;hdir&#39; in plot_type:
                ax = fig.add_subplot(inner[plot_type_idx],projection=&#39;polar&#39;)
            else:
                ax = fig.add_subplot(inner[plot_type_idx])

            if &#39;path&#39; in plot_type:
                self.makeSpikePathPlot(cluster, ax)
            if &#39;map&#39; in plot_type:
                rmap = self.makeRateMap(cluster, ax)
            if &#39;hdir&#39; in plot_type:
                self.makeHDPlot(cluster, ax, add_mrv=True)
            if &#39;sac&#39; in plot_type:
                rmap = self.makeRateMap(cluster)
                nodwell = ~np.isfinite(rmap[0])
                sac = S.autoCorr2D(rmap[0], nodwell)
                d = S.getMeasures(sac)
                S.show(sac,d,ax)
            if &#39;speed&#39; in plot_type:
                self.makeSpeedVsRatePlot(cluster, 0.0, 40.0, 3.0, ax)
            if &#39;sp_hd&#39; in plot_type:
                self.makeSpeedVsHeadDirectionPlot(cluster, ax)
            # if first_sub_axis in plot_type: # label the first sub-axis only
                # ax = fig.add_subplot(inner[plot_type_idx])
            ax.set_title(cluster, fontweight=&#39;bold&#39;, size=8)
    plt.show()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric"><code class="flex name class">
<span>class <span class="ident">PosCalcsGeneric</span></span>
<span>(</span><span>x, y, ppm, cm=True, jumpmax=100)</span>
</code></dt>
<dd>
<section class="desc"><p>Generic class for post-processing of position data
Uses numpys masked arrays for dealing with bad positions, filtering etc</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong>, <strong><code>y</code></strong> :&ensp;<code>array_like</code></dt>
<dd>The x and y positions.</dd>
<dt><strong><code>ppm</code></strong> :&ensp;<code>int</code></dt>
<dd>Pixels per metre</dd>
<dt><strong><code>cm</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Whether everything is converted into cms or not</dd>
<dt><strong><code>jumpmax</code></strong> :&ensp;<code>int</code></dt>
<dd>Jumps in position (pixel coords) greater than this are bad</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The positional data (x,y) is turned into a numpy masked array once this
class is initialised - that mask is then modified through various
functions (postprocesspos being the main one).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PosCalcsGeneric(object):
    &#34;&#34;&#34;
    Generic class for post-processing of position data
    Uses numpys masked arrays for dealing with bad positions, filtering etc

    Parameters
    ----------
    x, y : array_like
        The x and y positions.
    ppm : int
        Pixels per metre
    cm : boolean
        Whether everything is converted into cms or not
    jumpmax : int
        Jumps in position (pixel coords) greater than this are bad

    Notes
    -----
    The positional data (x,y) is turned into a numpy masked array once this
    class is initialised - that mask is then modified through various
    functions (postprocesspos being the main one).
    &#34;&#34;&#34;
    def __init__(self, x, y, ppm, cm=True, jumpmax=100):
        assert np.shape(x) == np.shape(y)
        self.xy = np.ma.MaskedArray([x, y])
        self.dir = np.ma.MaskedArray(np.zeros_like(x))
        self.speed = None
        self.ppm = ppm
        self.cm = cm
        self.jumpmax = jumpmax
        self.nleds = np.ndim(x)
        self.npos = len(x)
        self.tracker_params = None
        self.sample_rate = None

    def postprocesspos(self, tracker_params, **kwargs)-&gt;tuple:
        &#34;&#34;&#34;
        Post-process position data

        Parameters
        ----------
        tracker_params : dict
            Same dict as created in OEKiloPhy.Settings.parsePos
            (from module openephys2py)

        Returns
        -------
        xy, hdir : np.ma.MaskedArray
            The post-processed position data

        Notes
        -----
        Several internal functions are called here: speefilter, interpnans, smoothPos
        and calcSpeed. Some internal state/ instance variables are set as well. The
        mask of the positional data (an instance of numpy masked array) is modified
        throughout this method.

        &#34;&#34;&#34;
        xy = self.xy
        xy = np.ma.MaskedArray(xy, dtype=np.int32)
        x_zero = xy[:, 0] &lt; 0
        y_zero = xy[:, 1] &lt; 0
        xy[np.logical_or(x_zero, y_zero), :] = np.ma.masked

        self.tracker_params = tracker_params
        if &#39;LeftBorder&#39; in tracker_params:
            min_x = tracker_params[&#39;LeftBorder&#39;]
            xy[:, xy[0,:] &lt;= min_x] = np.ma.masked
        if &#39;TopBorder&#39; in tracker_params:
            min_y = tracker_params[&#39;TopBorder&#39;] # y origin at top
            xy[:, xy[1,:] &lt;= min_y] = np.ma.masked
        if &#39;RightBorder&#39; in tracker_params:
            max_x = tracker_params[&#39;RightBorder&#39;]
            xy[:, xy[0,:] &gt;= max_x] = np.ma.masked
        if &#39;BottomBorder&#39; in tracker_params:
            max_y = tracker_params[&#39;BottomBorder&#39;]
            xy[:, xy[1,:] &gt;= max_y] = np.ma.masked
        if &#39;SampleRate&#39; in tracker_params.keys():
            self.sample_rate = int(tracker_params[&#39;SampleRate&#39;])
        else:
            self.sample_rate = 30

        xy = xy.T
        xy = self.speedfilter(xy)
        xy = self.interpnans(xy) # ADJUST THIS SO NP.MASKED ARE INTERPOLATED OVER
        xy = self.smoothPos(xy)
        self.calcSpeed(xy)

        import math
        pos2 = np.arange(0, self.npos-1)
        xy_f = xy.astype(np.float)
        self.dir[pos2] = np.mod(((180/math.pi) * (np.arctan2(-xy_f[1, pos2+1] + xy_f[1,pos2],+xy_f[0,pos2+1]-xy_f[0,pos2]))), 360)
        self.dir[-1] = self.dir[-2]

        hdir = self.dir

        return xy, hdir

    def speedfilter(self, xy):
        &#34;&#34;&#34;
        Filters speed

        Parameters
        ----------
        xy : np.ma.MaskedArray
            The xy data

        Returns
        -------
        xy : np.ma.MaskedArray
            The xy data with speeds &gt; self.jumpmax masked
        &#34;&#34;&#34;
        df = np.diff(xy, axis=0)
        disp = np.hypot(df[:,0], df[:,1])
        disp = np.insert(disp, -1, 0)
        xy[disp &gt; self.jumpmax, :] = np.ma.masked
        return xy

    def interpnans(self, xy):
        for i in range(0,np.shape(xy)[-1],2):
            missing = xy.mask.any(axis=-1)
            ok = np.logical_not(missing)
            ok_idx = np.ravel(np.nonzero(np.ravel(ok))[0])#gets the indices of ok poses
            missing_idx = np.ravel(np.nonzero(np.ravel(missing))[0])#get the indices of missing poses
            if len(missing_idx) &gt; 0:
                try:
                    good_data = np.ravel(xy.data[ok_idx,i])
                    good_data1 = np.ravel(xy.data[ok_idx,i+1])
                    xy.data[missing_idx,i] = np.interp(missing_idx,ok_idx,good_data)#,left=np.min(good_data),right=np.max(good_data)
                    xy.data[missing_idx,i+1] = np.interp(missing_idx,ok_idx,good_data1)
                except ValueError as e:
                    pass
                    # print(e)
        xy.mask = 0
        print(&#34;{} bad/ jumpy positions were interpolated over&#34;.format(len(missing_idx)))#this is wrong i think
        return xy

    def smoothPos(self, xy):
        &#39;&#39;&#39;
        Smooths position data

        Parameters
        ----------
        xy : np.ma.MaskedArray
            The xy data

        Returns
        -------
        xy : array_like
            The smoothed positional data
        &#39;&#39;&#39;
        # Extract boundaries of window used in recording

        x = xy[:,0].astype(np.float64)
        y = xy[:,1].astype(np.float64)

        from ephysiopy.dacq2py import smoothdata
        # TODO: calculate window_len from pos sampling rate
        # 11 is roughly equal to 400ms at 30Hz (window_len needs to be odd)
        sm_x = smoothdata.smooth(x, window_len=11, window=&#39;flat&#39;)
        sm_y = smoothdata.smooth(y, window_len=11, window=&#39;flat&#39;)
        return np.array([sm_x, sm_y])

    def calcSpeed(self, xy):
        &#34;&#34;&#34;
        Calculates speed

        Paramters
        ---------
        xy : np.ma.MaskedArray
            The xy positional data

        Returns
        -------
        Nothing. Sets self.speed
        &#34;&#34;&#34;
        speed = np.sqrt(np.sum(np.power(np.diff(xy),2),0))
        speed = np.append(speed, speed[-1])
        if self.cm:
            self.speed = speed * (100 * self.sample_rate / self.ppm) # in cm/s now
        else:
            self.speed = speed

    def upsamplePos(self, xy, upsample_rate=50):
        &#34;&#34;&#34;
        Upsamples position data from 30 to upsample_rate

        Paramters
        ---------
        xy : np.ma.MaskedArray
            The xy positional data

        upsample_rate : int
            The rate to upsample to

        Returns
        -------
        new_xy : np.ma.MaskedArray
            The upsampled xy positional data

        Notes
        -----
        This is mostly to get pos data recorded using PosTracker at 30Hz
        into Axona format 50Hz data
        &#34;&#34;&#34;
        from scipy import signal
        denom = np.gcd(upsample_rate, 30)
        new_xy = signal.resample_poly(xy, upsample_rate/denom, 30/denom)
        return new_xy</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.calcSpeed"><code class="name flex">
<span>def <span class="ident">calcSpeed</span></span>(<span>self, xy)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates speed</p>
<h2 id="paramters">Paramters</h2>
<dl>
<dt><strong><code>xy</code></strong> :&ensp;<code>np.ma.MaskedArray</code></dt>
<dd>The xy positional data</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Nothing.</code> <code>Sets</code> <code>self.speed</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calcSpeed(self, xy):
    &#34;&#34;&#34;
    Calculates speed

    Paramters
    ---------
    xy : np.ma.MaskedArray
        The xy positional data

    Returns
    -------
    Nothing. Sets self.speed
    &#34;&#34;&#34;
    speed = np.sqrt(np.sum(np.power(np.diff(xy),2),0))
    speed = np.append(speed, speed[-1])
    if self.cm:
        self.speed = speed * (100 * self.sample_rate / self.ppm) # in cm/s now
    else:
        self.speed = speed</code></pre>
</details>
</dd>
<dt id="ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.interpnans"><code class="name flex">
<span>def <span class="ident">interpnans</span></span>(<span>self, xy)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpnans(self, xy):
    for i in range(0,np.shape(xy)[-1],2):
        missing = xy.mask.any(axis=-1)
        ok = np.logical_not(missing)
        ok_idx = np.ravel(np.nonzero(np.ravel(ok))[0])#gets the indices of ok poses
        missing_idx = np.ravel(np.nonzero(np.ravel(missing))[0])#get the indices of missing poses
        if len(missing_idx) &gt; 0:
            try:
                good_data = np.ravel(xy.data[ok_idx,i])
                good_data1 = np.ravel(xy.data[ok_idx,i+1])
                xy.data[missing_idx,i] = np.interp(missing_idx,ok_idx,good_data)#,left=np.min(good_data),right=np.max(good_data)
                xy.data[missing_idx,i+1] = np.interp(missing_idx,ok_idx,good_data1)
            except ValueError as e:
                pass
                # print(e)
    xy.mask = 0
    print(&#34;{} bad/ jumpy positions were interpolated over&#34;.format(len(missing_idx)))#this is wrong i think
    return xy</code></pre>
</details>
</dd>
<dt id="ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.postprocesspos"><code class="name flex">
<span>def <span class="ident">postprocesspos</span></span>(<span>self, tracker_params, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Post-process position data</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tracker_params</code></strong> :&ensp;<code>dict</code></dt>
<dd>Same dict as created in OEKiloPhy.Settings.parsePos
(from module openephys2py)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>xy</code></strong>, <strong><code>hdir</code></strong> :&ensp;<code>np.ma.MaskedArray</code></dt>
<dd>The post-processed position data</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Several internal functions are called here: speefilter, interpnans, smoothPos
and calcSpeed. Some internal state/ instance variables are set as well. The
mask of the positional data (an instance of numpy masked array) is modified
throughout this method.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def postprocesspos(self, tracker_params, **kwargs)-&gt;tuple:
    &#34;&#34;&#34;
    Post-process position data

    Parameters
    ----------
    tracker_params : dict
        Same dict as created in OEKiloPhy.Settings.parsePos
        (from module openephys2py)

    Returns
    -------
    xy, hdir : np.ma.MaskedArray
        The post-processed position data

    Notes
    -----
    Several internal functions are called here: speefilter, interpnans, smoothPos
    and calcSpeed. Some internal state/ instance variables are set as well. The
    mask of the positional data (an instance of numpy masked array) is modified
    throughout this method.

    &#34;&#34;&#34;
    xy = self.xy
    xy = np.ma.MaskedArray(xy, dtype=np.int32)
    x_zero = xy[:, 0] &lt; 0
    y_zero = xy[:, 1] &lt; 0
    xy[np.logical_or(x_zero, y_zero), :] = np.ma.masked

    self.tracker_params = tracker_params
    if &#39;LeftBorder&#39; in tracker_params:
        min_x = tracker_params[&#39;LeftBorder&#39;]
        xy[:, xy[0,:] &lt;= min_x] = np.ma.masked
    if &#39;TopBorder&#39; in tracker_params:
        min_y = tracker_params[&#39;TopBorder&#39;] # y origin at top
        xy[:, xy[1,:] &lt;= min_y] = np.ma.masked
    if &#39;RightBorder&#39; in tracker_params:
        max_x = tracker_params[&#39;RightBorder&#39;]
        xy[:, xy[0,:] &gt;= max_x] = np.ma.masked
    if &#39;BottomBorder&#39; in tracker_params:
        max_y = tracker_params[&#39;BottomBorder&#39;]
        xy[:, xy[1,:] &gt;= max_y] = np.ma.masked
    if &#39;SampleRate&#39; in tracker_params.keys():
        self.sample_rate = int(tracker_params[&#39;SampleRate&#39;])
    else:
        self.sample_rate = 30

    xy = xy.T
    xy = self.speedfilter(xy)
    xy = self.interpnans(xy) # ADJUST THIS SO NP.MASKED ARE INTERPOLATED OVER
    xy = self.smoothPos(xy)
    self.calcSpeed(xy)

    import math
    pos2 = np.arange(0, self.npos-1)
    xy_f = xy.astype(np.float)
    self.dir[pos2] = np.mod(((180/math.pi) * (np.arctan2(-xy_f[1, pos2+1] + xy_f[1,pos2],+xy_f[0,pos2+1]-xy_f[0,pos2]))), 360)
    self.dir[-1] = self.dir[-2]

    hdir = self.dir

    return xy, hdir</code></pre>
</details>
</dd>
<dt id="ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.smoothPos"><code class="name flex">
<span>def <span class="ident">smoothPos</span></span>(<span>self, xy)</span>
</code></dt>
<dd>
<section class="desc"><p>Smooths position data</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xy</code></strong> :&ensp;<code>np.ma.MaskedArray</code></dt>
<dd>The xy data</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>xy</code></strong> :&ensp;<code>array_like</code></dt>
<dd>The smoothed positional data</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def smoothPos(self, xy):
    &#39;&#39;&#39;
    Smooths position data

    Parameters
    ----------
    xy : np.ma.MaskedArray
        The xy data

    Returns
    -------
    xy : array_like
        The smoothed positional data
    &#39;&#39;&#39;
    # Extract boundaries of window used in recording

    x = xy[:,0].astype(np.float64)
    y = xy[:,1].astype(np.float64)

    from ephysiopy.dacq2py import smoothdata
    # TODO: calculate window_len from pos sampling rate
    # 11 is roughly equal to 400ms at 30Hz (window_len needs to be odd)
    sm_x = smoothdata.smooth(x, window_len=11, window=&#39;flat&#39;)
    sm_y = smoothdata.smooth(y, window_len=11, window=&#39;flat&#39;)
    return np.array([sm_x, sm_y])</code></pre>
</details>
</dd>
<dt id="ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.speedfilter"><code class="name flex">
<span>def <span class="ident">speedfilter</span></span>(<span>self, xy)</span>
</code></dt>
<dd>
<section class="desc"><p>Filters speed</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xy</code></strong> :&ensp;<code>np.ma.MaskedArray</code></dt>
<dd>The xy data</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>xy</code></strong> :&ensp;<code>np.ma.MaskedArray</code></dt>
<dd>The xy data with speeds &gt; self.jumpmax masked</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def speedfilter(self, xy):
    &#34;&#34;&#34;
    Filters speed

    Parameters
    ----------
    xy : np.ma.MaskedArray
        The xy data

    Returns
    -------
    xy : np.ma.MaskedArray
        The xy data with speeds &gt; self.jumpmax masked
    &#34;&#34;&#34;
    df = np.diff(xy, axis=0)
    disp = np.hypot(df[:,0], df[:,1])
    disp = np.insert(disp, -1, 0)
    xy[disp &gt; self.jumpmax, :] = np.ma.masked
    return xy</code></pre>
</details>
</dd>
<dt id="ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.upsamplePos"><code class="name flex">
<span>def <span class="ident">upsamplePos</span></span>(<span>self, xy, upsample_rate=50)</span>
</code></dt>
<dd>
<section class="desc"><p>Upsamples position data from 30 to upsample_rate</p>
<h2 id="paramters">Paramters</h2>
<dl>
<dt><strong><code>xy</code></strong> :&ensp;<code>np.ma.MaskedArray</code></dt>
<dd>The xy positional data</dd>
<dt><strong><code>upsample_rate</code></strong> :&ensp;<code>int</code></dt>
<dd>The rate to upsample to</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>new_xy</code></strong> :&ensp;<code>np.ma.MaskedArray</code></dt>
<dd>The upsampled xy positional data</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>This is mostly to get pos data recorded using PosTracker at 30Hz
into Axona format 50Hz data</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def upsamplePos(self, xy, upsample_rate=50):
    &#34;&#34;&#34;
    Upsamples position data from 30 to upsample_rate

    Paramters
    ---------
    xy : np.ma.MaskedArray
        The xy positional data

    upsample_rate : int
        The rate to upsample to

    Returns
    -------
    new_xy : np.ma.MaskedArray
        The upsampled xy positional data

    Notes
    -----
    This is mostly to get pos data recorded using PosTracker at 30Hz
    into Axona format 50Hz data
    &#34;&#34;&#34;
    from scipy import signal
    denom = np.gcd(upsample_rate, 30)
    new_xy = signal.resample_poly(xy, upsample_rate/denom, 30/denom)
    return new_xy</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric"><code class="flex name class">
<span>class <span class="ident">SpikeCalcsGeneric</span></span>
<span>(</span><span>spike_times, waveforms=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Generic class for processing and analysis of spiking data</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spike_times</code></strong> :&ensp;<code>array_like</code></dt>
<dd>the times of 'spikes' in the trial
this should be all spikes as the cluster identity vector _spk_clusters
is used to pick out the right spikes</dd>
<dt><strong><code>waveforms</code></strong> :&ensp;<code>np.array</code></dt>
<dd>not sure on shape yet but will be something like a
a 4 x nSpikes x nSamples (4 for tetrode-based analysis)</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Units for time are provided as per the sample rate but converted internally to milliseconds</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SpikeCalcsGeneric(object):
    &#34;&#34;&#34;
    Generic class for processing and analysis of spiking data

    Parameters
    ----------
    spike_times : array_like
        the times of &#39;spikes&#39; in the trial
        this should be all spikes as the cluster identity vector _spk_clusters
        is used to pick out the right spikes
    waveforms : np.array
        not sure on shape yet but will be something like a
        a 4 x nSpikes x nSamples (4 for tetrode-based analysis)

    Notes
    -----
    Units for time are provided as per the sample rate but converted internally to milliseconds
    &#34;&#34;&#34;
    def __init__(self, spike_times, waveforms=None, **kwargs):
        self.spike_times = spike_times
        self.waveforms = waveforms
        self._event_ts = None # the times that events occured i.e. the laser came on
        self._spk_clusters = None # vector of cluster ids, same length as spike_times
        self._event_window = np.array((-0.050, 0.100)) # window, in seconds, either side of the stimulus, to examine
        self._stim_width = None # the width, in ms, of the stimulus
        self._secs_per_bin = 0.001 # used to increase / decrease size of bins in psth
        self._sample_rate = 30000
        self._duration = None

    @property
    def sample_rate(self):
        return self._sample_rate

    @sample_rate.setter
    def sample_rate(self, value):
        self._sample_rate = value

    def n_spikes(self, cluster=None):
        if cluster is None:
            return len(self.spike_times)
        else:
            if self.spk_clusters is None:
                warnings.warn(&#34;No clusters available, please load some into me.&#34;)
                return
            else:
                return np.count_nonzero(self._spk_clusters==cluster)

    @property
    def event_ts(self):
        return self._event_ts

    @event_ts.setter
    def event_ts(self, value):
        self._event_ts = value

    @property
    def duration(self):
        return self._duration

    @duration.setter
    def duration(self, value):
        self._duration = value

    @property
    def spk_clusters(self):
        return self._spk_clusters

    @spk_clusters.setter
    def spk_clusters(self, value):
        self._spk_clusters = value

    @property
    def event_window(self):
        return self._event_window

    @event_window.setter
    def event_window(self, value):
        self._event_window = value

    @property
    def stim_width(self):
        return self._stim_width

    @stim_width.setter
    def stim_width(self, value):
        self._stim_width = value

    @property
    def _secs_per_bin(self):
        return self.__secs_per_bin

    @_secs_per_bin.setter
    def _secs_per_bin(self, value):
        self.__secs_per_bin = value

    def trial_mean_fr(self, cluster: int)-&gt;float:
        # Returns the trial mean firing rate for the cluster
        if self.duration is None:
            warnings.warn(&#34;No duration provided, give me one!&#34;)
            return
        return self.n_spikes(cluster) / self.duration

    def mean_isi_range(self, cluster: int, n: int)-&gt;float:
        &#34;&#34;&#34;
        Calculates the mean of the autocorrelation from 0 to n milliseconds
        Used to help classify a neruons type (principal, interneuron etc)

        Parameters
        ----------
        cluster : int
            The cluster to analyse
        n : int
            The range in milliseconds to calculate the mean over

        Returns
        -------
        mean_isi_range : float
            The mean of the autocorrelogram between 0 and n milliseconds
        &#34;&#34;&#34;
        if cluster not in self.spk_clusters:
            warnings.warn(&#34;Cluster not available&#34;)
            return
        bins = 201
        trange = np.array((-500, 500))
        t = self.spike_times[self.spk_clusters==cluster]
        y = self.xcorr(t, Trange=trange)
        y = y.astype(np.int64) # See xcorr docs
        counts, bins = np.histogram(y[y!=0], bins=bins, range=trange)
        mask = np.logical_and(bins&gt;0, bins&lt;n)
        return np.mean(counts[mask[1:]])

    def xcorr(self, x1: np.array, x2=None, Trange=None, **kwargs)-&gt;np.ndarray:
        &#34;&#34;&#34;
        Calculates the histogram of the ISIs in x1 or x1 vs x2

        Parameters
        ----------
        x1, x2 : array_like
            The times of the spikes emitted by the cluster(s)
            NB must be signed int to accomodate negative times
        Trange : array_like
            Range of times to bin up. Defaults to [-500, +500] in ms

        Returns
        -------
        y : np.ndarray
            The time differences between spike times in x1 over the range
            of times defined Trange
        &#34;&#34;&#34;
        if x2 is None:
            x2 = x1.copy()
        if Trange is None:
            Trange = np.array([-500, 500])
        if type(Trange) == tuple:
            Trange = np.array(Trange)
        y = []
        irange = x1[:, np.newaxis] + Trange[np.newaxis, :]
        dts = np.searchsorted(x2, irange)
        for i, t in enumerate(dts):
            y.extend(x2[t[0]:t[1]] - x1[i])
        y = np.array(y, dtype=float)
        return y

    def calculatePSTH(self, cluster_id, **kwargs):
        &#34;&#34;&#34;
        Calculate the PSTH of event_ts against the spiking of a cell

        Parameters
        ----------
        cluster_id : int
            The cluster for which to calculate the psth

        Returns
        -------
        x, y : list
            The list of time differences between the spikes of the cluster
            and the events (x) and the trials (y)
        &#34;&#34;&#34;
        if self._event_ts is None:
            raise Exception(&#34;Need some event timestamps! Aborting&#34;)
        if self._spk_clusters is None:
            raise Exception(&#34;Need cluster identities! Aborting&#34;)
        event_ts = self.event_ts
        event_ts.sort()
        if type(event_ts) == list:
            event_ts = np.array(event_ts)

        spike_times = self.spike_times[self.spk_clusters == cluster_id]
        irange = event_ts[:, np.newaxis] + self.event_window[np.newaxis, :]
        dts = np.searchsorted(spike_times, irange)
        x = []
        y = []
        for i, t in enumerate(dts):
            tmp = spike_times[t[0]:t[1]] - event_ts[i]
            x.extend(tmp)
            y.extend(np.repeat(i,len(tmp)))
        return x, y

    def plotPSTH(self, cluster, fig=None):
        &#34;&#34;&#34;
        Plots the PSTH for a cluster

        Parameters
        ----------
        cluster : int
            The cluster to examine

        Returns
        -------
        cluster, i : int
            The cluster and a junk variable (not sure why for now)
        &#34;&#34;&#34;
        x, y = self.calculatePSTH(cluster)
        show = False # used below to show the figure or leave this to the caller
        if fig is None:
            fig = plt.figure(figsize=(4.0,7.0))
            show = True
        scatter_ax = fig.add_subplot(111)
        scatter_ax.scatter(x, y, marker=&#39;.&#39;, s=2, rasterized=False)
        divider = make_axes_locatable(scatter_ax)
        scatter_ax.set_xticks((self.event_window[0], 0, self.event_window[1]))
        scatter_ax.set_xticklabels((str(self.event_window[0]), &#39;0&#39;, str(self.event_window[1])))
        hist_ax = divider.append_axes(&#34;top&#34;, 0.95, pad=0.2, sharex=scatter_ax,
                                      transform=scatter_ax.transAxes)
        scattTrans = transforms.blended_transform_factory(scatter_ax.transData,
                                                          scatter_ax.transAxes)
        if self.stim_width is not None:
            scatter_ax.add_patch(Rectangle((0, 0), width=self.stim_width, height=1,
                        transform=scattTrans,
                        color=[0, 0, 1], alpha=0.5))
            histTrans = transforms.blended_transform_factory(hist_ax.transData,
                                                             hist_ax.transAxes)
            hist_ax.add_patch(Rectangle((0, 0), width=self.stim_width, height=1,
                              transform=histTrans,
                              color=[0, 0, 1], alpha=0.5))
        scatter_ax.set_ylabel(&#39;Laser stimulation events&#39;, labelpad=-18.5)
        scatter_ax.set_xlabel(&#39;Time to stimulus onset(secs)&#39;)
        nStms = int(len(self.event_ts))
        scatter_ax.set_ylim(0, nStms)
        # Label only the min and max of the y-axis
        ylabels = scatter_ax.get_yticklabels()
        for i in range(1, len(ylabels)-1):
            ylabels[i].set_visible(False)
        yticks = scatter_ax.get_yticklines()
        for i in range(1, len(yticks)-1):
            yticks[i].set_visible(False)
        histColor = [192/255.0,192/255.0,192/255.0]
        histX = hist_ax.hist(x, bins=np.arange(self.event_window[0], self.event_window[1] + self._secs_per_bin, self._secs_per_bin),
                             color=histColor, alpha=0.6, range=self.event_window, rasterized=True, histtype=&#39;stepfilled&#39;)
        hist_ax.set_ylabel(&#34;Spike count&#34;, labelpad=-2.5)
        plt.setp(hist_ax.get_xticklabels(), visible=False)
        # Label only the min and max of the y-axis
        ylabels = hist_ax.get_yticklabels()
        for i in range(1, len(ylabels)-1):
            ylabels[i].set_visible(False)
        yticks = hist_ax.get_yticklines()
        for i in range(1, len(yticks)-1):
            yticks[i].set_visible(False)
        hist_ax.set_xlim(self.event_window)
        scatter_ax.set_xlim(self.event_window)
        if show:
            plt.show()
        yield cluster, 1

    def plotAllXCorrs(self, clusters, fig=None):
        &#39;&#39;&#39;
        Plots all scorrs in a single figure window
        &#39;&#39;&#39;
        from ephysiopy.dacq2py import spikecalcs
        SpkCalcs = spikecalcs.SpikeCalcs()
        if fig is None:
            fig = plt.figure(figsize=(10,20))

        nrows = np.ceil(np.sqrt(len(clusters))).astype(int)
        fig.subplots_adjust(wspace=0.25,hspace=0.25)
        for i, cluster in enumerate(clusters):
            cluster_idx = np.nonzero(self.spk_clusters == cluster)[0]
            cluster_ts = np.ravel(self.spike_times[cluster_idx])
            ax = fig.add_subplot(nrows,nrows,i+1)
            y = SpkCalcs.xcorr(cluster_ts.T / float(self.sample_rate / 1000)) # ms
            ax.hist(y[y != 0], bins=201, range=[-500, 500], color=&#39;k&#39;, histtype=&#39;stepfilled&#39;)
            ax.set_xlim(-500,500)
            ax.set_xticks((-500, 0, 500))
            ax.set_xticklabels((str(-500), &#39;0&#39;, str(500)),fontweight=&#39;normal&#39;, size=8)
            ax.tick_params(axis=&#39;both&#39;, which=&#39;both&#39;, left=False, right=False,
                            bottom=False, top=False)
            ax.set_yticklabels(&#39;&#39;)
            ax.spines[&#39;right&#39;].set_visible(False)
            ax.spines[&#39;top&#39;].set_visible(False)
            ax.spines[&#39;left&#39;].set_visible(False)
            ax.xaxis.set_ticks_position(&#39;bottom&#39;)
            ax.set_title(cluster, fontweight=&#39;bold&#39;, size=10, pad=1)
        plt.show()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsProbe" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsProbe">SpikeCalcsProbe</a></li>
<li><a title="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsTetrode" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsTetrode">SpikeCalcsTetrode</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.duration"><code class="name">var <span class="ident">duration</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def duration(self):
    return self._duration</code></pre>
</details>
</dd>
<dt id="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.event_ts"><code class="name">var <span class="ident">event_ts</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def event_ts(self):
    return self._event_ts</code></pre>
</details>
</dd>
<dt id="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.event_window"><code class="name">var <span class="ident">event_window</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def event_window(self):
    return self._event_window</code></pre>
</details>
</dd>
<dt id="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.sample_rate"><code class="name">var <span class="ident">sample_rate</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sample_rate(self):
    return self._sample_rate</code></pre>
</details>
</dd>
<dt id="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.spk_clusters"><code class="name">var <span class="ident">spk_clusters</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spk_clusters(self):
    return self._spk_clusters</code></pre>
</details>
</dd>
<dt id="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.stim_width"><code class="name">var <span class="ident">stim_width</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def stim_width(self):
    return self._stim_width</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.calculatePSTH"><code class="name flex">
<span>def <span class="ident">calculatePSTH</span></span>(<span>self, cluster_id, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculate the PSTH of event_ts against the spiking of a cell</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cluster_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The cluster for which to calculate the psth</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>x</code></strong>, <strong><code>y</code></strong> :&ensp;<code>list</code></dt>
<dd>The list of time differences between the spikes of the cluster
and the events (x) and the trials (y)</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculatePSTH(self, cluster_id, **kwargs):
    &#34;&#34;&#34;
    Calculate the PSTH of event_ts against the spiking of a cell

    Parameters
    ----------
    cluster_id : int
        The cluster for which to calculate the psth

    Returns
    -------
    x, y : list
        The list of time differences between the spikes of the cluster
        and the events (x) and the trials (y)
    &#34;&#34;&#34;
    if self._event_ts is None:
        raise Exception(&#34;Need some event timestamps! Aborting&#34;)
    if self._spk_clusters is None:
        raise Exception(&#34;Need cluster identities! Aborting&#34;)
    event_ts = self.event_ts
    event_ts.sort()
    if type(event_ts) == list:
        event_ts = np.array(event_ts)

    spike_times = self.spike_times[self.spk_clusters == cluster_id]
    irange = event_ts[:, np.newaxis] + self.event_window[np.newaxis, :]
    dts = np.searchsorted(spike_times, irange)
    x = []
    y = []
    for i, t in enumerate(dts):
        tmp = spike_times[t[0]:t[1]] - event_ts[i]
        x.extend(tmp)
        y.extend(np.repeat(i,len(tmp)))
    return x, y</code></pre>
</details>
</dd>
<dt id="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.mean_isi_range"><code class="name flex">
<span>def <span class="ident">mean_isi_range</span></span>(<span>self, cluster, n)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates the mean of the autocorrelation from 0 to n milliseconds
Used to help classify a neruons type (principal, interneuron etc)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cluster</code></strong> :&ensp;<code>int</code></dt>
<dd>The cluster to analyse</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>The range in milliseconds to calculate the mean over</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mean_isi_range</code></strong> :&ensp;<code>float</code></dt>
<dd>The mean of the autocorrelogram between 0 and n milliseconds</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean_isi_range(self, cluster: int, n: int)-&gt;float:
    &#34;&#34;&#34;
    Calculates the mean of the autocorrelation from 0 to n milliseconds
    Used to help classify a neruons type (principal, interneuron etc)

    Parameters
    ----------
    cluster : int
        The cluster to analyse
    n : int
        The range in milliseconds to calculate the mean over

    Returns
    -------
    mean_isi_range : float
        The mean of the autocorrelogram between 0 and n milliseconds
    &#34;&#34;&#34;
    if cluster not in self.spk_clusters:
        warnings.warn(&#34;Cluster not available&#34;)
        return
    bins = 201
    trange = np.array((-500, 500))
    t = self.spike_times[self.spk_clusters==cluster]
    y = self.xcorr(t, Trange=trange)
    y = y.astype(np.int64) # See xcorr docs
    counts, bins = np.histogram(y[y!=0], bins=bins, range=trange)
    mask = np.logical_and(bins&gt;0, bins&lt;n)
    return np.mean(counts[mask[1:]])</code></pre>
</details>
</dd>
<dt id="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.n_spikes"><code class="name flex">
<span>def <span class="ident">n_spikes</span></span>(<span>self, cluster=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def n_spikes(self, cluster=None):
    if cluster is None:
        return len(self.spike_times)
    else:
        if self.spk_clusters is None:
            warnings.warn(&#34;No clusters available, please load some into me.&#34;)
            return
        else:
            return np.count_nonzero(self._spk_clusters==cluster)</code></pre>
</details>
</dd>
<dt id="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.plotAllXCorrs"><code class="name flex">
<span>def <span class="ident">plotAllXCorrs</span></span>(<span>self, clusters, fig=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots all scorrs in a single figure window</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotAllXCorrs(self, clusters, fig=None):
    &#39;&#39;&#39;
    Plots all scorrs in a single figure window
    &#39;&#39;&#39;
    from ephysiopy.dacq2py import spikecalcs
    SpkCalcs = spikecalcs.SpikeCalcs()
    if fig is None:
        fig = plt.figure(figsize=(10,20))

    nrows = np.ceil(np.sqrt(len(clusters))).astype(int)
    fig.subplots_adjust(wspace=0.25,hspace=0.25)
    for i, cluster in enumerate(clusters):
        cluster_idx = np.nonzero(self.spk_clusters == cluster)[0]
        cluster_ts = np.ravel(self.spike_times[cluster_idx])
        ax = fig.add_subplot(nrows,nrows,i+1)
        y = SpkCalcs.xcorr(cluster_ts.T / float(self.sample_rate / 1000)) # ms
        ax.hist(y[y != 0], bins=201, range=[-500, 500], color=&#39;k&#39;, histtype=&#39;stepfilled&#39;)
        ax.set_xlim(-500,500)
        ax.set_xticks((-500, 0, 500))
        ax.set_xticklabels((str(-500), &#39;0&#39;, str(500)),fontweight=&#39;normal&#39;, size=8)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;both&#39;, left=False, right=False,
                        bottom=False, top=False)
        ax.set_yticklabels(&#39;&#39;)
        ax.spines[&#39;right&#39;].set_visible(False)
        ax.spines[&#39;top&#39;].set_visible(False)
        ax.spines[&#39;left&#39;].set_visible(False)
        ax.xaxis.set_ticks_position(&#39;bottom&#39;)
        ax.set_title(cluster, fontweight=&#39;bold&#39;, size=10, pad=1)
    plt.show()</code></pre>
</details>
</dd>
<dt id="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.plotPSTH"><code class="name flex">
<span>def <span class="ident">plotPSTH</span></span>(<span>self, cluster, fig=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the PSTH for a cluster</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cluster</code></strong> :&ensp;<code>int</code></dt>
<dd>The cluster to examine</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>cluster</code></strong>, <strong><code>i</code></strong> :&ensp;<code>int</code></dt>
<dd>The cluster and a junk variable (not sure why for now)</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotPSTH(self, cluster, fig=None):
    &#34;&#34;&#34;
    Plots the PSTH for a cluster

    Parameters
    ----------
    cluster : int
        The cluster to examine

    Returns
    -------
    cluster, i : int
        The cluster and a junk variable (not sure why for now)
    &#34;&#34;&#34;
    x, y = self.calculatePSTH(cluster)
    show = False # used below to show the figure or leave this to the caller
    if fig is None:
        fig = plt.figure(figsize=(4.0,7.0))
        show = True
    scatter_ax = fig.add_subplot(111)
    scatter_ax.scatter(x, y, marker=&#39;.&#39;, s=2, rasterized=False)
    divider = make_axes_locatable(scatter_ax)
    scatter_ax.set_xticks((self.event_window[0], 0, self.event_window[1]))
    scatter_ax.set_xticklabels((str(self.event_window[0]), &#39;0&#39;, str(self.event_window[1])))
    hist_ax = divider.append_axes(&#34;top&#34;, 0.95, pad=0.2, sharex=scatter_ax,
                                  transform=scatter_ax.transAxes)
    scattTrans = transforms.blended_transform_factory(scatter_ax.transData,
                                                      scatter_ax.transAxes)
    if self.stim_width is not None:
        scatter_ax.add_patch(Rectangle((0, 0), width=self.stim_width, height=1,
                    transform=scattTrans,
                    color=[0, 0, 1], alpha=0.5))
        histTrans = transforms.blended_transform_factory(hist_ax.transData,
                                                         hist_ax.transAxes)
        hist_ax.add_patch(Rectangle((0, 0), width=self.stim_width, height=1,
                          transform=histTrans,
                          color=[0, 0, 1], alpha=0.5))
    scatter_ax.set_ylabel(&#39;Laser stimulation events&#39;, labelpad=-18.5)
    scatter_ax.set_xlabel(&#39;Time to stimulus onset(secs)&#39;)
    nStms = int(len(self.event_ts))
    scatter_ax.set_ylim(0, nStms)
    # Label only the min and max of the y-axis
    ylabels = scatter_ax.get_yticklabels()
    for i in range(1, len(ylabels)-1):
        ylabels[i].set_visible(False)
    yticks = scatter_ax.get_yticklines()
    for i in range(1, len(yticks)-1):
        yticks[i].set_visible(False)
    histColor = [192/255.0,192/255.0,192/255.0]
    histX = hist_ax.hist(x, bins=np.arange(self.event_window[0], self.event_window[1] + self._secs_per_bin, self._secs_per_bin),
                         color=histColor, alpha=0.6, range=self.event_window, rasterized=True, histtype=&#39;stepfilled&#39;)
    hist_ax.set_ylabel(&#34;Spike count&#34;, labelpad=-2.5)
    plt.setp(hist_ax.get_xticklabels(), visible=False)
    # Label only the min and max of the y-axis
    ylabels = hist_ax.get_yticklabels()
    for i in range(1, len(ylabels)-1):
        ylabels[i].set_visible(False)
    yticks = hist_ax.get_yticklines()
    for i in range(1, len(yticks)-1):
        yticks[i].set_visible(False)
    hist_ax.set_xlim(self.event_window)
    scatter_ax.set_xlim(self.event_window)
    if show:
        plt.show()
    yield cluster, 1</code></pre>
</details>
</dd>
<dt id="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.trial_mean_fr"><code class="name flex">
<span>def <span class="ident">trial_mean_fr</span></span>(<span>self, cluster)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trial_mean_fr(self, cluster: int)-&gt;float:
    # Returns the trial mean firing rate for the cluster
    if self.duration is None:
        warnings.warn(&#34;No duration provided, give me one!&#34;)
        return
    return self.n_spikes(cluster) / self.duration</code></pre>
</details>
</dd>
<dt id="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.xcorr"><code class="name flex">
<span>def <span class="ident">xcorr</span></span>(<span>self, x1, x2=None, Trange=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates the histogram of the ISIs in x1 or x1 vs x2</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x1</code></strong>, <strong><code>x2</code></strong> :&ensp;<code>array_like</code></dt>
<dd>The times of the spikes emitted by the cluster(s)
NB must be signed int to accomodate negative times</dd>
<dt><strong><code>Trange</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Range of times to bin up. Defaults to [-500, +500] in ms</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The time differences between spike times in x1 over the range
of times defined Trange</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xcorr(self, x1: np.array, x2=None, Trange=None, **kwargs)-&gt;np.ndarray:
    &#34;&#34;&#34;
    Calculates the histogram of the ISIs in x1 or x1 vs x2

    Parameters
    ----------
    x1, x2 : array_like
        The times of the spikes emitted by the cluster(s)
        NB must be signed int to accomodate negative times
    Trange : array_like
        Range of times to bin up. Defaults to [-500, +500] in ms

    Returns
    -------
    y : np.ndarray
        The time differences between spike times in x1 over the range
        of times defined Trange
    &#34;&#34;&#34;
    if x2 is None:
        x2 = x1.copy()
    if Trange is None:
        Trange = np.array([-500, 500])
    if type(Trange) == tuple:
        Trange = np.array(Trange)
    y = []
    irange = x1[:, np.newaxis] + Trange[np.newaxis, :]
    dts = np.searchsorted(x2, irange)
    for i, t in enumerate(dts):
        y.extend(x2[t[0]:t[1]] - x1[i])
    y = np.array(y, dtype=float)
    return y</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsProbe"><code class="flex name class">
<span>class <span class="ident">SpikeCalcsProbe</span></span>
</code></dt>
<dd>
<section class="desc"><p>Encapsulates methods specific to probe-based recordings</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SpikeCalcsProbe(SpikeCalcsGeneric):
    &#34;&#34;&#34;
    Encapsulates methods specific to probe-based recordings
    &#34;&#34;&#34;
    def __init__(self):
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric">SpikeCalcsGeneric</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric">SpikeCalcsGeneric</a></b></code>:
<ul class="hlist">
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.calculatePSTH" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.calculatePSTH">calculatePSTH</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.mean_isi_range" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.mean_isi_range">mean_isi_range</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.plotAllXCorrs" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.plotAllXCorrs">plotAllXCorrs</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.plotPSTH" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.plotPSTH">plotPSTH</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.xcorr" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.xcorr">xcorr</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsTetrode"><code class="flex name class">
<span>class <span class="ident">SpikeCalcsTetrode</span></span>
</code></dt>
<dd>
<section class="desc"><p>Encapsulates methods specific to the geometry inherent in tetrode-based
recordings</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SpikeCalcsTetrode(SpikeCalcsGeneric):
    &#34;&#34;&#34;
    Encapsulates methods specific to the geometry inherent in tetrode-based
    recordings
    &#34;&#34;&#34;
    def __init__(self):
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric">SpikeCalcsGeneric</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric">SpikeCalcsGeneric</a></b></code>:
<ul class="hlist">
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.calculatePSTH" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.calculatePSTH">calculatePSTH</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.mean_isi_range" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.mean_isi_range">mean_isi_range</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.plotAllXCorrs" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.plotAllXCorrs">plotAllXCorrs</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.plotPSTH" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.plotPSTH">plotPSTH</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.xcorr" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.xcorr">xcorr</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ephysiopy.ephys_generic" href="index.html">ephysiopy.ephys_generic</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ephysiopy.ephys_generic.ephys_generic.EEGCalcsGeneric" href="#ephysiopy.ephys_generic.ephys_generic.EEGCalcsGeneric">EEGCalcsGeneric</a></code></h4>
<ul class="">
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.EEGCalcsGeneric.butterFilter" href="#ephysiopy.ephys_generic.ephys_generic.EEGCalcsGeneric.butterFilter">butterFilter</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.EEGCalcsGeneric.calcEEGPowerSpectrum" href="#ephysiopy.ephys_generic.ephys_generic.EEGCalcsGeneric.calcEEGPowerSpectrum">calcEEGPowerSpectrum</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.EEGCalcsGeneric.plotEventEEG" href="#ephysiopy.ephys_generic.ephys_generic.EEGCalcsGeneric.plotEventEEG">plotEventEEG</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.EEGCalcsGeneric.plotPowerSpectrum" href="#ephysiopy.ephys_generic.ephys_generic.EEGCalcsGeneric.plotPowerSpectrum">plotPowerSpectrum</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric" href="#ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric">MapCalcsGeneric</a></code></h4>
<ul class="">
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.good_clusters" href="#ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.good_clusters">good_clusters</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.makeHDPlot" href="#ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.makeHDPlot">makeHDPlot</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.makeRateMap" href="#ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.makeRateMap">makeRateMap</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.makeSpeedVsHeadDirectionPlot" href="#ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.makeSpeedVsHeadDirectionPlot">makeSpeedVsHeadDirectionPlot</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.makeSpeedVsRatePlot" href="#ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.makeSpeedVsRatePlot">makeSpeedVsRatePlot</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.makeSpikePathPlot" href="#ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.makeSpikePathPlot">makeSpikePathPlot</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.plotAll" href="#ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.plotAll">plotAll</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.ppm" href="#ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.ppm">ppm</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.spk_clusters" href="#ephysiopy.ephys_generic.ephys_generic.MapCalcsGeneric.spk_clusters">spk_clusters</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric" href="#ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric">PosCalcsGeneric</a></code></h4>
<ul class="two-column">
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.calcSpeed" href="#ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.calcSpeed">calcSpeed</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.interpnans" href="#ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.interpnans">interpnans</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.postprocesspos" href="#ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.postprocesspos">postprocesspos</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.smoothPos" href="#ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.smoothPos">smoothPos</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.speedfilter" href="#ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.speedfilter">speedfilter</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.upsamplePos" href="#ephysiopy.ephys_generic.ephys_generic.PosCalcsGeneric.upsamplePos">upsamplePos</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric">SpikeCalcsGeneric</a></code></h4>
<ul class="two-column">
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.calculatePSTH" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.calculatePSTH">calculatePSTH</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.duration" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.duration">duration</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.event_ts" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.event_ts">event_ts</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.event_window" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.event_window">event_window</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.mean_isi_range" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.mean_isi_range">mean_isi_range</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.n_spikes" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.n_spikes">n_spikes</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.plotAllXCorrs" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.plotAllXCorrs">plotAllXCorrs</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.plotPSTH" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.plotPSTH">plotPSTH</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.sample_rate" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.sample_rate">sample_rate</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.spk_clusters" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.spk_clusters">spk_clusters</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.stim_width" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.stim_width">stim_width</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.trial_mean_fr" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.trial_mean_fr">trial_mean_fr</a></code></li>
<li><code><a title="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.xcorr" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsGeneric.xcorr">xcorr</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsProbe" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsProbe">SpikeCalcsProbe</a></code></h4>
</li>
<li>
<h4><code><a title="ephysiopy.ephys_generic.ephys_generic.SpikeCalcsTetrode" href="#ephysiopy.ephys_generic.ephys_generic.SpikeCalcsTetrode">SpikeCalcsTetrode</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>