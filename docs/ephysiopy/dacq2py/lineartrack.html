<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>ephysiopy.dacq2py.lineartrack API documentation</title>
<meta name="description" content="Created on Mon Apr 21 15:01:45 2014 â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ephysiopy.dacq2py.lineartrack</code></h1>
</header>
<section id="section-intro">
<p>Created on Mon Apr 21 15:01:45 2014</p>
<p>@author: Robin</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Mon Apr 21 15:01:45 2014

@author: Robin
&#34;&#34;&#34;
import numpy as np
from scipy import interpolate, signal, spatial, misc, stats, ndimage, interpolate, optimize
import matplotlib
import os
import re
from glob import glob
import subprocess
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as colors
from matplotlib.lines import Line2D
from matplotlib.patches import Rectangle
import matplotlib.transforms as transforms
from matplotlib.transforms import offset_copy
from matplotlib.widgets import Button, RadioButtons
from matplotlib.backends.backend_pdf import PdfPages
from mpl_toolkits.axes_grid1 import make_axes_locatable
import warnings
from ephysiopy import dacq2py
from ephysiopy.dacq2py import tintcolours as tcols
from astropy.convolution import convolve
from sklearn.decomposition import PCA
from scikits import bootstrap
from ephysiopy.dacq2py import gridcell
from itertools import combinations
from mpl_toolkits.axes_grid1 import ImageGrid
import skimage, skimage.morphology, skimage.feature
from ephysiopy.dacq2py.dacq2py_util import Trial
from ephysiopy.dacq2py import spikecalcs

class LTrack(Trial):
        &#39;&#39;&#39;
        Class definition
        &#39;&#39;&#39;
        def __init__(self, fname_root):
                self.fname_root = fname_root
                self._figNum = None
                self._min_spks = 1
                self._getAvailableFiles()
                for fs in self._available_files:
                        if &#39;log&#39; in fs:
                                self._logData = self._getLogData()
                self.POS = dacq2py.Pos(fname_root) # load pos by default
                self.POS.postprocesspos() # and postprocess
                self._xlims = (int(self.POS.header[&#39;window_min_x&#39;]), int(self.POS.header[&#39;window_max_x&#39;]))
                self._ylims = (int(self.POS.header[&#39;window_min_y&#39;]), int(self.POS.header[&#39;window_max_y&#39;]))
                try:
                        self.EEG = dacq2py.EEG(fname_root)
#            self.EEG.thetaAmpPhase()
                except IOError:
                        self.EEG = None
                self.setheader = self.POS.getHeader(self.fname_root + &#39;.set&#39;)
                if &#39;minX&#39; in self.setheader[&#39;comments&#39;]:
                        minmaxRE = re.compile(&#39;minX\s+=\s+(\d+)\D\s+maxX\s+=\s+(\d+)&#39;)
                        m = minmaxRE.findall(self.setheader[&#39;comments&#39;])
                        self._laser_edges = (int(m[0][0]), int(m[0][1]))
                else:
                        self._laser_edges = None
                self.TETRODE = {} # a dict to hold all tetrodes - only loaded as and when needed
                self.LOG = {}
                self.spikecalcs = spikecalcs()
                self.posFilter = None # can be a dict used to filter pos e.g. {&#39;dir&#39;: (225, 315)}
                
                
                self._ptSize = 40
                self._lines = None
                self._path = None
                self._pathSpks = None
                self._eeglines = None
                self._eeglines2 = None
                self._eegspks = None
                self._eegfirst = None
                self._ppText = None
                self._posText = None
                self._eegText = None
                self._pts = None
                self._firstSpks = None
                self._regressRunLine = None
                self._pathFirstSpks = None
                self.pp_patch = None
                self.pos_patch = None
                self.eeg_patch = None
                self._xticks = None
                self._runIdx = 0
                

        def _getClusterXPos(self, tetrode, cluster):
                &#39;&#39;&#39;
                Returns the x pos of a given cluster taking account of any masking
                &#39;&#39;&#39;
                idx = self.TETRODE[tetrode].getClustIdx(cluster)
                x = self.POS.xy[0, idx]
                return x

        def plotPhaseVsX(self, tetrode, cluster, ax=None):
                &#39;&#39;&#39;
                Plots phase of theta cycle at which a given cluster on a given tetrode
                fired against x position (used for linear track analysis).
                Pos filters are applied if present
                &#39;&#39;&#39;
                if not self.EEG:
                        self.EEG = dacq2py.EEG(self.filename_root)
                x_pos = self._getClusterXPos(tetrode, cluster)
                x_pos = np.ma.hstack((x_pos, x_pos))  # duplicate for 720 degree plot
                x_phase = self._getClusterPhaseVals(tetrode, cluster)
                x_phase = np.ma.hstack((x_phase, x_phase + (2*np.pi)))
                if ax is None:
                        ax = plt.gca()
                else:
                        ax = ax
                ax.plot(x_pos, x_phase, &#39;.&#39;)
                ax.set_xlim(self._xlims)
                        
        def plotPPperRun(self, tetrode, cluster):
                self.__checkTetrodeLoaded__(tetrode)
                if not self.EEG:
                        self.EEG = dacq2py.EEG(self.fname_root)
                self.EEG.sm_eeg = self.EEG.eegfilter()
                idx = self.TETRODE[tetrode].getClustIdx(cluster)
                
                # remove any pos filtering to get peaks and troughs
                old_filter = self.posFilter
#        old_x_mask = 
                self.posFilter = None
                peaks, troughs = self._getThetaCycles()
                clust_ts = self.TETRODE[tetrode].getClustTS(cluster)
                firstSpk = self._getSpikeInCycle(peaks, clust_ts)
                self.firstSpkEEGIdx = firstSpk
                self.firstSpkPosIdx = firstSpk / 5
                self.posFilter = old_filter
                
                t = self._getClusterPhaseVals(tetrode, cluster)
                x = self._getClusterXPos(tetrode, cluster)
                label, xe, _ = self._getFieldLims(tetrode, cluster)
                xInField = xe[label.nonzero()[1]]
                mask = np.logical_and(x &gt; np.min(xInField), x &lt; np.max(xInField)) # same length as idx (nSpikes in cluster)
                # combine this mask with the possibly pre-existing one for the x and phase data if pos filtering has been applied
                x = np.ma.masked_where(~mask, x)
                t = np.ma.masked_where(~mask, t)
                
                # keep x between -1 and +1
                self.mnx = np.ma.mean(x)
                xn = x - self.mnx
                self.mxx = np.ma.max(np.ma.abs(xn))
                x = xn / self.mxx
                self.x = x
                self.t = t
                self.idx = idx
                
                slope, intercept = self.circRegress(x, t)
                rho, p, rho_boot, p_shuff, ci = self.circCircCorrTLinear(x, t)
                self.fig, self.ax = plt.subplots(num=self._figNum, figsize=(8.27, 11.69))
                
                plt.subplots_adjust(bottom=0.3, top=0.85)
                self.ptcolor = tcols.colours[0]
                self.pts = self.ax.scatter(x, t, color = self.ptcolor, s=self._ptSize)
                self.ax.plot((-1, 1), (-slope + intercept, slope + intercept), &#39;r&#39;, lw=3)
                
                plt.axis([-1,1,-np.pi,np.pi])
                
                runs, spks, durations = self.getFieldRuns(tetrode, cluster)
                self.runs = runs
                self.spks = spks
                # path axis
                self.posAx = self.fig.add_axes([0.125, 0.02, 0.775, 0.1])
                self.posAx.plot(self.POS.xy[0], self.POS.xy[1], color=self.ptcolor)
                self.posAx.set_xlim((np.min(xInField),np.max(xInField)))
                self.posAx.set_ylim(self._ylims)
#        self.posAx.set_aspect(&#39;equal&#39;)
                plt.setp(self.posAx.get_xticklabels(), visible=False)
                plt.setp(self.posAx.get_yticklabels(), visible=False)
                # eeg axis
                self.eegaxis = self.fig.add_axes([0.125,0.15,0.775,0.1])
                self.eegaxis.set_xlim((np.min(xInField),np.max(xInField)))
                plt.setp(self.eegaxis.get_xticklabels(), visible=False)
                plt.setp(self.eegaxis.get_yticklabels(), visible=False)

                # next and previous buttons 
                self.nextax = plt.axes([0.5,0.9,0.1,0.05])
                self.nextbutton = Button(self.nextax, &#39;Next&#39;, color=&#39;r&#39;)
                self.nextbutton.on_clicked(self.nextRun)
                
                self.prevax = plt.axes([0.3,0.9,0.1,0.05])
                self.prevbutton = Button(self.prevax, &#39;Prev&#39;, color=&#39;r&#39;)
                self.prevbutton.on_clicked(self.prevRun)
                plt.show()
                
                self.update()
                
        def clear(self, ax, lines):
                if ax is not None:
                        for line in lines:
                                line.remove()
                        ax.figure.canvas.draw_idle()
                
        def update(self):
                pos_v = np.intersect1d(self.spks[self._runIdx],self.idx)
                this_idx = np.searchsorted(self.idx, pos_v)
                v = np.intersect1d(self.firstSpkPosIdx, pos_v)
                firstSpkIdx = np.searchsorted(self.idx, v)
#        self.clear(self._path, self._lines)
                if self._lines is not None:
                        for line in self._lines:
                                line.remove()
                if self._pts is not None:
                        self._pts.remove()
                if self._firstSpks is not None:
                        self._firstSpks.remove()
                if self._path is not None:
                        for line in self._path:
                                line.remove()
                if self._pathSpks is not None:
                        for line in self._pathSpks:
                                line.remove()
                if self._eeglines is not None:
                        for line in self._eeglines:
                                line.remove()
                if self._eeglines2 is not None:
                        for line in self._eeglines2:
                                line.remove()
                if self._eegspks is not None:
                        for line in self._eegspks:
                                line.remove()
                if self._eegfirst is not None:
                        for line in self._eegfirst:
                                line.remove()
                if self._ppText is not None:
                        for txt in self._ppText:
                                txt.remove()
                if self._posText is not None:
                        for txt in self._posText:
                                txt.remove()
                if self._eegText is not None:
                        for txt in self._eegText:
                                txt.remove()
                if self._regressRunLine is not None:
                        for line in self._regressRunLine:
                                line.remove()
                if self._pathFirstSpks is not None:
                        for line in self._pathFirstSpks:
                                line.remove()
                if self._xticks is not None:
                        for line in self._xticks:
                                line.remove()
                if self.pp_patch is not None:
                        self.pp_patch.remove()
                if self.pos_patch is not None:
                        self.pos_patch.remove()
                if self.eeg_patch is not None:
                        self.eeg_patch.remove()
                self._lines = self.ax.plot(self.x[this_idx], self.t[this_idx],&#39;k&#39;,lw=1)
                self._pts = self.ax.scatter(self.x[this_idx], self.t[this_idx], c=&#39;b&#39;,s=self._ptSize)
                self._firstSpks = self.ax.scatter(self.x[firstSpkIdx], self.t[firstSpkIdx], c=&#39;r&#39;,s=self._ptSize)
                # plot the regeression line through the x-phase values in this run
                x = self.x[this_idx]
                t = self.t[this_idx]
#        mnx = np.ma.mean(x)
#        xn = x - mnx
#        mxx = np.ma.max(np.ma.abs(xn))
#        x = xn / mxx
                slope, intercept = self.circRegress(x, t)
                rho, p, rho_boot, p_shuff, ci = self.circCircCorrTLinear(x, t)
                self._regressRunLine = self.ax.plot((-1, 1), (-slope + intercept, slope + intercept), &#39;k--&#39;, lw=2)
                
                transOffset = offset_copy(self.ax.transData, fig=self.fig, x=5, y=5, units=&#39;dots&#39;)
                self._ppText = []
                for s,x,y in zip(range(len(this_idx)), self.x[this_idx], self.t[this_idx]):
                        self._ppText.append(self.ax.text(x, y, s=&#39;%d&#39; % (int(s)), fontsize=15, transform=transOffset))
                
                this_run = self.runs[self._runIdx]
                these_spks = self.spks[self._runIdx]
                self._path = self.posAx.plot(self.POS.xy[0,this_run],self.POS.xy[1,this_run],lw=3,c=&#39;k&#39;)
                self._pathSpks = self.posAx.plot(self.POS.xy[0,these_spks],self.POS.xy[1,these_spks],&#39;s&#39;, c=&#39;b&#39;, mec=&#39;b&#39;)
                self._pathFirstSpks = self.posAx.plot(self.POS.xy[0,v],self.POS.xy[1,v],&#39;s&#39;, c=&#39;r&#39;, mec=&#39;r&#39;)
                
                transOffset = offset_copy(self.posAx.transData, fig=self.fig, x=0, y=15, units=&#39;dots&#39;)
                
                self._posText = []
                for s,x,y in zip(range(len(these_spks)), self.POS.xy[0,these_spks], self.POS.xy[1,these_spks]):
                        self._posText.append(self.posAx.text(x, y, s=&#39;%d&#39; % (int(s)), fontsize=11, transform=transOffset))

                m = interpolate.interp1d(np.linspace(0,len(this_run), len(this_run)), self.POS.xy[0,this_run])
                x_new = m(np.linspace(0, len(this_run), len(self.EEG.sm_eeg[this_run[0] * self.pos2eegScale:this_run[-1] * self.pos2eegScale])))
                self._eeglines = self.eegaxis.plot(x_new, self.EEG.eeg[this_run[0]*5:this_run[-1]*5], c=[0.8627, 0.8627, 0.8627], lw=5)
                self._eeglines2 = self.eegaxis.plot(x_new, self.EEG.sm_eeg[this_run[0] * self.pos2eegScale:this_run[-1] * self.pos2eegScale], c=&#39;k&#39;)
                self._eegspks = self.eegaxis.plot(self.POS.xy[0,these_spks], self.EEG.sm_eeg[these_spks * self.pos2eegScale], &#39;|&#39;, ms=9, mew=3, c=&#39;b&#39;)
                self._eegfirst = self.eegaxis.plot(self.POS.xy[0,v], self.EEG.sm_eeg[v * self.pos2eegScale], &#39;|&#39;, ms=9, mew=3, c=&#39;r&#39;)
                
                transOffset = offset_copy(self.eegaxis.transData, fig=self.fig, x=0, y=13, units=&#39;dots&#39;)
                
                self._eegText = []
                for s,x,y in zip(range(len(these_spks)), self.POS.xy[0,these_spks], self.EEG.sm_eeg[these_spks * self.pos2eegScale]):
                        self._eegText.append(self.eegaxis.text(x, y, s=&#39;%d&#39; % (int(s)), fontsize=15, transform=transOffset))
                
                # add xticks/ lines at intervals of 1/10 seconds to the eeg plot
                self._xticks = []
                axtrans = transforms.blended_transform_factory(self.eegaxis.transData, self.eegaxis.transAxes)
                for xx in x_new[0:-1:int(self.EEG.sample_rate/10)]:
                        self._xticks.append(self.eegaxis.add_line(Line2D((xx,xx),(-1,1),c=&#39;b&#39;, ls=&#39;--&#39;,transform=axtrans)))


                # add the actual laser on/off position to the plots  as some kind of box        
                if self._laser_edges is not None:
                        log_data = self._getLogData()
                        log_ts = log_data[&#39;ts&#39;]  / 20
                        log_state = log_data[&#39;state&#39;]
                        laser_on_pos_idx = log_ts[log_state==&#39;on&#39;]
                        this_run_on = np.intersect1d(laser_on_pos_idx, this_run)
                        start_x = np.min(self.POS.xy[0,this_run_on])
                        end_x = np.max(self.POS.xy[0,this_run_on])
                        left_edge = (start_x - self.mnx) / self.mxx
                        right_edge = (end_x - self.mnx) / self.mxx
                        laserAxTrans = transforms.blended_transform_factory(self.ax.transData, self.ax.transAxes)
                        self.pp_patch = self.ax.add_patch(Rectangle((left_edge,0), width=np.diff((left_edge,right_edge)), 
                                                                   height=1, transform = laserAxTrans, color=[1,1,0], alpha=0.5))
                        laserAxTrans = transforms.blended_transform_factory(self.posAx.transData, self.posAx.transAxes)
                        self.pos_patch = self.posAx.add_patch(Rectangle((start_x,0), width=np.ptp((start_x, end_x)), 
                                                                   height=1, transform = laserAxTrans, color=[1,1,0], alpha=0.5))
                        laserAxTrans = transforms.blended_transform_factory(self.eegaxis.transData, self.eegaxis.transAxes)
                        self.eeg_patch = self.eegaxis.add_patch(Rectangle((start_x,0), width=np.ptp((start_x, end_x)), 
                                                                   height=1, transform = laserAxTrans, color=[1,1,0], alpha=0.5))
                
                
                self.eegaxis.figure.canvas.draw_idle()
                self.posAx.figure.canvas.draw_idle()
                self.ax.figure.canvas.draw_idle()
                
        def prevRun(self, event):
                if self._runIdx &lt;= 0:
                        self._runIdx = 0
                else:
                        self._runIdx -= 1
                self.update()
        def nextRun(self, event):
                if self._runIdx == len(self.runs):
                        self._runIdx = len(self.runs)
                else:
                        self._runIdx += 1
                self.update()


class LinearTrackTrial(Trial):
        def plotLTSpikesRateMap(self, tetrode, cluster, clamp=True, ax=None):
                &#39;&#39;&#39;
                ====
                plotLTSpikesRateMap
                ====

                Definition: plotSpikesOnPath(tetrode, clusters, clamp=True)

                ----

                Plots the spikes on the path during a trial for a particular tetrode/
                cluster(s) with the ratemap below and a histogram of the spikes vs x
                above the spike / pos plot + a kernel smoothed density estimate of the
                smoothed spike/ pos data. Only does this for a single cluster (not multiple)

                Parameters
                ----------
                tetrode: integer
                                 the tetrode you want to look at
                cluster: integer, 1xn array/ list
                                 a single number or list (or 1xn array) of the clusters to plot
                clamp:   bool, optional
                                 whether to restrict the plot to the self._xlims and self_ylims
                                 property

                &#39;&#39;&#39;
                xy = self._getPath()
                fig = plt.figure(self._figNum)

                if ax is None:
                        ax = fig.add_subplot(1, 1, 1)

                idx = self.TETRODE[tetrode].getClustIdx(cluster)
                ax.plot(xy[0], xy[1], c=tcols.colours[0], zorder=1)
                ax.plot(xy[0, idx], xy[1, idx], &#39;s&#39;, c=tcols.colours[cluster],
                                mec=tcols.colours[cluster])
                ax.set_xlim(self._xlims)
                ax.set_ylim(self._ylims)
                ax.set_aspect(&#39;equal&#39;)

                divider = make_axes_locatable(ax)
                axHistx = divider.append_axes(&#34;top&#34;, 1.2, pad=0.1, sharex=ax)

                binsize = self.__getBinUnits__()
                if np.ma.is_masked(self.POS.xy[0]):
                        mask = ~np.ma.getmask(self.POS.xy[0])
                        mask = mask.nonzero()[0]
                        idx = idx[np.in1d(idx, mask)]

                axHistx.hist(self.POS.xy[0, idx], bins=self.binsize[1],
                                         range=self._xlims)[0]
                # calculate and plot the kernel smoothed density estimate
                kde = stats.gaussian_kde(self.POS.xy[0, idx])
                # calculate the amount to normalise kde by
                norm = len(self.POS.xy[0, idx]) * (np.float(np.ptp(self._xlims)) / binsize[1])
                grid = np.linspace(self._xlims[0], self._xlims[1], binsize[1])
                z = kde.evaluate(grid)
                # normalise kde by the number of data points and the bin width
                z = z * norm
                axHistx.plot(grid, z, &#39;r&#39;)

                axRmap = divider.append_axes(&#34;bottom&#34;, 1.2, pad=0.1, sharex=ax, sharey=ax)
                rmap, ye, xe = self._getMap(tetrode, cluster)
                axRmap.imshow(rmap, extent=(xe[0], xe[-1], ye[0], ye[-1]),
                                          interpolation=&#39;nearest&#39;, origin=&#39;lower&#39;)

                plt.setp(axHistx.get_xticklabels() + axHistx.get_yticklabels(),
                                 visible=False)
                plt.setp(ax.get_xticklabels() + ax.get_yticklabels(), visible=False)
                plt.setp(axRmap.get_xticklabels() + axRmap.get_yticklabels(),
                                 visible=False)
                plt.show()

        def plotLTSpikesOnPath(self, tetrode, cluster, figNum=1):
                &#39;&#39;&#39;
                plotts a n row by 3 column plot:
                1st column is both directions of running
                2nd column is leftward runs
                3rd column is rightward runs
                &#39;&#39;&#39;
                self._figNum = figNum
                old_filter = self.posFilter
                self.posFilter = None
                self.plotSpikesOnPath(tetrode, cluster, colNum=1)
                self.posFilter = {&#39;dir&#39;: (315, 45)}
                self.plotSpikesOnPath(tetrode, cluster, colNum=2)
                self.posFilter = {&#39;dir&#39;: (135, 225)}
                self.plotSpikesOnPath(tetrode, cluster, colNum=3)
                self.posFilter = old_filter</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ephysiopy.dacq2py.lineartrack.LTrack"><code class="flex name class">
<span>class <span class="ident">LTrack</span></span>
<span>(</span><span>fname_root)</span>
</code></dt>
<dd>
<section class="desc"><p>Class definition</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename_root</code></strong> :&ensp;<code>str</code></dt>
<dd>The absolute filename without any suffix attached
i.e. C:\Robin\mytrial<pre><code>Note that when RH is using this can be just the trial name as the getFullFile method
tries to find the trial given the folder layout and the filename - see that method
for details
</code></pre>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>T</code></strong> :&ensp;<code>object</code></dt>
<dd>a dacq2py_util.Trial object</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; T = dacq2py_util.Trial(r'/media/robin/data/Dropbox/Science/Recordings/M851/M851_140908t1rh')
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LTrack(Trial):
        &#39;&#39;&#39;
        Class definition
        &#39;&#39;&#39;
        def __init__(self, fname_root):
                self.fname_root = fname_root
                self._figNum = None
                self._min_spks = 1
                self._getAvailableFiles()
                for fs in self._available_files:
                        if &#39;log&#39; in fs:
                                self._logData = self._getLogData()
                self.POS = dacq2py.Pos(fname_root) # load pos by default
                self.POS.postprocesspos() # and postprocess
                self._xlims = (int(self.POS.header[&#39;window_min_x&#39;]), int(self.POS.header[&#39;window_max_x&#39;]))
                self._ylims = (int(self.POS.header[&#39;window_min_y&#39;]), int(self.POS.header[&#39;window_max_y&#39;]))
                try:
                        self.EEG = dacq2py.EEG(fname_root)
#            self.EEG.thetaAmpPhase()
                except IOError:
                        self.EEG = None
                self.setheader = self.POS.getHeader(self.fname_root + &#39;.set&#39;)
                if &#39;minX&#39; in self.setheader[&#39;comments&#39;]:
                        minmaxRE = re.compile(&#39;minX\s+=\s+(\d+)\D\s+maxX\s+=\s+(\d+)&#39;)
                        m = minmaxRE.findall(self.setheader[&#39;comments&#39;])
                        self._laser_edges = (int(m[0][0]), int(m[0][1]))
                else:
                        self._laser_edges = None
                self.TETRODE = {} # a dict to hold all tetrodes - only loaded as and when needed
                self.LOG = {}
                self.spikecalcs = spikecalcs()
                self.posFilter = None # can be a dict used to filter pos e.g. {&#39;dir&#39;: (225, 315)}
                
                
                self._ptSize = 40
                self._lines = None
                self._path = None
                self._pathSpks = None
                self._eeglines = None
                self._eeglines2 = None
                self._eegspks = None
                self._eegfirst = None
                self._ppText = None
                self._posText = None
                self._eegText = None
                self._pts = None
                self._firstSpks = None
                self._regressRunLine = None
                self._pathFirstSpks = None
                self.pp_patch = None
                self.pos_patch = None
                self.eeg_patch = None
                self._xticks = None
                self._runIdx = 0
                

        def _getClusterXPos(self, tetrode, cluster):
                &#39;&#39;&#39;
                Returns the x pos of a given cluster taking account of any masking
                &#39;&#39;&#39;
                idx = self.TETRODE[tetrode].getClustIdx(cluster)
                x = self.POS.xy[0, idx]
                return x

        def plotPhaseVsX(self, tetrode, cluster, ax=None):
                &#39;&#39;&#39;
                Plots phase of theta cycle at which a given cluster on a given tetrode
                fired against x position (used for linear track analysis).
                Pos filters are applied if present
                &#39;&#39;&#39;
                if not self.EEG:
                        self.EEG = dacq2py.EEG(self.filename_root)
                x_pos = self._getClusterXPos(tetrode, cluster)
                x_pos = np.ma.hstack((x_pos, x_pos))  # duplicate for 720 degree plot
                x_phase = self._getClusterPhaseVals(tetrode, cluster)
                x_phase = np.ma.hstack((x_phase, x_phase + (2*np.pi)))
                if ax is None:
                        ax = plt.gca()
                else:
                        ax = ax
                ax.plot(x_pos, x_phase, &#39;.&#39;)
                ax.set_xlim(self._xlims)
                        
        def plotPPperRun(self, tetrode, cluster):
                self.__checkTetrodeLoaded__(tetrode)
                if not self.EEG:
                        self.EEG = dacq2py.EEG(self.fname_root)
                self.EEG.sm_eeg = self.EEG.eegfilter()
                idx = self.TETRODE[tetrode].getClustIdx(cluster)
                
                # remove any pos filtering to get peaks and troughs
                old_filter = self.posFilter
#        old_x_mask = 
                self.posFilter = None
                peaks, troughs = self._getThetaCycles()
                clust_ts = self.TETRODE[tetrode].getClustTS(cluster)
                firstSpk = self._getSpikeInCycle(peaks, clust_ts)
                self.firstSpkEEGIdx = firstSpk
                self.firstSpkPosIdx = firstSpk / 5
                self.posFilter = old_filter
                
                t = self._getClusterPhaseVals(tetrode, cluster)
                x = self._getClusterXPos(tetrode, cluster)
                label, xe, _ = self._getFieldLims(tetrode, cluster)
                xInField = xe[label.nonzero()[1]]
                mask = np.logical_and(x &gt; np.min(xInField), x &lt; np.max(xInField)) # same length as idx (nSpikes in cluster)
                # combine this mask with the possibly pre-existing one for the x and phase data if pos filtering has been applied
                x = np.ma.masked_where(~mask, x)
                t = np.ma.masked_where(~mask, t)
                
                # keep x between -1 and +1
                self.mnx = np.ma.mean(x)
                xn = x - self.mnx
                self.mxx = np.ma.max(np.ma.abs(xn))
                x = xn / self.mxx
                self.x = x
                self.t = t
                self.idx = idx
                
                slope, intercept = self.circRegress(x, t)
                rho, p, rho_boot, p_shuff, ci = self.circCircCorrTLinear(x, t)
                self.fig, self.ax = plt.subplots(num=self._figNum, figsize=(8.27, 11.69))
                
                plt.subplots_adjust(bottom=0.3, top=0.85)
                self.ptcolor = tcols.colours[0]
                self.pts = self.ax.scatter(x, t, color = self.ptcolor, s=self._ptSize)
                self.ax.plot((-1, 1), (-slope + intercept, slope + intercept), &#39;r&#39;, lw=3)
                
                plt.axis([-1,1,-np.pi,np.pi])
                
                runs, spks, durations = self.getFieldRuns(tetrode, cluster)
                self.runs = runs
                self.spks = spks
                # path axis
                self.posAx = self.fig.add_axes([0.125, 0.02, 0.775, 0.1])
                self.posAx.plot(self.POS.xy[0], self.POS.xy[1], color=self.ptcolor)
                self.posAx.set_xlim((np.min(xInField),np.max(xInField)))
                self.posAx.set_ylim(self._ylims)
#        self.posAx.set_aspect(&#39;equal&#39;)
                plt.setp(self.posAx.get_xticklabels(), visible=False)
                plt.setp(self.posAx.get_yticklabels(), visible=False)
                # eeg axis
                self.eegaxis = self.fig.add_axes([0.125,0.15,0.775,0.1])
                self.eegaxis.set_xlim((np.min(xInField),np.max(xInField)))
                plt.setp(self.eegaxis.get_xticklabels(), visible=False)
                plt.setp(self.eegaxis.get_yticklabels(), visible=False)

                # next and previous buttons 
                self.nextax = plt.axes([0.5,0.9,0.1,0.05])
                self.nextbutton = Button(self.nextax, &#39;Next&#39;, color=&#39;r&#39;)
                self.nextbutton.on_clicked(self.nextRun)
                
                self.prevax = plt.axes([0.3,0.9,0.1,0.05])
                self.prevbutton = Button(self.prevax, &#39;Prev&#39;, color=&#39;r&#39;)
                self.prevbutton.on_clicked(self.prevRun)
                plt.show()
                
                self.update()
                
        def clear(self, ax, lines):
                if ax is not None:
                        for line in lines:
                                line.remove()
                        ax.figure.canvas.draw_idle()
                
        def update(self):
                pos_v = np.intersect1d(self.spks[self._runIdx],self.idx)
                this_idx = np.searchsorted(self.idx, pos_v)
                v = np.intersect1d(self.firstSpkPosIdx, pos_v)
                firstSpkIdx = np.searchsorted(self.idx, v)
#        self.clear(self._path, self._lines)
                if self._lines is not None:
                        for line in self._lines:
                                line.remove()
                if self._pts is not None:
                        self._pts.remove()
                if self._firstSpks is not None:
                        self._firstSpks.remove()
                if self._path is not None:
                        for line in self._path:
                                line.remove()
                if self._pathSpks is not None:
                        for line in self._pathSpks:
                                line.remove()
                if self._eeglines is not None:
                        for line in self._eeglines:
                                line.remove()
                if self._eeglines2 is not None:
                        for line in self._eeglines2:
                                line.remove()
                if self._eegspks is not None:
                        for line in self._eegspks:
                                line.remove()
                if self._eegfirst is not None:
                        for line in self._eegfirst:
                                line.remove()
                if self._ppText is not None:
                        for txt in self._ppText:
                                txt.remove()
                if self._posText is not None:
                        for txt in self._posText:
                                txt.remove()
                if self._eegText is not None:
                        for txt in self._eegText:
                                txt.remove()
                if self._regressRunLine is not None:
                        for line in self._regressRunLine:
                                line.remove()
                if self._pathFirstSpks is not None:
                        for line in self._pathFirstSpks:
                                line.remove()
                if self._xticks is not None:
                        for line in self._xticks:
                                line.remove()
                if self.pp_patch is not None:
                        self.pp_patch.remove()
                if self.pos_patch is not None:
                        self.pos_patch.remove()
                if self.eeg_patch is not None:
                        self.eeg_patch.remove()
                self._lines = self.ax.plot(self.x[this_idx], self.t[this_idx],&#39;k&#39;,lw=1)
                self._pts = self.ax.scatter(self.x[this_idx], self.t[this_idx], c=&#39;b&#39;,s=self._ptSize)
                self._firstSpks = self.ax.scatter(self.x[firstSpkIdx], self.t[firstSpkIdx], c=&#39;r&#39;,s=self._ptSize)
                # plot the regeression line through the x-phase values in this run
                x = self.x[this_idx]
                t = self.t[this_idx]
#        mnx = np.ma.mean(x)
#        xn = x - mnx
#        mxx = np.ma.max(np.ma.abs(xn))
#        x = xn / mxx
                slope, intercept = self.circRegress(x, t)
                rho, p, rho_boot, p_shuff, ci = self.circCircCorrTLinear(x, t)
                self._regressRunLine = self.ax.plot((-1, 1), (-slope + intercept, slope + intercept), &#39;k--&#39;, lw=2)
                
                transOffset = offset_copy(self.ax.transData, fig=self.fig, x=5, y=5, units=&#39;dots&#39;)
                self._ppText = []
                for s,x,y in zip(range(len(this_idx)), self.x[this_idx], self.t[this_idx]):
                        self._ppText.append(self.ax.text(x, y, s=&#39;%d&#39; % (int(s)), fontsize=15, transform=transOffset))
                
                this_run = self.runs[self._runIdx]
                these_spks = self.spks[self._runIdx]
                self._path = self.posAx.plot(self.POS.xy[0,this_run],self.POS.xy[1,this_run],lw=3,c=&#39;k&#39;)
                self._pathSpks = self.posAx.plot(self.POS.xy[0,these_spks],self.POS.xy[1,these_spks],&#39;s&#39;, c=&#39;b&#39;, mec=&#39;b&#39;)
                self._pathFirstSpks = self.posAx.plot(self.POS.xy[0,v],self.POS.xy[1,v],&#39;s&#39;, c=&#39;r&#39;, mec=&#39;r&#39;)
                
                transOffset = offset_copy(self.posAx.transData, fig=self.fig, x=0, y=15, units=&#39;dots&#39;)
                
                self._posText = []
                for s,x,y in zip(range(len(these_spks)), self.POS.xy[0,these_spks], self.POS.xy[1,these_spks]):
                        self._posText.append(self.posAx.text(x, y, s=&#39;%d&#39; % (int(s)), fontsize=11, transform=transOffset))

                m = interpolate.interp1d(np.linspace(0,len(this_run), len(this_run)), self.POS.xy[0,this_run])
                x_new = m(np.linspace(0, len(this_run), len(self.EEG.sm_eeg[this_run[0] * self.pos2eegScale:this_run[-1] * self.pos2eegScale])))
                self._eeglines = self.eegaxis.plot(x_new, self.EEG.eeg[this_run[0]*5:this_run[-1]*5], c=[0.8627, 0.8627, 0.8627], lw=5)
                self._eeglines2 = self.eegaxis.plot(x_new, self.EEG.sm_eeg[this_run[0] * self.pos2eegScale:this_run[-1] * self.pos2eegScale], c=&#39;k&#39;)
                self._eegspks = self.eegaxis.plot(self.POS.xy[0,these_spks], self.EEG.sm_eeg[these_spks * self.pos2eegScale], &#39;|&#39;, ms=9, mew=3, c=&#39;b&#39;)
                self._eegfirst = self.eegaxis.plot(self.POS.xy[0,v], self.EEG.sm_eeg[v * self.pos2eegScale], &#39;|&#39;, ms=9, mew=3, c=&#39;r&#39;)
                
                transOffset = offset_copy(self.eegaxis.transData, fig=self.fig, x=0, y=13, units=&#39;dots&#39;)
                
                self._eegText = []
                for s,x,y in zip(range(len(these_spks)), self.POS.xy[0,these_spks], self.EEG.sm_eeg[these_spks * self.pos2eegScale]):
                        self._eegText.append(self.eegaxis.text(x, y, s=&#39;%d&#39; % (int(s)), fontsize=15, transform=transOffset))
                
                # add xticks/ lines at intervals of 1/10 seconds to the eeg plot
                self._xticks = []
                axtrans = transforms.blended_transform_factory(self.eegaxis.transData, self.eegaxis.transAxes)
                for xx in x_new[0:-1:int(self.EEG.sample_rate/10)]:
                        self._xticks.append(self.eegaxis.add_line(Line2D((xx,xx),(-1,1),c=&#39;b&#39;, ls=&#39;--&#39;,transform=axtrans)))


                # add the actual laser on/off position to the plots  as some kind of box        
                if self._laser_edges is not None:
                        log_data = self._getLogData()
                        log_ts = log_data[&#39;ts&#39;]  / 20
                        log_state = log_data[&#39;state&#39;]
                        laser_on_pos_idx = log_ts[log_state==&#39;on&#39;]
                        this_run_on = np.intersect1d(laser_on_pos_idx, this_run)
                        start_x = np.min(self.POS.xy[0,this_run_on])
                        end_x = np.max(self.POS.xy[0,this_run_on])
                        left_edge = (start_x - self.mnx) / self.mxx
                        right_edge = (end_x - self.mnx) / self.mxx
                        laserAxTrans = transforms.blended_transform_factory(self.ax.transData, self.ax.transAxes)
                        self.pp_patch = self.ax.add_patch(Rectangle((left_edge,0), width=np.diff((left_edge,right_edge)), 
                                                                   height=1, transform = laserAxTrans, color=[1,1,0], alpha=0.5))
                        laserAxTrans = transforms.blended_transform_factory(self.posAx.transData, self.posAx.transAxes)
                        self.pos_patch = self.posAx.add_patch(Rectangle((start_x,0), width=np.ptp((start_x, end_x)), 
                                                                   height=1, transform = laserAxTrans, color=[1,1,0], alpha=0.5))
                        laserAxTrans = transforms.blended_transform_factory(self.eegaxis.transData, self.eegaxis.transAxes)
                        self.eeg_patch = self.eegaxis.add_patch(Rectangle((start_x,0), width=np.ptp((start_x, end_x)), 
                                                                   height=1, transform = laserAxTrans, color=[1,1,0], alpha=0.5))
                
                
                self.eegaxis.figure.canvas.draw_idle()
                self.posAx.figure.canvas.draw_idle()
                self.ax.figure.canvas.draw_idle()
                
        def prevRun(self, event):
                if self._runIdx &lt;= 0:
                        self._runIdx = 0
                else:
                        self._runIdx -= 1
                self.update()
        def nextRun(self, event):
                if self._runIdx == len(self.runs):
                        self._runIdx = len(self.runs)
                else:
                        self._runIdx += 1
                self.update()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ephysiopy.dacq2py.dacq2py_util.Trial" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial">Trial</a></li>
<li><a title="ephysiopy.dacq2py.axonaIO.IO" href="axonaIO.html#ephysiopy.dacq2py.axonaIO.IO">IO</a></li>
<li><a title="ephysiopy.ephys_generic.gridcell.SAC" href="../ephys_generic/gridcell.html#ephysiopy.ephys_generic.gridcell.SAC">SAC</a></li>
<li>builtins.dict</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ephysiopy.dacq2py.lineartrack.LTrack.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self, ax, lines)</span>
</code></dt>
<dd>
<section class="desc"><p>D.clear() -&gt; None.
Remove all items from D.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self, ax, lines):
        if ax is not None:
                for line in lines:
                        line.remove()
                ax.figure.canvas.draw_idle()</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.lineartrack.LTrack.nextRun"><code class="name flex">
<span>def <span class="ident">nextRun</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nextRun(self, event):
        if self._runIdx == len(self.runs):
                self._runIdx = len(self.runs)
        else:
                self._runIdx += 1
        self.update()</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.lineartrack.LTrack.plotPPperRun"><code class="name flex">
<span>def <span class="ident">plotPPperRun</span></span>(<span>self, tetrode, cluster)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">        def plotPPperRun(self, tetrode, cluster):
                self.__checkTetrodeLoaded__(tetrode)
                if not self.EEG:
                        self.EEG = dacq2py.EEG(self.fname_root)
                self.EEG.sm_eeg = self.EEG.eegfilter()
                idx = self.TETRODE[tetrode].getClustIdx(cluster)
                
                # remove any pos filtering to get peaks and troughs
                old_filter = self.posFilter
#        old_x_mask = 
                self.posFilter = None
                peaks, troughs = self._getThetaCycles()
                clust_ts = self.TETRODE[tetrode].getClustTS(cluster)
                firstSpk = self._getSpikeInCycle(peaks, clust_ts)
                self.firstSpkEEGIdx = firstSpk
                self.firstSpkPosIdx = firstSpk / 5
                self.posFilter = old_filter
                
                t = self._getClusterPhaseVals(tetrode, cluster)
                x = self._getClusterXPos(tetrode, cluster)
                label, xe, _ = self._getFieldLims(tetrode, cluster)
                xInField = xe[label.nonzero()[1]]
                mask = np.logical_and(x &gt; np.min(xInField), x &lt; np.max(xInField)) # same length as idx (nSpikes in cluster)
                # combine this mask with the possibly pre-existing one for the x and phase data if pos filtering has been applied
                x = np.ma.masked_where(~mask, x)
                t = np.ma.masked_where(~mask, t)
                
                # keep x between -1 and +1
                self.mnx = np.ma.mean(x)
                xn = x - self.mnx
                self.mxx = np.ma.max(np.ma.abs(xn))
                x = xn / self.mxx
                self.x = x
                self.t = t
                self.idx = idx
                
                slope, intercept = self.circRegress(x, t)
                rho, p, rho_boot, p_shuff, ci = self.circCircCorrTLinear(x, t)
                self.fig, self.ax = plt.subplots(num=self._figNum, figsize=(8.27, 11.69))
                
                plt.subplots_adjust(bottom=0.3, top=0.85)
                self.ptcolor = tcols.colours[0]
                self.pts = self.ax.scatter(x, t, color = self.ptcolor, s=self._ptSize)
                self.ax.plot((-1, 1), (-slope + intercept, slope + intercept), &#39;r&#39;, lw=3)
                
                plt.axis([-1,1,-np.pi,np.pi])
                
                runs, spks, durations = self.getFieldRuns(tetrode, cluster)
                self.runs = runs
                self.spks = spks
                # path axis
                self.posAx = self.fig.add_axes([0.125, 0.02, 0.775, 0.1])
                self.posAx.plot(self.POS.xy[0], self.POS.xy[1], color=self.ptcolor)
                self.posAx.set_xlim((np.min(xInField),np.max(xInField)))
                self.posAx.set_ylim(self._ylims)
#        self.posAx.set_aspect(&#39;equal&#39;)
                plt.setp(self.posAx.get_xticklabels(), visible=False)
                plt.setp(self.posAx.get_yticklabels(), visible=False)
                # eeg axis
                self.eegaxis = self.fig.add_axes([0.125,0.15,0.775,0.1])
                self.eegaxis.set_xlim((np.min(xInField),np.max(xInField)))
                plt.setp(self.eegaxis.get_xticklabels(), visible=False)
                plt.setp(self.eegaxis.get_yticklabels(), visible=False)

                # next and previous buttons 
                self.nextax = plt.axes([0.5,0.9,0.1,0.05])
                self.nextbutton = Button(self.nextax, &#39;Next&#39;, color=&#39;r&#39;)
                self.nextbutton.on_clicked(self.nextRun)
                
                self.prevax = plt.axes([0.3,0.9,0.1,0.05])
                self.prevbutton = Button(self.prevax, &#39;Prev&#39;, color=&#39;r&#39;)
                self.prevbutton.on_clicked(self.prevRun)
                plt.show()
                
                self.update()</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.lineartrack.LTrack.plotPhaseVsX"><code class="name flex">
<span>def <span class="ident">plotPhaseVsX</span></span>(<span>self, tetrode, cluster, ax=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots phase of theta cycle at which a given cluster on a given tetrode
fired against x position (used for linear track analysis).
Pos filters are applied if present</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotPhaseVsX(self, tetrode, cluster, ax=None):
        &#39;&#39;&#39;
        Plots phase of theta cycle at which a given cluster on a given tetrode
        fired against x position (used for linear track analysis).
        Pos filters are applied if present
        &#39;&#39;&#39;
        if not self.EEG:
                self.EEG = dacq2py.EEG(self.filename_root)
        x_pos = self._getClusterXPos(tetrode, cluster)
        x_pos = np.ma.hstack((x_pos, x_pos))  # duplicate for 720 degree plot
        x_phase = self._getClusterPhaseVals(tetrode, cluster)
        x_phase = np.ma.hstack((x_phase, x_phase + (2*np.pi)))
        if ax is None:
                ax = plt.gca()
        else:
                ax = ax
        ax.plot(x_pos, x_phase, &#39;.&#39;)
        ax.set_xlim(self._xlims)</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.lineartrack.LTrack.prevRun"><code class="name flex">
<span>def <span class="ident">prevRun</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prevRun(self, event):
        if self._runIdx &lt;= 0:
                self._runIdx = 0
        else:
                self._runIdx -= 1
        self.update()</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.lineartrack.LTrack.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>D.update([E, ]**F) -&gt; None.
Update D from dict/iterable E and F.
If E is present and has a .keys() method, then does:
for k in E: D[k] = E[k]
If E is present and lacks a .keys() method, then does:
for k, v in E: D[k] = v
In either case, this is followed by: for k in F:
D[k] = F[k]</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">        def update(self):
                pos_v = np.intersect1d(self.spks[self._runIdx],self.idx)
                this_idx = np.searchsorted(self.idx, pos_v)
                v = np.intersect1d(self.firstSpkPosIdx, pos_v)
                firstSpkIdx = np.searchsorted(self.idx, v)
#        self.clear(self._path, self._lines)
                if self._lines is not None:
                        for line in self._lines:
                                line.remove()
                if self._pts is not None:
                        self._pts.remove()
                if self._firstSpks is not None:
                        self._firstSpks.remove()
                if self._path is not None:
                        for line in self._path:
                                line.remove()
                if self._pathSpks is not None:
                        for line in self._pathSpks:
                                line.remove()
                if self._eeglines is not None:
                        for line in self._eeglines:
                                line.remove()
                if self._eeglines2 is not None:
                        for line in self._eeglines2:
                                line.remove()
                if self._eegspks is not None:
                        for line in self._eegspks:
                                line.remove()
                if self._eegfirst is not None:
                        for line in self._eegfirst:
                                line.remove()
                if self._ppText is not None:
                        for txt in self._ppText:
                                txt.remove()
                if self._posText is not None:
                        for txt in self._posText:
                                txt.remove()
                if self._eegText is not None:
                        for txt in self._eegText:
                                txt.remove()
                if self._regressRunLine is not None:
                        for line in self._regressRunLine:
                                line.remove()
                if self._pathFirstSpks is not None:
                        for line in self._pathFirstSpks:
                                line.remove()
                if self._xticks is not None:
                        for line in self._xticks:
                                line.remove()
                if self.pp_patch is not None:
                        self.pp_patch.remove()
                if self.pos_patch is not None:
                        self.pos_patch.remove()
                if self.eeg_patch is not None:
                        self.eeg_patch.remove()
                self._lines = self.ax.plot(self.x[this_idx], self.t[this_idx],&#39;k&#39;,lw=1)
                self._pts = self.ax.scatter(self.x[this_idx], self.t[this_idx], c=&#39;b&#39;,s=self._ptSize)
                self._firstSpks = self.ax.scatter(self.x[firstSpkIdx], self.t[firstSpkIdx], c=&#39;r&#39;,s=self._ptSize)
                # plot the regeression line through the x-phase values in this run
                x = self.x[this_idx]
                t = self.t[this_idx]
#        mnx = np.ma.mean(x)
#        xn = x - mnx
#        mxx = np.ma.max(np.ma.abs(xn))
#        x = xn / mxx
                slope, intercept = self.circRegress(x, t)
                rho, p, rho_boot, p_shuff, ci = self.circCircCorrTLinear(x, t)
                self._regressRunLine = self.ax.plot((-1, 1), (-slope + intercept, slope + intercept), &#39;k--&#39;, lw=2)
                
                transOffset = offset_copy(self.ax.transData, fig=self.fig, x=5, y=5, units=&#39;dots&#39;)
                self._ppText = []
                for s,x,y in zip(range(len(this_idx)), self.x[this_idx], self.t[this_idx]):
                        self._ppText.append(self.ax.text(x, y, s=&#39;%d&#39; % (int(s)), fontsize=15, transform=transOffset))
                
                this_run = self.runs[self._runIdx]
                these_spks = self.spks[self._runIdx]
                self._path = self.posAx.plot(self.POS.xy[0,this_run],self.POS.xy[1,this_run],lw=3,c=&#39;k&#39;)
                self._pathSpks = self.posAx.plot(self.POS.xy[0,these_spks],self.POS.xy[1,these_spks],&#39;s&#39;, c=&#39;b&#39;, mec=&#39;b&#39;)
                self._pathFirstSpks = self.posAx.plot(self.POS.xy[0,v],self.POS.xy[1,v],&#39;s&#39;, c=&#39;r&#39;, mec=&#39;r&#39;)
                
                transOffset = offset_copy(self.posAx.transData, fig=self.fig, x=0, y=15, units=&#39;dots&#39;)
                
                self._posText = []
                for s,x,y in zip(range(len(these_spks)), self.POS.xy[0,these_spks], self.POS.xy[1,these_spks]):
                        self._posText.append(self.posAx.text(x, y, s=&#39;%d&#39; % (int(s)), fontsize=11, transform=transOffset))

                m = interpolate.interp1d(np.linspace(0,len(this_run), len(this_run)), self.POS.xy[0,this_run])
                x_new = m(np.linspace(0, len(this_run), len(self.EEG.sm_eeg[this_run[0] * self.pos2eegScale:this_run[-1] * self.pos2eegScale])))
                self._eeglines = self.eegaxis.plot(x_new, self.EEG.eeg[this_run[0]*5:this_run[-1]*5], c=[0.8627, 0.8627, 0.8627], lw=5)
                self._eeglines2 = self.eegaxis.plot(x_new, self.EEG.sm_eeg[this_run[0] * self.pos2eegScale:this_run[-1] * self.pos2eegScale], c=&#39;k&#39;)
                self._eegspks = self.eegaxis.plot(self.POS.xy[0,these_spks], self.EEG.sm_eeg[these_spks * self.pos2eegScale], &#39;|&#39;, ms=9, mew=3, c=&#39;b&#39;)
                self._eegfirst = self.eegaxis.plot(self.POS.xy[0,v], self.EEG.sm_eeg[v * self.pos2eegScale], &#39;|&#39;, ms=9, mew=3, c=&#39;r&#39;)
                
                transOffset = offset_copy(self.eegaxis.transData, fig=self.fig, x=0, y=13, units=&#39;dots&#39;)
                
                self._eegText = []
                for s,x,y in zip(range(len(these_spks)), self.POS.xy[0,these_spks], self.EEG.sm_eeg[these_spks * self.pos2eegScale]):
                        self._eegText.append(self.eegaxis.text(x, y, s=&#39;%d&#39; % (int(s)), fontsize=15, transform=transOffset))
                
                # add xticks/ lines at intervals of 1/10 seconds to the eeg plot
                self._xticks = []
                axtrans = transforms.blended_transform_factory(self.eegaxis.transData, self.eegaxis.transAxes)
                for xx in x_new[0:-1:int(self.EEG.sample_rate/10)]:
                        self._xticks.append(self.eegaxis.add_line(Line2D((xx,xx),(-1,1),c=&#39;b&#39;, ls=&#39;--&#39;,transform=axtrans)))


                # add the actual laser on/off position to the plots  as some kind of box        
                if self._laser_edges is not None:
                        log_data = self._getLogData()
                        log_ts = log_data[&#39;ts&#39;]  / 20
                        log_state = log_data[&#39;state&#39;]
                        laser_on_pos_idx = log_ts[log_state==&#39;on&#39;]
                        this_run_on = np.intersect1d(laser_on_pos_idx, this_run)
                        start_x = np.min(self.POS.xy[0,this_run_on])
                        end_x = np.max(self.POS.xy[0,this_run_on])
                        left_edge = (start_x - self.mnx) / self.mxx
                        right_edge = (end_x - self.mnx) / self.mxx
                        laserAxTrans = transforms.blended_transform_factory(self.ax.transData, self.ax.transAxes)
                        self.pp_patch = self.ax.add_patch(Rectangle((left_edge,0), width=np.diff((left_edge,right_edge)), 
                                                                   height=1, transform = laserAxTrans, color=[1,1,0], alpha=0.5))
                        laserAxTrans = transforms.blended_transform_factory(self.posAx.transData, self.posAx.transAxes)
                        self.pos_patch = self.posAx.add_patch(Rectangle((start_x,0), width=np.ptp((start_x, end_x)), 
                                                                   height=1, transform = laserAxTrans, color=[1,1,0], alpha=0.5))
                        laserAxTrans = transforms.blended_transform_factory(self.eegaxis.transData, self.eegaxis.transAxes)
                        self.eeg_patch = self.eegaxis.add_patch(Rectangle((start_x,0), width=np.ptp((start_x, end_x)), 
                                                                   height=1, transform = laserAxTrans, color=[1,1,0], alpha=0.5))
                
                
                self.eegaxis.figure.canvas.draw_idle()
                self.posAx.figure.canvas.draw_idle()
                self.ax.figure.canvas.draw_idle()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ephysiopy.dacq2py.dacq2py_util.Trial" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial">Trial</a></b></code>:
<ul class="hlist">
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.EEG" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.EEG">EEG</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.EGF" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.EGF">EGF</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.POS" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.POS">POS</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.STM" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.STM">STM</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.adjust_median_speed" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.adjust_median_speed">adjust_median_speed</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.autoCorr2D" href="../ephys_generic/gridcell.html#ephysiopy.ephys_generic.gridcell.SAC.autoCorr2D">autoCorr2D</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.crossCorr2D" href="../ephys_generic/gridcell.html#ephysiopy.ephys_generic.gridcell.SAC.crossCorr2D">crossCorr2D</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.deformSAC" href="../ephys_generic/gridcell.html#ephysiopy.ephys_generic.gridcell.SAC.deformSAC">deformSAC</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getBorderScore" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getBorderScore">getBorderScore</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getCluCut" href="axonaIO.html#ephysiopy.dacq2py.axonaIO.IO.getCluCut">getCluCut</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getCut" href="axonaIO.html#ephysiopy.dacq2py.axonaIO.IO.getCut">getCut</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getData" href="axonaIO.html#ephysiopy.dacq2py.axonaIO.IO.getData">getData</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getFieldRuns" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getFieldRuns">getFieldRuns</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getFullFile" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getFullFile">getFullFile</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getHeader" href="axonaIO.html#ephysiopy.dacq2py.axonaIO.IO.getHeader">getHeader</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getHeaderVal" href="axonaIO.html#ephysiopy.dacq2py.axonaIO.IO.getHeaderVal">getHeaderVal</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getMeasures" href="../ephys_generic/gridcell.html#ephysiopy.ephys_generic.gridcell.SAC.getMeasures">getMeasures</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getRasterHist" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getRasterHist">getRasterHist</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getThetaModIdx" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getThetaModIdx">getThetaModIdx</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getThetaModIdx2" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getThetaModIdx2">getThetaModIdx2</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getThigmotaxisIndex" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getThigmotaxisIndex">getThigmotaxisIndex</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getTsAndCs" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getTsAndCs">getTsAndCs</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getcircR" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getcircR">getcircR</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getcoherence" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getcoherence">getcoherence</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getgridness" href="../ephys_generic/gridcell.html#ephysiopy.ephys_generic.gridcell.SAC.getgridness">getgridness</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getkldiv" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getkldiv">getkldiv</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getmrv" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getmrv">getmrv</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getorientation" href="../ephys_generic/gridcell.html#ephysiopy.ephys_generic.gridcell.SAC.getorientation">getorientation</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getskaggsInfo" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getskaggsInfo">getskaggsInfo</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.hasFiles" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.hasFiles">hasFiles</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.klustakwik" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.klustakwik">klustakwik</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotClusterSpace" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotClusterSpace">plotClusterSpace</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotDirFilteredRmaps" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotDirFilteredRmaps">plotDirFilteredRmaps</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotEEGPower" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotEEGPower">plotEEGPower</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotEventEEGRange" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotEventEEGRange">plotEventEEGRange</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotFreqVSpeed" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotFreqVSpeed">plotFreqVSpeed</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotFullSAC" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotFullSAC">plotFullSAC</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotMap" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotMap">plotMap</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotPath" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotPath">plotPath</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotPhaseInField" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotPhaseInField">plotPhaseInField</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotPhaseOfFiring" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotPhaseOfFiring">plotPhaseOfFiring</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotRaster" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotRaster">plotRaster</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotRateVSpeed" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotRateVSpeed">plotRateVSpeed</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotRollingCorrRateVSpeed" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotRollingCorrRateVSpeed">plotRollingCorrRateVSpeed</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotSAC" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotSAC">plotSAC</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotSpectrogram" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotSpectrogram">plotSpectrogram</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotSpikesOnPath" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotSpikesOnPath">plotSpikesOnPath</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotWaveforms" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotWaveforms">plotWaveforms</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotXCorr" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotXCorr">plotXCorr</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plot_event_EEG" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plot_event_EEG">plot_event_EEG</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.posFilter" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.posFilter">posFilter</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.print_stim_dict" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.print_stim_dict">print_stim_dict</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.setData" href="axonaIO.html#ephysiopy.dacq2py.axonaIO.IO.setData">setData</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.setHeader" href="axonaIO.html#ephysiopy.dacq2py.axonaIO.IO.setHeader">setHeader</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.setheader" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.setheader">setheader</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.show" href="../ephys_generic/gridcell.html#ephysiopy.ephys_generic.gridcell.SAC.show">show</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.t_win_SAC" href="../ephys_generic/gridcell.html#ephysiopy.ephys_generic.gridcell.SAC.t_win_SAC">t_win_SAC</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.tortuosity" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.tortuosity">tortuosity</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ephysiopy.dacq2py.lineartrack.LinearTrackTrial"><code class="flex name class">
<span>class <span class="ident">LinearTrackTrial</span></span>
<span>(</span><span>filename_root, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Providesm ethods to plot electrophysiology data acquired using the Axona DACQ recording system
and methods to extract some measures from that data</p>
<p>The actual loading of the data is done lazily i.e. only when you ask for
position data (say plotting the path the animal took in the trial) is the
position data actually loaded. The class also uses as attibutes several
instances of subpackages (binning.Ratemap for example) so that the code
could be made more modular.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>filename_root</code></strong> :&ensp;<code>str</code></dt>
<dd>Absolute location on the filesystem of the set of files without a suffix</dd>
<dt><strong><code>basename</code></strong> :&ensp;<code>str</code></dt>
<dd>Basename of the set of files without a suffix (everything after the last trailing slash)</dd>
<dt><strong><code>EEG</code></strong> :&ensp;<code>dacq2py.axonaIO.EEG</code> <code>class</code></dt>
<dd>Containing data from .eeg file</dd>
<dt><strong><code>EGF</code></strong> :&ensp;<code>dacq2py.axonaIO.EEG</code> <code>class</code></dt>
<dd>Containing data from .egf file</dd>
<dt><strong><code>STM</code></strong> :&ensp;<code>dacq2py.axonaIO.Stim</code> <code>class</code></dt>
<dd>Contains stimulation data (timestamps mostly) and header + some additions work done below</dd>
<dt><strong><code>POS</code></strong> :&ensp;<code>dacq2py.axonaIO.Pos</code> <code>class</code></dt>
<dd>Contains raw and post-processed position data (xy, dir, speed etc) &amp; header</dd>
<dt><strong><code>TETRODE</code></strong> :&ensp;<code>extension</code> of <code>Pythons</code> <code>dict</code> <code>class"</code></dt>
<dd>Each value is an instance of dacq2py.axonaIO.Tetrode. Contains
methods to get cluster spike times, cluster indices etc</dd>
<dt><strong><code>posFilter</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keys are things like 'speed', 'time'; values are n x 2 arrays of range of values <em>to keep</em></dd>
<dt><strong><code>setheader</code></strong> :&ensp;<code>dict</code></dt>
<dd>Corresponds to the .set file for the file set. Keys/ values are all strings</dd>
<dt><strong><code>_available_files</code></strong> :&ensp;<code>list</code></dt>
<dd>All files matching the filename_root + any valid suffix</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>OrderedDict</code></dt>
<dd>Some basic info if the file is an *rh one (see _parseMetaData)</dd>
<dt><strong><code>ratemap</code></strong> :&ensp;<code>dacq2py.binning.Ratemap</code> <code>class</code> <code>instance</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code>binning Basic binning of data</code>, <code>calculation of bin sizes etc</code>
<code>eegcalcs Contains filters</code>, <code>eeg power spectra methods</code>
<code>spikecalcs Temporal measures of spike trains (firing rates etc) and extracting parameters from the waveforms and clusters themselves</code>
<code>fieldcalcs Methods for extracting information from 2D ratemaps mostly but also contains some statistical tools (information theoretic measures etc)</code>
<code>gridcellTrial Trial inherits from this at the moment. Includes methods for obtaining the spatial autocorrelogram (SAC) (and cross-correlogram) and plotting of the SAC</code></p>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; from dacq2py.dacq2py_util import Trial
&gt;&gt;&gt; T = Trial(r'/media/robin/data/Dropbox/Science/Recordings/M851/M851_140908t1rh')
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename_root</code></strong> :&ensp;<code>str</code></dt>
<dd>The absolute filename without any suffix attached
i.e. C:\Robin\mytrial<pre><code>Note that when RH is using this can be just the trial name as the getFullFile method
tries to find the trial given the folder layout and the filename - see that method
for details
</code></pre>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>T</code></strong> :&ensp;<code>object</code></dt>
<dd>a dacq2py_util.Trial object</dd>
</dl>
<h2 id="examples_1">Examples</h2>
<pre><code>&gt;&gt;&gt; T = dacq2py_util.Trial(r'/media/robin/data/Dropbox/Science/Recordings/M851/M851_140908t1rh')
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LinearTrackTrial(Trial):
        def plotLTSpikesRateMap(self, tetrode, cluster, clamp=True, ax=None):
                &#39;&#39;&#39;
                ====
                plotLTSpikesRateMap
                ====

                Definition: plotSpikesOnPath(tetrode, clusters, clamp=True)

                ----

                Plots the spikes on the path during a trial for a particular tetrode/
                cluster(s) with the ratemap below and a histogram of the spikes vs x
                above the spike / pos plot + a kernel smoothed density estimate of the
                smoothed spike/ pos data. Only does this for a single cluster (not multiple)

                Parameters
                ----------
                tetrode: integer
                                 the tetrode you want to look at
                cluster: integer, 1xn array/ list
                                 a single number or list (or 1xn array) of the clusters to plot
                clamp:   bool, optional
                                 whether to restrict the plot to the self._xlims and self_ylims
                                 property

                &#39;&#39;&#39;
                xy = self._getPath()
                fig = plt.figure(self._figNum)

                if ax is None:
                        ax = fig.add_subplot(1, 1, 1)

                idx = self.TETRODE[tetrode].getClustIdx(cluster)
                ax.plot(xy[0], xy[1], c=tcols.colours[0], zorder=1)
                ax.plot(xy[0, idx], xy[1, idx], &#39;s&#39;, c=tcols.colours[cluster],
                                mec=tcols.colours[cluster])
                ax.set_xlim(self._xlims)
                ax.set_ylim(self._ylims)
                ax.set_aspect(&#39;equal&#39;)

                divider = make_axes_locatable(ax)
                axHistx = divider.append_axes(&#34;top&#34;, 1.2, pad=0.1, sharex=ax)

                binsize = self.__getBinUnits__()
                if np.ma.is_masked(self.POS.xy[0]):
                        mask = ~np.ma.getmask(self.POS.xy[0])
                        mask = mask.nonzero()[0]
                        idx = idx[np.in1d(idx, mask)]

                axHistx.hist(self.POS.xy[0, idx], bins=self.binsize[1],
                                         range=self._xlims)[0]
                # calculate and plot the kernel smoothed density estimate
                kde = stats.gaussian_kde(self.POS.xy[0, idx])
                # calculate the amount to normalise kde by
                norm = len(self.POS.xy[0, idx]) * (np.float(np.ptp(self._xlims)) / binsize[1])
                grid = np.linspace(self._xlims[0], self._xlims[1], binsize[1])
                z = kde.evaluate(grid)
                # normalise kde by the number of data points and the bin width
                z = z * norm
                axHistx.plot(grid, z, &#39;r&#39;)

                axRmap = divider.append_axes(&#34;bottom&#34;, 1.2, pad=0.1, sharex=ax, sharey=ax)
                rmap, ye, xe = self._getMap(tetrode, cluster)
                axRmap.imshow(rmap, extent=(xe[0], xe[-1], ye[0], ye[-1]),
                                          interpolation=&#39;nearest&#39;, origin=&#39;lower&#39;)

                plt.setp(axHistx.get_xticklabels() + axHistx.get_yticklabels(),
                                 visible=False)
                plt.setp(ax.get_xticklabels() + ax.get_yticklabels(), visible=False)
                plt.setp(axRmap.get_xticklabels() + axRmap.get_yticklabels(),
                                 visible=False)
                plt.show()

        def plotLTSpikesOnPath(self, tetrode, cluster, figNum=1):
                &#39;&#39;&#39;
                plotts a n row by 3 column plot:
                1st column is both directions of running
                2nd column is leftward runs
                3rd column is rightward runs
                &#39;&#39;&#39;
                self._figNum = figNum
                old_filter = self.posFilter
                self.posFilter = None
                self.plotSpikesOnPath(tetrode, cluster, colNum=1)
                self.posFilter = {&#39;dir&#39;: (315, 45)}
                self.plotSpikesOnPath(tetrode, cluster, colNum=2)
                self.posFilter = {&#39;dir&#39;: (135, 225)}
                self.plotSpikesOnPath(tetrode, cluster, colNum=3)
                self.posFilter = old_filter</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ephysiopy.dacq2py.dacq2py_util.Trial" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial">Trial</a></li>
<li><a title="ephysiopy.dacq2py.axonaIO.IO" href="axonaIO.html#ephysiopy.dacq2py.axonaIO.IO">IO</a></li>
<li><a title="ephysiopy.ephys_generic.gridcell.SAC" href="../ephys_generic/gridcell.html#ephysiopy.ephys_generic.gridcell.SAC">SAC</a></li>
<li>builtins.dict</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ephysiopy.dacq2py.lineartrack.LinearTrackTrial.plotLTSpikesOnPath"><code class="name flex">
<span>def <span class="ident">plotLTSpikesOnPath</span></span>(<span>self, tetrode, cluster, figNum=1)</span>
</code></dt>
<dd>
<section class="desc"><p>plotts a n row by 3 column plot:
1st column is both directions of running
2nd column is leftward runs
3rd column is rightward runs</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotLTSpikesOnPath(self, tetrode, cluster, figNum=1):
        &#39;&#39;&#39;
        plotts a n row by 3 column plot:
        1st column is both directions of running
        2nd column is leftward runs
        3rd column is rightward runs
        &#39;&#39;&#39;
        self._figNum = figNum
        old_filter = self.posFilter
        self.posFilter = None
        self.plotSpikesOnPath(tetrode, cluster, colNum=1)
        self.posFilter = {&#39;dir&#39;: (315, 45)}
        self.plotSpikesOnPath(tetrode, cluster, colNum=2)
        self.posFilter = {&#39;dir&#39;: (135, 225)}
        self.plotSpikesOnPath(tetrode, cluster, colNum=3)
        self.posFilter = old_filter</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.lineartrack.LinearTrackTrial.plotLTSpikesRateMap"><code class="name flex">
<span>def <span class="ident">plotLTSpikesRateMap</span></span>(<span>self, tetrode, cluster, clamp=True, ax=None)</span>
</code></dt>
<dd>
<section class="desc"><p>====
plotLTSpikesRateMap
====</p>
<p>Definition: plotSpikesOnPath(tetrode, clusters, clamp=True)</p>
<hr>
<p>Plots the spikes on the path during a trial for a particular tetrode/
cluster(s) with the ratemap below and a histogram of the spikes vs x
above the spike / pos plot + a kernel smoothed density estimate of the
smoothed spike/ pos data. Only does this for a single cluster (not multiple)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tetrode</code></strong> :&ensp;<code>integer</code></dt>
<dd>the tetrode you want to look at</dd>
<dt><strong><code>cluster</code></strong> :&ensp;<code>integer</code>, <code>1xn</code> <code>array</code>/ <code>list</code></dt>
<dd>a single number or list (or 1xn array) of the clusters to plot</dd>
<dt><strong><code>clamp</code></strong> :&ensp;
<code>bool</code>, optional</dt>
<dd>whether to restrict the plot to the self._xlims and self_ylims
property</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotLTSpikesRateMap(self, tetrode, cluster, clamp=True, ax=None):
        &#39;&#39;&#39;
        ====
        plotLTSpikesRateMap
        ====

        Definition: plotSpikesOnPath(tetrode, clusters, clamp=True)

        ----

        Plots the spikes on the path during a trial for a particular tetrode/
        cluster(s) with the ratemap below and a histogram of the spikes vs x
        above the spike / pos plot + a kernel smoothed density estimate of the
        smoothed spike/ pos data. Only does this for a single cluster (not multiple)

        Parameters
        ----------
        tetrode: integer
                         the tetrode you want to look at
        cluster: integer, 1xn array/ list
                         a single number or list (or 1xn array) of the clusters to plot
        clamp:   bool, optional
                         whether to restrict the plot to the self._xlims and self_ylims
                         property

        &#39;&#39;&#39;
        xy = self._getPath()
        fig = plt.figure(self._figNum)

        if ax is None:
                ax = fig.add_subplot(1, 1, 1)

        idx = self.TETRODE[tetrode].getClustIdx(cluster)
        ax.plot(xy[0], xy[1], c=tcols.colours[0], zorder=1)
        ax.plot(xy[0, idx], xy[1, idx], &#39;s&#39;, c=tcols.colours[cluster],
                        mec=tcols.colours[cluster])
        ax.set_xlim(self._xlims)
        ax.set_ylim(self._ylims)
        ax.set_aspect(&#39;equal&#39;)

        divider = make_axes_locatable(ax)
        axHistx = divider.append_axes(&#34;top&#34;, 1.2, pad=0.1, sharex=ax)

        binsize = self.__getBinUnits__()
        if np.ma.is_masked(self.POS.xy[0]):
                mask = ~np.ma.getmask(self.POS.xy[0])
                mask = mask.nonzero()[0]
                idx = idx[np.in1d(idx, mask)]

        axHistx.hist(self.POS.xy[0, idx], bins=self.binsize[1],
                                 range=self._xlims)[0]
        # calculate and plot the kernel smoothed density estimate
        kde = stats.gaussian_kde(self.POS.xy[0, idx])
        # calculate the amount to normalise kde by
        norm = len(self.POS.xy[0, idx]) * (np.float(np.ptp(self._xlims)) / binsize[1])
        grid = np.linspace(self._xlims[0], self._xlims[1], binsize[1])
        z = kde.evaluate(grid)
        # normalise kde by the number of data points and the bin width
        z = z * norm
        axHistx.plot(grid, z, &#39;r&#39;)

        axRmap = divider.append_axes(&#34;bottom&#34;, 1.2, pad=0.1, sharex=ax, sharey=ax)
        rmap, ye, xe = self._getMap(tetrode, cluster)
        axRmap.imshow(rmap, extent=(xe[0], xe[-1], ye[0], ye[-1]),
                                  interpolation=&#39;nearest&#39;, origin=&#39;lower&#39;)

        plt.setp(axHistx.get_xticklabels() + axHistx.get_yticklabels(),
                         visible=False)
        plt.setp(ax.get_xticklabels() + ax.get_yticklabels(), visible=False)
        plt.setp(axRmap.get_xticklabels() + axRmap.get_yticklabels(),
                         visible=False)
        plt.show()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ephysiopy.dacq2py.dacq2py_util.Trial" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial">Trial</a></b></code>:
<ul class="hlist">
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.EEG" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.EEG">EEG</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.EGF" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.EGF">EGF</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.POS" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.POS">POS</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.STM" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.STM">STM</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.adjust_median_speed" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.adjust_median_speed">adjust_median_speed</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.autoCorr2D" href="../ephys_generic/gridcell.html#ephysiopy.ephys_generic.gridcell.SAC.autoCorr2D">autoCorr2D</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.crossCorr2D" href="../ephys_generic/gridcell.html#ephysiopy.ephys_generic.gridcell.SAC.crossCorr2D">crossCorr2D</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.deformSAC" href="../ephys_generic/gridcell.html#ephysiopy.ephys_generic.gridcell.SAC.deformSAC">deformSAC</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getBorderScore" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getBorderScore">getBorderScore</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getCluCut" href="axonaIO.html#ephysiopy.dacq2py.axonaIO.IO.getCluCut">getCluCut</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getCut" href="axonaIO.html#ephysiopy.dacq2py.axonaIO.IO.getCut">getCut</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getData" href="axonaIO.html#ephysiopy.dacq2py.axonaIO.IO.getData">getData</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getFieldRuns" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getFieldRuns">getFieldRuns</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getFullFile" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getFullFile">getFullFile</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getHeader" href="axonaIO.html#ephysiopy.dacq2py.axonaIO.IO.getHeader">getHeader</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getHeaderVal" href="axonaIO.html#ephysiopy.dacq2py.axonaIO.IO.getHeaderVal">getHeaderVal</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getMeasures" href="../ephys_generic/gridcell.html#ephysiopy.ephys_generic.gridcell.SAC.getMeasures">getMeasures</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getRasterHist" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getRasterHist">getRasterHist</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getThetaModIdx" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getThetaModIdx">getThetaModIdx</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getThetaModIdx2" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getThetaModIdx2">getThetaModIdx2</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getThigmotaxisIndex" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getThigmotaxisIndex">getThigmotaxisIndex</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getTsAndCs" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getTsAndCs">getTsAndCs</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getcircR" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getcircR">getcircR</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getcoherence" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getcoherence">getcoherence</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getgridness" href="../ephys_generic/gridcell.html#ephysiopy.ephys_generic.gridcell.SAC.getgridness">getgridness</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getkldiv" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getkldiv">getkldiv</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getmrv" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getmrv">getmrv</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getorientation" href="../ephys_generic/gridcell.html#ephysiopy.ephys_generic.gridcell.SAC.getorientation">getorientation</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getskaggsInfo" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getskaggsInfo">getskaggsInfo</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.hasFiles" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.hasFiles">hasFiles</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.klustakwik" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.klustakwik">klustakwik</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotClusterSpace" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotClusterSpace">plotClusterSpace</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotDirFilteredRmaps" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotDirFilteredRmaps">plotDirFilteredRmaps</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotEEGPower" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotEEGPower">plotEEGPower</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotEventEEGRange" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotEventEEGRange">plotEventEEGRange</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotFreqVSpeed" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotFreqVSpeed">plotFreqVSpeed</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotFullSAC" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotFullSAC">plotFullSAC</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotMap" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotMap">plotMap</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotPath" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotPath">plotPath</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotPhaseInField" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotPhaseInField">plotPhaseInField</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotPhaseOfFiring" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotPhaseOfFiring">plotPhaseOfFiring</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotRaster" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotRaster">plotRaster</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotRateVSpeed" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotRateVSpeed">plotRateVSpeed</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotRollingCorrRateVSpeed" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotRollingCorrRateVSpeed">plotRollingCorrRateVSpeed</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotSAC" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotSAC">plotSAC</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotSpectrogram" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotSpectrogram">plotSpectrogram</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotSpikesOnPath" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotSpikesOnPath">plotSpikesOnPath</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotWaveforms" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotWaveforms">plotWaveforms</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotXCorr" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotXCorr">plotXCorr</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plot_event_EEG" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plot_event_EEG">plot_event_EEG</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.posFilter" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.posFilter">posFilter</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.print_stim_dict" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.print_stim_dict">print_stim_dict</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.setData" href="axonaIO.html#ephysiopy.dacq2py.axonaIO.IO.setData">setData</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.setHeader" href="axonaIO.html#ephysiopy.dacq2py.axonaIO.IO.setHeader">setHeader</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.setheader" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.setheader">setheader</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.show" href="../ephys_generic/gridcell.html#ephysiopy.ephys_generic.gridcell.SAC.show">show</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.t_win_SAC" href="../ephys_generic/gridcell.html#ephysiopy.ephys_generic.gridcell.SAC.t_win_SAC">t_win_SAC</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.tortuosity" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.tortuosity">tortuosity</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ephysiopy.dacq2py" href="index.html">ephysiopy.dacq2py</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ephysiopy.dacq2py.lineartrack.LTrack" href="#ephysiopy.dacq2py.lineartrack.LTrack">LTrack</a></code></h4>
<ul class="two-column">
<li><code><a title="ephysiopy.dacq2py.lineartrack.LTrack.clear" href="#ephysiopy.dacq2py.lineartrack.LTrack.clear">clear</a></code></li>
<li><code><a title="ephysiopy.dacq2py.lineartrack.LTrack.nextRun" href="#ephysiopy.dacq2py.lineartrack.LTrack.nextRun">nextRun</a></code></li>
<li><code><a title="ephysiopy.dacq2py.lineartrack.LTrack.plotPPperRun" href="#ephysiopy.dacq2py.lineartrack.LTrack.plotPPperRun">plotPPperRun</a></code></li>
<li><code><a title="ephysiopy.dacq2py.lineartrack.LTrack.plotPhaseVsX" href="#ephysiopy.dacq2py.lineartrack.LTrack.plotPhaseVsX">plotPhaseVsX</a></code></li>
<li><code><a title="ephysiopy.dacq2py.lineartrack.LTrack.prevRun" href="#ephysiopy.dacq2py.lineartrack.LTrack.prevRun">prevRun</a></code></li>
<li><code><a title="ephysiopy.dacq2py.lineartrack.LTrack.update" href="#ephysiopy.dacq2py.lineartrack.LTrack.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ephysiopy.dacq2py.lineartrack.LinearTrackTrial" href="#ephysiopy.dacq2py.lineartrack.LinearTrackTrial">LinearTrackTrial</a></code></h4>
<ul class="">
<li><code><a title="ephysiopy.dacq2py.lineartrack.LinearTrackTrial.plotLTSpikesOnPath" href="#ephysiopy.dacq2py.lineartrack.LinearTrackTrial.plotLTSpikesOnPath">plotLTSpikesOnPath</a></code></li>
<li><code><a title="ephysiopy.dacq2py.lineartrack.LinearTrackTrial.plotLTSpikesRateMap" href="#ephysiopy.dacq2py.lineartrack.LinearTrackTrial.plotLTSpikesRateMap">plotLTSpikesRateMap</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>