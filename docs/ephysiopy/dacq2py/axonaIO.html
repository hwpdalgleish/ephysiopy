<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>ephysiopy.dacq2py.axonaIO API documentation</title>
<meta name="description" content="Created on Thu Apr 12 17:44:50 2012 â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ephysiopy.dacq2py.axonaIO</code></h1>
</header>
<section id="section-intro">
<p>Created on Thu Apr 12 17:44:50 2012</p>
<p>@author: robin</p>
<p>Defines classes and methods for working with Axona electrophysiological
recording data.</p>
<p>IO - main i/o class for reading Axona files and additionally .clu files
generated from KlustaKwik</p>
<p>Pos - does all the pos post-processing such as interpolating bad positions
and smoothing the data using the relevant filters etc</p>
<p>Tetrode - processes tetrode data. By default converts the raw values to volts.
Also can get timestamps, unique clusters etc</p>
<p>EEG - for eeg data. Also converts to volts and can do powerspectra and filter
for theta etc. TODO: needs expanding to include spectrogram</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Thu Apr 12 17:44:50 2012

@author: robin

Defines classes and methods for working with Axona electrophysiological
recording data.

IO - main i/o class for reading Axona files and additionally .clu files
generated from KlustaKwik

Pos - does all the pos post-processing such as interpolating bad positions
and smoothing the data using the relevant filters etc

Tetrode - processes tetrode data. By default converts the raw values to volts.
Also can get timestamps, unique clusters etc

EEG - for eeg data. Also converts to volts and can do powerspectra and filter
for theta etc. TODO: needs expanding to include spectrogram

&#34;&#34;&#34;
import scipy, scipy.interpolate, scipy.stats, scipy.ndimage, scipy.signal
import numpy as np
import math
import os
import pickle
import fnmatch
from . import smoothdata as sm
from .spikecalcs import SpikeCalcs

MAXSPEED = 4.0  # pos data speed filter in m/s
BOXCAR = 20  # this gives a 400ms smoothing window for pos averaging

empty_headers = {
        &#34;tetrode&#34; : os.path.join(os.path.dirname(__file__), &#34;tetrode_header.pkl&#34;),
        &#34;pos&#34; : os.path.join(os.path.dirname(__file__), &#34;pos_header.pkl&#34;),
        &#34;set&#34; : os.path.join(os.path.dirname(__file__), &#34;set_header.pkl&#34;),
        &#34;eeg&#34; : os.path.join(os.path.dirname(__file__), &#34;eeg_header.pkl&#34;),
        &#34;egf&#34; : os.path.join(os.path.dirname(__file__), &#34;egf_header.pkl&#34;)
}

class IO(object):
        &#39;&#39;&#39;Class for reading data from Axona data acquisition system. Also
        reads .clu files generated from KlustaKwik

        Class attributes:
        axona_files (dict): keys are axona format file suffixes
        and the values are used as numpy dtypes to read the data.
        NB it&#39;s assumed a .set file is *always* present
        &#39;&#39;&#39;
        tetrode_files = dict.fromkeys([&#34;.&#34; + str(i) for i in range(1, 17)], [(&#39;ts&#39;, &#39;&gt;i&#39;), (&#39;waveform&#39;, &#39;50b&#39;)])
        other_files = {&#39;.pos&#39;: [(&#39;ts&#39;, &#39;&gt;i&#39;), (&#39;pos&#39;, &#39;&gt;8h&#39;)],
                                   &#39;.eeg&#39;: [(&#39;eeg&#39;, &#39;=b&#39;)],
                                   &#39;.eeg2&#39;: [(&#39;eeg&#39;, &#39;=b&#39;)],
                                   &#39;.egf&#39;: [(&#39;eeg&#39;, &#39;int16&#39;)],
                                   &#39;.egf2&#39;: [(&#39;eeg&#39;, &#39;int16&#39;)],
                                   &#39;.inp&#39;: [(&#39;ts&#39;, &#39;&gt;i4&#39;), (&#39;type&#39;, &#39;&gt;b&#39;), (&#39;value&#39;, &#39;&gt;2b&#39;)],
                                   &#39;.log&#39;: [(&#39;state&#39;, &#39;S3&#39;), (&#39;ts&#39;, &#39;&gt;i&#39;)],
                                   &#39;.stm&#39;: [(&#39;ts&#39;, &#39;&gt;i&#39;)]}

        axona_files = {**other_files, **tetrode_files} # this will only work in &gt;= Python3.5

        def __init__(self, filename_root=&#39;&#39;):
                self.filename_root = filename_root

        &#39;&#39;&#39;
        These path to these files are given in __init__.py
        &#39;&#39;&#39;
        @staticmethod
        def getEmptyHeader(ftype: str)-&gt;dict:
                pname = empty_headers.get(ftype, &#39;&#39;)
                if os.path.isfile(pname):
                        with open(pname, &#39;rb&#39;) as f:
                                return pickle.load(f)

        def getData(self, filename_root):
                &#39;&#39;&#39;
                Returns the data part of an Axona data file i.e. from &#34;data_start&#34; to
                &#34;data_end&#34;
                Parameters
                ----------------------
                input:  str
                                fully qualified path name to the data file
                Returns
                ---------
                output: numpy.array
                                the data part of whatever file was fed in. Format specified from file type
                &#39;&#39;&#39;
                n_samps = -1
                fType = os.path.splitext(filename_root)[1]
                if fType in self.axona_files:
                        try:
                                header = self.getHeader(filename_root)
                                for key in header.keys():
                                        if len(fType) &gt; 2:
                                                if fnmatch.fnmatch(key, &#39;num_*_samples&#39;):
                                                        n_samps = int(header[key])
                                        else:
                                                if key.startswith(&#39;num_spikes&#39;):
                                                        n_samps = int(header[key]) * 4
                        except IOError:
                                print(&#39;File type not recognised&#39;)
                        f = open(filename_root, &#39;rb&#39;)
                        data = f.read()
                        st = data.find(b&#39;data_start&#39;) + len(&#39;data_start&#39;)
                        f.seek(st)
                        if fType == &#39;.log&#39;:
                                f.seek(0)
                        dt = np.dtype(self.axona_files[fType])
                        a = np.fromfile(f, dtype=dt, count=n_samps)
                        f.close()
                return a

        def getCluCut(self, tet):
                &#39;&#39;&#39;Load a clu file and return as an array of integers&#39;&#39;&#39;
                filename_root = self.filename_root + &#39;.&#39; + &#39;clu.&#39; + str(tet)
                dt = np.dtype([(&#39;data&#39;, &#39;&lt;i&#39;)])
                clu_data = np.loadtxt(filename_root, dtype=dt)
                return clu_data[&#39;data&#39;][1::]  # first entry is number of clusters found

        def getCut(self, tet):
                &#39;&#39;&#39;Returns the cut file as a list of integers&#39;&#39;&#39;
                a = []
                filename_root = self.filename_root + &#39;_&#39; + str(tet) + &#39;.cut&#39;
                if not os.path.exists(filename_root):
                        cut = self.getCluCut(tet)
                        return cut - 1
                with open(filename_root, &#39;r&#39;) as f:
                        cut_data = f.read()
                        f.close()
                tmp = cut_data.split(&#39;spikes: &#39;)
                tmp1 = tmp[1].split(&#39;\n&#39;)
                cut = tmp1[1:]
                for line in cut:
                        m = line.split()
                        for i in m:
                                a.append(int(i))
                return a

        def setHeader(self, filename_root: str, header: dict):
                &#39;&#39;&#39;
                Writes out the header to the specified file

                Parameters
                ------------
                filename_root - a fully qualified path to a file with the relevant suffix at
                the end (e.g. &#34;.set&#34;, &#34;.pos&#34; or whatever)

                header - a dict, an empty version of which can be loaded using getEmptyHeader above
                &#39;&#39;&#39;
                encoding = &#34;ISO-8859-1&#34;
                with open(filename_root, &#39;w&#39;) as f:
                        for key, val in header.items():
                                f.write(key)#, encoding))
                                f.write(&#34; &#34;)#, encoding))
                                if val is None:
                                        val = &#34;&#34;
                                f.write(val)#, encoding))
                                f.write(&#39;\r\n&#39;)#, encoding))
                        f.write(&#39;data_start&#39;)#, encoding))
                        f.write(&#39;\r\n&#39;)
                        f.write(&#39;data_end&#39;)
                        f.write(&#39;\r\n&#39;)

        def setData(self, filename_root: str, data: np.array):
                &#39;&#39;&#39;
                Writes data to the given filename
                Assumes the data is in the correct format
                &#39;&#39;&#39;
                encoding = &#34;ISO-8859-1&#34;
                fType = os.path.splitext(filename_root)[1]
                if fType in self.axona_files:
                        f = open(filename_root, &#39;rb+&#39;)
                        d = f.read()
                        st = d.find(b&#39;data_start&#39;) + len(&#39;data_start&#39;)
                        f.seek(st)
                        data.tofile(f)
                        f.close()
                        f = open(filename_root, &#39;a&#39;)
                        f.write(&#39;\r\n&#39;)
                        f.write(&#39;data_end&#39;)
                        f.write(&#39;\r\n&#39;)
                        f.close()

        def getHeader(self, filename_root):
                &#39;&#39;&#39;
                Returns the header of a specified data file as a dictionary

                Parameters
                ------------
                filename_root (str) - fully qualified filename of Axona type

                Returns
                -------
                A dictionary with key - value pairs of the header part of an Axona type file
                &#39;&#39;&#39;
                with open(filename_root, &#39;rb&#39;) as f:
                        data = f.read()
                        f.close()
                if os.path.splitext(filename_root)[1] != &#39;.set&#39;:
                        st = data.find(b&#39;data_start&#39;) + len(&#39;data_start&#39;)
                        header = data[0:st-len(&#39;data_start&#39;)-2]
                else:
                        header = data
                headerDict = {}
                lines = header.splitlines()
                for line in lines:
                        line = str(line.decode(&#34;ISO-8859-1&#34;)).rstrip()
                        line = line.split(&#39; &#39;, 1)
                        try:
                                headerDict[line[0]] = line[1]
                        except IndexError:
                                headerDict[line[0]] = &#39;&#39;
                return headerDict

        def getHeaderVal(self, header, key):
                &#39;&#39;&#39;
                Given a header and a key value string (&#39;timebase&#39;, &#39;sample_rate&#39;, etc)
                returns the associated value
                &#39;&#39;&#39;
                tmp = header[key]
                val = tmp.split(&#39; &#39;)
                val = val[0].split(&#39;.&#39;)
                val = int(val[0])
                return val


class Pos(IO):
        def __init__(self, filename_root, *args, **kwargs):
                self.filename_root = filename_root
                self.header = self.getHeader(filename_root + &#39;.pos&#39;)
                self.setheader = None
                try:
                        self.setheader = self.getHeader(filename_root + &#39;.set&#39;)
                except Exception:
                        pass
                self.posProcessed = False
                posData = self.getData(filename_root + &#39;.pos&#39;)
                self.nLEDs = 1
                if self.setheader is not None:
                        self.nLEDs = sum([self.getHeaderVal(self.setheader,&#39;colactive_1&#39;),
                                                          self.getHeaderVal(self.setheader,&#39;colactive_2&#39;)])
                if self.nLEDs == 1:
                        self.led_pos = np.ma.masked_values([posData[&#39;pos&#39;][:,0],posData[&#39;pos&#39;][:,1]],1023)
                        self.led_pix = np.ma.masked_values(posData[&#39;pos&#39;][:,4],1023)
                elif self.nLEDs == 2:
                        self.led_pos = np.ma.masked_values([posData[&#39;pos&#39;][:,0],posData[&#39;pos&#39;][:,1],
                                                                                         posData[&#39;pos&#39;][:,2],posData[&#39;pos&#39;][:,3]],1023)
                        self.led_pix = np.ma.masked_values([posData[&#39;pos&#39;][:,4],posData[&#39;pos&#39;][:,5]],1023)
                self.npos = len(self.led_pos[0])
                self.xy = np.ones([2,self.npos]) * np.nan
                self.dir = np.ones([self.npos]) * np.nan
                self.dir_disp = np.ones([self.npos]) * np.nan
                self.speed = np.ones([self.npos]) * np.nan
                self.pos_sample_rate = self.getHeaderVal(self.header, &#39;sample_rate&#39;)
                self._ppm = None
                if &#39;cm&#39; in kwargs:
                        self.cm = kwargs[&#39;cm&#39;]
                else:
                        self.cm = False # if True return xy in cm, otherwise in pixels (see end of postprocesspos)

        @property
        def ppm(self):
                if self._ppm is None:
                        try:
                                self._ppm = self.getHeaderVal(self.header, &#39;pixels_per_metre&#39;)
                        except IOError:
                                self._ppm = None
                return self._ppm

        @ppm.setter
        def ppm(self, value):
                self._ppm = value
                self.posProcessed = False
                self.postprocesspos()

        def __getitem__(self, key):
                try:
                        val = self.__dict__[key]
                        return val
                except:
                        pass

        def postprocesspos(self):
                &#39;&#39;&#39;post processes position data
                something isn&#39;t quite right here at least with 2 led data&#39;&#39;&#39;
                if self.posProcessed is True:
                        return
                elif self.posProcessed is False:
                        led_pos = self.led_pos
                        led_pix = self.led_pix
                        # as with AJ&#39;s implementation in mtint, calculate weights for a weighted mean
                        # of the front and back leds for when trials have poorly tracked trials
                        # NB could probably do this straight from the number of leds tracked which
                        # is available in the raw data
                        # need to mask all values of the array using logical or to replicate
                        # mtints way of filling in missing values
                        nLED_idx = self.nLEDs * 2
                        led_pos[0:nLED_idx].__setmask__(led_pos[0:nLED_idx].mask.any(axis=0))
                        weights = np.zeros(2)
                        weights[0] = float(np.sum(np.nonzero(led_pos[0:2]), axis=1)[0]) / self.npos
                        try:
                                weights[1] = float(np.sum(np.nonzero(led_pos[2:4]), axis=1)[0]) / self.npos
                        except IndexError:
                                pass
                        # need to deal with improperly tracked positions where the values are
                        # plainly ridiculous
                        # values less than 0 are masked
                        led_pos[led_pos &lt; 0] = np.ma.masked
                        # deal with values outside the range of the tracked window
                        led_pos[0, (led_pos[0] &gt; int(self.header[&#39;max_x&#39;]))] = np.ma.masked
                        led_pos[1, (led_pos[1] &gt; int(self.header[&#39;max_y&#39;]))] = np.ma.masked
                        # try and deal with other led if present
                        try:
                                led_pos[2, (led_pos[2] &gt; int(self.header[&#39;max_x&#39;]))] = np.ma.masked
                                led_pos[3, (led_pos[3] &gt; int(self.header[&#39;max_y&#39;]))] = np.ma.masked
                        except IndexError:
                                pass
                        if np.logical_and(np.any(np.nonzero(led_pix)), self.nLEDs==2):
                                swap_list = self.ledswapFilter(led_pos, led_pix)
                                tmp = led_pos[0:2, swap_list]
                                led_pos[0:2, swap_list] = led_pos[2:4, swap_list]
                                led_pos[2:4, swap_list] = tmp
                                tmp = led_pix[0, swap_list]
                                led_pix[0, swap_list] = led_pix[1, swap_list]
                                led_pix[1, swap_list] = tmp
                        ppm = self.ppm
                        max_ppm_per_sample = MAXSPEED * ppm / self.pos_sample_rate
                        led_pos = self.ledspeedFilter(led_pos,max_ppm_per_sample)
                        led_pos = self.interpNans(led_pos)
                        # get distances and angles of LEDs from rat
                        pos1 = np.arange(0,self.npos)
                        pos2 = np.arange(0,self.npos-1)
                        if self.nLEDs == 1:
                                self.xy[0:2,pos1] = led_pos[0:2,pos1]
                                self.xy[0,:] = sm.smooth(self.xy[0,:],BOXCAR,&#39;flat&#39;)
                                self.xy[1,:] = sm.smooth(self.xy[1,:],BOXCAR,&#39;flat&#39;)
                                self.dir[pos2] = np.mod(((180/math.pi) * (np.arctan2(-self.xy[1,pos2+1] + self.xy[1,pos2],+self.xy[0,pos2+1]-self.xy[0,pos2]))), 360)
                                self.dir[-1] = self.dir[-2]
                                self.dir_disp = self.dir
                        elif self.nLEDs == 2:
                                lightBearings = np.zeros([2,1])
                                lightBearings[0] = self.getHeaderVal(self.setheader,&#39;lightBearing_1&#39;)
                                lightBearings[1] = self.getHeaderVal(self.setheader,&#39;lightBearing_2&#39;)
                                front_back_xy_sm = np.zeros([4,self.npos])
                                for i in range(len(front_back_xy_sm)):
#                    front_back_xy_sm[i,pos1] = scipy.signal.convolve(led_pos[i, pos1], np.ones(BOXCAR) / BOXCAR, mode=&#39;same&#39;)
                                        front_back_xy_sm[i,pos1] = sm.smooth(led_pos[i,pos1],BOXCAR,&#39;flat&#39;)
                                correction = lightBearings[0]
                                self.dir[pos1] = np.mod((180/math.pi) * (np.arctan2(-front_back_xy_sm[1,pos1]+front_back_xy_sm[3,pos1],
                                                                  +front_back_xy_sm[0,pos1]-front_back_xy_sm[2,pos1])-correction),360)
                                # get xy from smoothed individual lights weighting for reliability
                                self.xy[0,pos1] = (weights[0]*front_back_xy_sm[0,pos1] + weights[1]*front_back_xy_sm[2,pos1]) / np.sum(weights)
                                self.xy[1,pos1] = (weights[0]*front_back_xy_sm[1,pos1] + weights[1]*front_back_xy_sm[3,pos1]) / np.sum(weights)
                                self.dir_disp[pos2] = np.mod(((180/math.pi) * (np.arctan2(-self.xy[1,pos2+1] + self.xy[1,pos2],+self.xy[0,pos2+1]-self.xy[0,pos2]))) ,360)
                                self.dir_disp[-1] = self.dir_disp[-2]

                        if self.cm:
                                self.xy = self.xy / ppm * 100 # xy now in cm
                        # calculate speed based on distance
                        self.speed[pos2] = np.sqrt(np.sum(np.power(np.diff(self.xy),2),0))
                        self.speed[self.npos-1] = self.speed[-1]
                        self.speed = self.speed * (100 * self.pos_sample_rate / ppm) # *100 to get into cm/s
                        if np.isnan(self.speed[-1]):
                                self.speed[-1] = 0

                        self.posProcessed = True

        def ledspeedFilter(self,led_pos,max_ppm_per_sample):
                &#39;&#39;&#39;
                Filters for impossibly fast tracked points
                input: masked led_pos array [x1,y1,x2,y2]
                max_ppm_per_sample
                led = big or small (1 or 2)
                output: number of jumpy points
                masked led_pos
                &#39;&#39;&#39;
                max_ppms_sqd = max_ppm_per_sample ** 2
                for i in range(0,len(led_pos),2):
                        ok_pos = led_pos[i,:]
                        prev_pos = ok_pos[0:-1]
                        cur_pos = ok_pos[1:]
                        pix_per_sample_sqd = (np.power((np.subtract(led_pos[i,cur_pos], led_pos[i,prev_pos])),2) + np.power((np.subtract(led_pos[i+1,cur_pos], led_pos[i+1,prev_pos])),2)) / np.power(np.subtract(cur_pos,prev_pos),2)
                        pix_per_sample_sqd = np.insert(pix_per_sample_sqd, -1, 0)
                        led_pos[i:i+2,pix_per_sample_sqd &gt; max_ppms_sqd] = np.ma.masked
                return led_pos

        def ledswapFilter(self,led_pos,led_pix):
                &#39;&#39;&#39;Checks for led swapping in 2-spot mode
                input: led_pos - a masked array of dims [4 x nPosSamples]
                format is x1,y1,x2,y2
                mskd_pix - a masked array of dims [2 x nPosSamples]
                format is nPix1, nPix2
                output: list of swapped positions&#39;&#39;&#39;
                thresh = 5
                mean_npix = led_pix.mean(axis=1).data
                std_npix = led_pix.std(axis=1).data
                pos = np.arange(1,led_pix.shape[1])
                #calculate distances
                dist12 = np.sqrt(np.nansum(((np.squeeze(led_pos[0:2,pos])-np.squeeze(led_pos[2:4,pos-1]))**2),axis=0))
                dist11 = np.sqrt(np.nansum(((np.squeeze(led_pos[0:2,pos])-np.squeeze(led_pos[0:2,pos-1]))**2),axis=0))
                dist21 = np.sqrt(np.nansum(((np.squeeze(led_pos[2:4,pos])-np.squeeze(led_pos[0:2,pos-1]))**2),axis=0))
                dist22 = np.sqrt(np.nansum(((np.squeeze(led_pos[2:4,pos])-np.squeeze(led_pos[2:4,pos-1]))**2),axis=0))
                switched = np.logical_or(np.logical_and((dist12 &lt; dist11 - thresh).data,led_pos[2,pos].mask),(dist21 &lt; dist22-thresh).data)
                z11 = (mean_npix[0] - led_pix[0,pos]) / std_npix[0]
                z12 = (led_pix[0,pos] - mean_npix[1]) / std_npix[1]
                shrunk = z11 &gt; z12
                swap_list = np.nonzero(np.logical_and(switched, shrunk.data))[0] + 1
                return swap_list

        def interpNans(self,led_pos):
                &#39;&#39;&#39;interpolates over missing values with the specified
                boxcar
                input: masked array (led_pos)
                output: smoothed, unmasked array (led_pos)&#39;&#39;&#39;
                for i in range(0,len(led_pos),2):
                        missing = led_pos[i:i+2].mask.any(axis=0)
                        ok = np.logical_not(missing)
                        ok_idx = ok.ravel().nonzero()[0]#gets the indices of ok poses
                        missing_idx = missing.ravel().nonzero()[0]#get the indices of missing poses
                        good_data = led_pos.data[i,ok_idx]
                        good_data1 = led_pos.data[i+1,ok_idx]
                        led_pos.data[i,missing_idx] = np.interp(missing_idx,ok_idx,good_data)#,left=np.min(good_data),right=np.max(good_data)
                        led_pos.data[i+1,missing_idx] = np.interp(missing_idx,ok_idx,good_data1) #,left=np.min(good_data1),right=np.max(good_data1) y coord
                #unmask the array
                led_pos.mask = 0
                return led_pos
        def filterPos(self, filterDict):
                &#39;&#39;&#39;
                Filters position data depending on the filter specified in fType
                Inputs:
                filterDict - a dict which contains the type(s) of filter to be used and the
                range of values to filter for. Values are pairs specifying the range
                of values to filter for NB can take multiple filters and iteratively apply them
                legal values are:
                Parameters
                ------------
                &#39;dir&#39; - the directional range to filter for NB this can contain &#39;w&#39;,&#39;e&#39;,&#39;s&#39; or &#39;n&#39;
                &#39;speed&#39; - min and max speed to filter for
                &#39;xrange&#39; - min and max values to filter x pos values
                &#39;yrange&#39; - same as xrange but for y pos
                &#39;time&#39; - the times to keep / remove specified in ms

                Returns
                --------
                the filtered indices i.e. those that should be kept
                &#39;&#39;&#39;
                if filterDict is None:
                        return
                nSamples = int(self.header[&#39;num_pos_samples&#39;])
                bool_arr = np.ones(shape=(len(filterDict), nSamples), dtype=np.bool)
                for idx, key in enumerate(filterDict):
                        if isinstance(filterDict[key], str):
                                if len(filterDict[key]) == 1 and &#39;dir&#39; in key:
                                        if &#39;w&#39; in filterDict[key]:
                                                filterDict[key] = (135, 225)
                                        elif &#39;e&#39; in filterDict[key]:
                                                filterDict[key] = (315, 45)
                                        elif &#39;s&#39; in filterDict[key]:
                                                filterDict[key] = (225, 315)
                                        elif &#39;n&#39; in filterDict[key]:
                                                filterDict[key] = (45, 135)
                                else:
                                        raise ValueError(&#34;filter must contain a key / value pair&#34;)
                                        return
                        if &#39;speed&#39; in key:
                                if filterDict[key][0] &gt; filterDict[key][1]:
                                        raise ValueError(&#34;First value must be less than the second one&#34;)
                                else:
                                        bool_arr[idx,:] = np.logical_and(self.speed &gt; filterDict[key][0],
                                                                         self.speed &lt; filterDict[key][1])
                        elif &#39;dir&#39; in key:
                                if filterDict[key][0] &lt; filterDict[key][1]:
                                        bool_arr[idx,:] = np.logical_and(self.dir &gt; filterDict[key][0],
                                                                                 self.dir &lt; filterDict[key][1])
                                else:
                                        bool_arr[idx,:] = np.logical_or(self.dir &gt; filterDict[key][0],
                                                                                self.dir &lt; filterDict[key][1])
                        elif &#39;xrange&#39; in key:
                                bool_arr[idx, :] = np.logical_and(self.xy[0, :] &gt; filterDict[key][0],
                                                                                self.xy[0, :] &lt; filterDict[key][1])
                        elif &#39;yrange&#39; in key:
                                bool_arr[idx, :] = np.logical_and(self.xy[1, :] &gt; filterDict[key][0],
                                                                                self.xy[1, :] &lt; filterDict[key][1])
                        elif &#39;time&#39; in key:
                                # takes the form of &#39;from&#39; - &#39;to&#39; times in SECONDS such that only pos&#39;s between these ranges are KEPT
                                filterDict[key] = filterDict[key]  * self.pos_sample_rate
                                if filterDict[key].ndim == 1:
                                        bool_arr[idx, filterDict[key][0]:filterDict[key][1]] = False
                                else:
                                        for i in filterDict[key]:
                                                bool_arr[idx, i[0]:i[1]] = False
                                bool_arr = ~bool_arr
                        else:
                                print(&#34;Unrecognised key in dict&#34;)
                                pass
                return np.expand_dims(np.any(~bool_arr, axis=0), 0)

class Tetrode(IO, SpikeCalcs):
        def __init__(self, filename_root, tetrode, volts=True):
                self.filename_root = filename_root
                self.tetrode = tetrode
                self.volts = volts
                self.header = self.getHeader(self.filename_root + &#39;.&#39; + str(tetrode))
                data = self.getData(filename_root + &#39;.&#39; + str(tetrode))
                self.spk_ts = data[&#39;ts&#39;][::4]
                self.nChans = self.getHeaderVal(self.header, &#39;num_chans&#39;)
                self.samples = self.getHeaderVal(self.header, &#39;samples_per_spike&#39;)
                self.nSpikes = self.getHeaderVal(self.header, &#39;num_spikes&#39;)
                self.posSampleRate = self.getHeaderVal(self.getHeader(self.filename_root + &#39;.&#39; + &#39;pos&#39;), &#39;sample_rate&#39;)
                self.waveforms = data[&#39;waveform&#39;].reshape(self.nSpikes, self.nChans, self.samples)
                del data
                if volts:
                        set_header = self.getHeader(self.filename_root + &#39;.set&#39;)
                        gains = np.zeros(4)
                        st = (tetrode - 1) * 4
                        for i, g in enumerate(np.arange(st, st+4)):
                                gains[i] = int(set_header[&#39;gain_ch_&#39; + str(g)])
                        ADC_mv = int(set_header[&#39;ADC_fullscale_mv&#39;])
                        scaling = (ADC_mv/1000.) / gains
                        self.scaling = scaling
                        self.gains = gains
                        self.waveforms = (self.waveforms / 128.) * scaling[:,np.newaxis]# waveforms now in volts
                self.timebase = self.getHeaderVal(self.header, &#39;timebase&#39;)
                try:
                        cut = np.array(self.getCut(self.tetrode), dtype=int)
                        self.cut = cut
                        self.clusters = np.unique(self.cut)
                except IOError:
                        try:
                                cut = self.getCluCut(self.tetrode)
                                cut = np.array(cut) - 1
                                self.cut = cut
                                self.clusters = np.unique(self.cut)
                        except IOError:
                                self.cut = None
                self.pos_samples = None

        def getSpkTS(self):
                &#39;&#39;&#39;
                Returns the list of timestamps a series of spike events occured on a tetrode
                &#39;&#39;&#39;
                return np.ma.compressed(self.spk_ts)

        def getClustTS(self, cluster=None):
                &#39;&#39;&#39;
                Returns the timestamps for a cluster on a tetrode
                &#39;&#39;&#39;
                # Return all of the timestamps if no cluster given
                if cluster is None:
                        clustTS = self.getSpkTS()
                else:
                        if self.cut is None:
                                try:
                                        cut = np.array(self.getCut(self.tetrode),dtype=int)
                                except IOError:
                                        cut = self.getCluCut(self.tetrode)
                                        cut = np.array(cut) - 1
                                self.cut = cut
                        self.getSpkTS()
                        clustTS = np.ma.compressed(self.spk_ts[self.cut==cluster])
                return clustTS

        def getPosSamples(self):
                &#39;&#39;&#39;
                Returns the pos samples at which the spikes were captured
                &#39;&#39;&#39;
                self.pos_samples = np.floor(self.getSpkTS() / float(self.timebase) * self.posSampleRate).astype(int)
                return np.ma.compressed(self.pos_samples)

        def getClustSpks(self, cluster):
                &#39;&#39;&#39;
                Returns the waveforms of the asked for cluster
                &#39;&#39;&#39;
                if self.cut is None:
                        self.getClustTS(cluster)
                return self.waveforms[self.cut==cluster, :, :]#taking the mean of this along axis=0 gives mean waveform on each channel for a cluster

        def getClustIdx(self, cluster):
                &#39;&#39;&#39;
                Returns the pos samples corresponding to the cluster
                &#39;&#39;&#39;
                if self.cut is None:
                        try:
                                cut = np.array(self.getCut(self.tetrode), dtype=int)
                        except IOError:
                                cut = self.getCluCut(self.tetrode)
                                cut = np.array(cut) - 1
                        self.cut = cut
                if self.pos_samples is None:
                        self.getPosSamples()
                return self.pos_samples[self.cut == cluster].astype(int)

        def getUniqueClusters(self):
                &#39;&#39;&#39;
                Returns an array of the unique clusters in the cut file associated
                with the tetrode
                &#39;&#39;&#39;
                if self.cut is None:
                        try:
                                cut = np.array(self.getCut(self.tetrode), dtype=int)
                        except IOError:
                                cut = self.getCluCut(self.tetrode)
                                cut = np.array(cut) - 1
                        self.cut = cut
                else:
                        cut = self.cut
                return np.unique(cut)


class EEG(IO):
        def __init__(self, filename_root, eeg_file=1, egf=0):
                self.showfigs = 0
                self.filename_root = filename_root
                if egf == 0:
                        denom = 128.0 #used below to normalise data
                        if eeg_file == 1:
                                eeg_suffix = &#39;.eeg&#39;
                        else:
                                eeg_suffix = &#39;.eeg&#39; + str(eeg_file)
                elif egf == 1:
                        denom = 128.0 # used below to normalise data
                        if eeg_file == 1:
                                eeg_suffix = &#39;.egf&#39;
                        else:
                                eeg_suffix = &#39;.egf&#39; + str(eeg_file)
                self.header = self.getHeader(self.filename_root + eeg_suffix)
                self.eeg = self.getData(filename_root + eeg_suffix)[&#39;eeg&#39;]
                # sometimes the eeg record is longer than reported in the &#39;num_EEG_samples&#39;
                # value of the header so eeg record should be truncated to match &#39;num_EEG_samples&#39;
                # TODO: this could be taken care of in the IO base class
                if egf:
                        self.eeg = self.eeg[0:int(self.header[&#39;num_EGF_samples&#39;])]
                else:
                        self.eeg = self.eeg[0:int(self.header[&#39;num_EEG_samples&#39;])]
                if egf == 1:
                        # self.eeg = self.eeg.view(np.int8).reshape(self.eeg.shape+(2,)) # fast!
                        self.eeg = self.eeg[:, 1]
                self.sample_rate = int(self.getHeaderVal(self.header, &#39;sample_rate&#39;))
                set_header = self.getHeader(self.filename_root + &#39;.set&#39;)
                eeg_ch = int(set_header[&#39;EEG_ch_1&#39;]) - 1
                if eeg_ch &lt; 0:
                        eeg_ch = 0
                eeg_gain = int(set_header[&#39;gain_ch_&#39; + str(eeg_ch)])
                # EEG polarity is determined by the &#34;mode_ch_n&#34; key in the setfile
                # where n is the channel # for the eeg. The possibles values to these
                # keys are as follows:
                #       0 = Signal
                #       1 = Ref
                #       2 = -Signal
                #       3 = -Ref
                #       4 = Sig-Ref
                #       5 = Ref-Sig
                #       6 = grounded
                # So if the EEG has been recorded with -Signal (2) then the recorded polarity
                # is inverted with respect to that in the brain
                eeg_mode = int(set_header[&#39;mode_ch_&#39; + set_header[&#39;EEG_ch_1&#39;]])
                polarity = 1 # ensure it always has a value
                if eeg_mode == 2:
                        polarity = -1
                ADC_mv = float(set_header[&#39;ADC_fullscale_mv&#39;])
                scaling = (ADC_mv/1000.) * eeg_gain
                self.scaling = scaling
                self.gain = eeg_gain
                self.polarity = polarity
                self.eeg = (self.eeg / denom) * scaling * polarity# eeg now in microvolts
                self.EEGphase = None
                # x1 / x2 are the lower and upper limits of the eeg filter
                self.x1 = 6
                self.x2 = 12

        def eegfilter(self, E=None):
                &#39;&#39;&#39;filters the eeg using a 251-tap bandpass (6-12Hz) blackman filter
                between the values given in x1 and x2: defaults to filtering between theta
                frequency (6-12Hz)
                &#39;&#39;&#39;
                if E is None:
                        E = self.eeg
                nyquist = self.sample_rate / 2.
                eegfilter = scipy.signal.firwin(int(self.sample_rate) + 1, [self.x1/nyquist, self.x2/nyquist], window=&#39;black&#39;, pass_zero=False)
                filtEEG = scipy.signal.filtfilt(eegfilter, [1], E.ravel(), padtype=&#39;odd&#39;)
                if np.ma.is_masked(self.eeg):
                        mask = np.ma.getmask(self.eeg)
                        return np.ma.masked_where(mask, filtEEG)
                else:
                        return filtEEG

        def thetaAmpPhase(self, fx=None):
                &#39;&#39;&#39;
                extracts the amplitude (phase?) of the EEG signal after it has been filtered
                by the thetafilter method above
                &#39;&#39;&#39;
                # extract the real part of the analytic signal using the hilbert transform
                if fx is None:
                        fx = self.eegfilter(E=self.eeg)
                analytic = scipy.signal.hilbert(fx)
                self.EEGphase = np.angle(analytic)
                self.UWphase = np.unwrap(self.EEGphase)
                tmp = np.append(self.UWphase, np.nan)
                self.EEGinstfreq = np.diff(tmp) * (self.sample_rate / (2*np.pi))
                self.thAmp = np.abs(analytic)

        def nextpow2(self, val):
                &#39;&#39;&#39;calculates the next power of 2 that will hold val&#39;&#39;&#39;
                val = val - 1
                val = (val &gt;&gt; 1) | val
                val = (val &gt;&gt; 2) | val
                val = (val &gt;&gt; 4) | val
                val = (val &gt;&gt; 8) | val
                val = (val &gt;&gt; 16) | val
                val = (val &gt;&gt; 32) | val
                return np.log2(val + 1)

class Stim(dict, IO):
        def __init__(self, filename_root, *args, **kwargs):
                self.update(*args, **kwargs)
                self.filename_root = filename_root
                stmData = self.getData(filename_root + &#39;.stm&#39;)
                self.__setitem__(&#39;on&#39;, stmData[&#39;ts&#39;])
                stmHdr = self.getHeader(filename_root + &#39;.stm&#39;)
                for k,v in stmHdr.items():
                        self.__setitem__(k, v)
                tb = int(self[&#39;timebase&#39;].split(&#39; &#39;)[0])
                self.timebase = tb

        def update(self, *args, **kwargs):
                for k, v in dict(*args, **kwargs).iteritems():
                        self[k] = v

        def __getitem__(self, key):
                try:
                        val = dict.__getitem__(self, key)
                        return val
                except KeyError:
                        print(&#39;KeyError&#39;)

        def __setitem__(self, key, val):
                dict.__setitem__(self, key, val)

        def getTS(self):
                return self[&#39;on&#39;] / int(self.timebase / 1000)# in ms

        def getPosIdx(self):
                &#39;&#39;&#39;
                these get* methods will only work once the Stim object has been
                instantiated from within the dacq2py_util.Trial class - see its _STM
                property there for details about what this update entails
                &#39;&#39;&#39;
                scale = self.timebase / float(self[&#39;posSampRate&#39;])
                return self[&#39;on&#39;] / scale

        def getEEGIdx(self):
                scale = self.timebase / float(self[&#39;eegSampRate&#39;])
                return (self[&#39;on&#39;] / scale).astype(int)

        def getEGFIdx(self):
                scale = self.timebase / float(self[&#39;egfSampRate&#39;])
                return (self[&#39;on&#39;] / scale).astype(int)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ephysiopy.dacq2py.axonaIO.EEG"><code class="flex name class">
<span>class <span class="ident">EEG</span></span>
<span>(</span><span>filename_root, eeg_file=1, egf=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Class for reading data from Axona data acquisition system. Also
reads .clu files generated from KlustaKwik</p>
<p>Class attributes:
axona_files (dict): keys are axona format file suffixes
and the values are used as numpy dtypes to read the data.
NB it's assumed a .set file is <em>always</em> present</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EEG(IO):
        def __init__(self, filename_root, eeg_file=1, egf=0):
                self.showfigs = 0
                self.filename_root = filename_root
                if egf == 0:
                        denom = 128.0 #used below to normalise data
                        if eeg_file == 1:
                                eeg_suffix = &#39;.eeg&#39;
                        else:
                                eeg_suffix = &#39;.eeg&#39; + str(eeg_file)
                elif egf == 1:
                        denom = 128.0 # used below to normalise data
                        if eeg_file == 1:
                                eeg_suffix = &#39;.egf&#39;
                        else:
                                eeg_suffix = &#39;.egf&#39; + str(eeg_file)
                self.header = self.getHeader(self.filename_root + eeg_suffix)
                self.eeg = self.getData(filename_root + eeg_suffix)[&#39;eeg&#39;]
                # sometimes the eeg record is longer than reported in the &#39;num_EEG_samples&#39;
                # value of the header so eeg record should be truncated to match &#39;num_EEG_samples&#39;
                # TODO: this could be taken care of in the IO base class
                if egf:
                        self.eeg = self.eeg[0:int(self.header[&#39;num_EGF_samples&#39;])]
                else:
                        self.eeg = self.eeg[0:int(self.header[&#39;num_EEG_samples&#39;])]
                if egf == 1:
                        # self.eeg = self.eeg.view(np.int8).reshape(self.eeg.shape+(2,)) # fast!
                        self.eeg = self.eeg[:, 1]
                self.sample_rate = int(self.getHeaderVal(self.header, &#39;sample_rate&#39;))
                set_header = self.getHeader(self.filename_root + &#39;.set&#39;)
                eeg_ch = int(set_header[&#39;EEG_ch_1&#39;]) - 1
                if eeg_ch &lt; 0:
                        eeg_ch = 0
                eeg_gain = int(set_header[&#39;gain_ch_&#39; + str(eeg_ch)])
                # EEG polarity is determined by the &#34;mode_ch_n&#34; key in the setfile
                # where n is the channel # for the eeg. The possibles values to these
                # keys are as follows:
                #       0 = Signal
                #       1 = Ref
                #       2 = -Signal
                #       3 = -Ref
                #       4 = Sig-Ref
                #       5 = Ref-Sig
                #       6 = grounded
                # So if the EEG has been recorded with -Signal (2) then the recorded polarity
                # is inverted with respect to that in the brain
                eeg_mode = int(set_header[&#39;mode_ch_&#39; + set_header[&#39;EEG_ch_1&#39;]])
                polarity = 1 # ensure it always has a value
                if eeg_mode == 2:
                        polarity = -1
                ADC_mv = float(set_header[&#39;ADC_fullscale_mv&#39;])
                scaling = (ADC_mv/1000.) * eeg_gain
                self.scaling = scaling
                self.gain = eeg_gain
                self.polarity = polarity
                self.eeg = (self.eeg / denom) * scaling * polarity# eeg now in microvolts
                self.EEGphase = None
                # x1 / x2 are the lower and upper limits of the eeg filter
                self.x1 = 6
                self.x2 = 12

        def eegfilter(self, E=None):
                &#39;&#39;&#39;filters the eeg using a 251-tap bandpass (6-12Hz) blackman filter
                between the values given in x1 and x2: defaults to filtering between theta
                frequency (6-12Hz)
                &#39;&#39;&#39;
                if E is None:
                        E = self.eeg
                nyquist = self.sample_rate / 2.
                eegfilter = scipy.signal.firwin(int(self.sample_rate) + 1, [self.x1/nyquist, self.x2/nyquist], window=&#39;black&#39;, pass_zero=False)
                filtEEG = scipy.signal.filtfilt(eegfilter, [1], E.ravel(), padtype=&#39;odd&#39;)
                if np.ma.is_masked(self.eeg):
                        mask = np.ma.getmask(self.eeg)
                        return np.ma.masked_where(mask, filtEEG)
                else:
                        return filtEEG

        def thetaAmpPhase(self, fx=None):
                &#39;&#39;&#39;
                extracts the amplitude (phase?) of the EEG signal after it has been filtered
                by the thetafilter method above
                &#39;&#39;&#39;
                # extract the real part of the analytic signal using the hilbert transform
                if fx is None:
                        fx = self.eegfilter(E=self.eeg)
                analytic = scipy.signal.hilbert(fx)
                self.EEGphase = np.angle(analytic)
                self.UWphase = np.unwrap(self.EEGphase)
                tmp = np.append(self.UWphase, np.nan)
                self.EEGinstfreq = np.diff(tmp) * (self.sample_rate / (2*np.pi))
                self.thAmp = np.abs(analytic)

        def nextpow2(self, val):
                &#39;&#39;&#39;calculates the next power of 2 that will hold val&#39;&#39;&#39;
                val = val - 1
                val = (val &gt;&gt; 1) | val
                val = (val &gt;&gt; 2) | val
                val = (val &gt;&gt; 4) | val
                val = (val &gt;&gt; 8) | val
                val = (val &gt;&gt; 16) | val
                val = (val &gt;&gt; 32) | val
                return np.log2(val + 1)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ephysiopy.dacq2py.axonaIO.IO" href="#ephysiopy.dacq2py.axonaIO.IO">IO</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ephysiopy.dacq2py.eegcalcs.EEGCalcs" href="eegcalcs.html#ephysiopy.dacq2py.eegcalcs.EEGCalcs">EEGCalcs</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ephysiopy.dacq2py.axonaIO.EEG.eegfilter"><code class="name flex">
<span>def <span class="ident">eegfilter</span></span>(<span>self, E=None)</span>
</code></dt>
<dd>
<section class="desc"><p>filters the eeg using a 251-tap bandpass (6-12Hz) blackman filter
between the values given in x1 and x2: defaults to filtering between theta
frequency (6-12Hz)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eegfilter(self, E=None):
        &#39;&#39;&#39;filters the eeg using a 251-tap bandpass (6-12Hz) blackman filter
        between the values given in x1 and x2: defaults to filtering between theta
        frequency (6-12Hz)
        &#39;&#39;&#39;
        if E is None:
                E = self.eeg
        nyquist = self.sample_rate / 2.
        eegfilter = scipy.signal.firwin(int(self.sample_rate) + 1, [self.x1/nyquist, self.x2/nyquist], window=&#39;black&#39;, pass_zero=False)
        filtEEG = scipy.signal.filtfilt(eegfilter, [1], E.ravel(), padtype=&#39;odd&#39;)
        if np.ma.is_masked(self.eeg):
                mask = np.ma.getmask(self.eeg)
                return np.ma.masked_where(mask, filtEEG)
        else:
                return filtEEG</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.axonaIO.EEG.nextpow2"><code class="name flex">
<span>def <span class="ident">nextpow2</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<section class="desc"><p>calculates the next power of 2 that will hold val</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nextpow2(self, val):
        &#39;&#39;&#39;calculates the next power of 2 that will hold val&#39;&#39;&#39;
        val = val - 1
        val = (val &gt;&gt; 1) | val
        val = (val &gt;&gt; 2) | val
        val = (val &gt;&gt; 4) | val
        val = (val &gt;&gt; 8) | val
        val = (val &gt;&gt; 16) | val
        val = (val &gt;&gt; 32) | val
        return np.log2(val + 1)</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.axonaIO.EEG.thetaAmpPhase"><code class="name flex">
<span>def <span class="ident">thetaAmpPhase</span></span>(<span>self, fx=None)</span>
</code></dt>
<dd>
<section class="desc"><p>extracts the amplitude (phase?) of the EEG signal after it has been filtered
by the thetafilter method above</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def thetaAmpPhase(self, fx=None):
        &#39;&#39;&#39;
        extracts the amplitude (phase?) of the EEG signal after it has been filtered
        by the thetafilter method above
        &#39;&#39;&#39;
        # extract the real part of the analytic signal using the hilbert transform
        if fx is None:
                fx = self.eegfilter(E=self.eeg)
        analytic = scipy.signal.hilbert(fx)
        self.EEGphase = np.angle(analytic)
        self.UWphase = np.unwrap(self.EEGphase)
        tmp = np.append(self.UWphase, np.nan)
        self.EEGinstfreq = np.diff(tmp) * (self.sample_rate / (2*np.pi))
        self.thAmp = np.abs(analytic)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ephysiopy.dacq2py.axonaIO.IO" href="#ephysiopy.dacq2py.axonaIO.IO">IO</a></b></code>:
<ul class="hlist">
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.getCluCut" href="#ephysiopy.dacq2py.axonaIO.IO.getCluCut">getCluCut</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.getCut" href="#ephysiopy.dacq2py.axonaIO.IO.getCut">getCut</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.getData" href="#ephysiopy.dacq2py.axonaIO.IO.getData">getData</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.getHeader" href="#ephysiopy.dacq2py.axonaIO.IO.getHeader">getHeader</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.getHeaderVal" href="#ephysiopy.dacq2py.axonaIO.IO.getHeaderVal">getHeaderVal</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.setData" href="#ephysiopy.dacq2py.axonaIO.IO.setData">setData</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.setHeader" href="#ephysiopy.dacq2py.axonaIO.IO.setHeader">setHeader</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ephysiopy.dacq2py.axonaIO.IO"><code class="flex name class">
<span>class <span class="ident">IO</span></span>
<span>(</span><span>filename_root='')</span>
</code></dt>
<dd>
<section class="desc"><p>Class for reading data from Axona data acquisition system. Also
reads .clu files generated from KlustaKwik</p>
<p>Class attributes:
axona_files (dict): keys are axona format file suffixes
and the values are used as numpy dtypes to read the data.
NB it's assumed a .set file is <em>always</em> present</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IO(object):
        &#39;&#39;&#39;Class for reading data from Axona data acquisition system. Also
        reads .clu files generated from KlustaKwik

        Class attributes:
        axona_files (dict): keys are axona format file suffixes
        and the values are used as numpy dtypes to read the data.
        NB it&#39;s assumed a .set file is *always* present
        &#39;&#39;&#39;
        tetrode_files = dict.fromkeys([&#34;.&#34; + str(i) for i in range(1, 17)], [(&#39;ts&#39;, &#39;&gt;i&#39;), (&#39;waveform&#39;, &#39;50b&#39;)])
        other_files = {&#39;.pos&#39;: [(&#39;ts&#39;, &#39;&gt;i&#39;), (&#39;pos&#39;, &#39;&gt;8h&#39;)],
                                   &#39;.eeg&#39;: [(&#39;eeg&#39;, &#39;=b&#39;)],
                                   &#39;.eeg2&#39;: [(&#39;eeg&#39;, &#39;=b&#39;)],
                                   &#39;.egf&#39;: [(&#39;eeg&#39;, &#39;int16&#39;)],
                                   &#39;.egf2&#39;: [(&#39;eeg&#39;, &#39;int16&#39;)],
                                   &#39;.inp&#39;: [(&#39;ts&#39;, &#39;&gt;i4&#39;), (&#39;type&#39;, &#39;&gt;b&#39;), (&#39;value&#39;, &#39;&gt;2b&#39;)],
                                   &#39;.log&#39;: [(&#39;state&#39;, &#39;S3&#39;), (&#39;ts&#39;, &#39;&gt;i&#39;)],
                                   &#39;.stm&#39;: [(&#39;ts&#39;, &#39;&gt;i&#39;)]}

        axona_files = {**other_files, **tetrode_files} # this will only work in &gt;= Python3.5

        def __init__(self, filename_root=&#39;&#39;):
                self.filename_root = filename_root

        &#39;&#39;&#39;
        These path to these files are given in __init__.py
        &#39;&#39;&#39;
        @staticmethod
        def getEmptyHeader(ftype: str)-&gt;dict:
                pname = empty_headers.get(ftype, &#39;&#39;)
                if os.path.isfile(pname):
                        with open(pname, &#39;rb&#39;) as f:
                                return pickle.load(f)

        def getData(self, filename_root):
                &#39;&#39;&#39;
                Returns the data part of an Axona data file i.e. from &#34;data_start&#34; to
                &#34;data_end&#34;
                Parameters
                ----------------------
                input:  str
                                fully qualified path name to the data file
                Returns
                ---------
                output: numpy.array
                                the data part of whatever file was fed in. Format specified from file type
                &#39;&#39;&#39;
                n_samps = -1
                fType = os.path.splitext(filename_root)[1]
                if fType in self.axona_files:
                        try:
                                header = self.getHeader(filename_root)
                                for key in header.keys():
                                        if len(fType) &gt; 2:
                                                if fnmatch.fnmatch(key, &#39;num_*_samples&#39;):
                                                        n_samps = int(header[key])
                                        else:
                                                if key.startswith(&#39;num_spikes&#39;):
                                                        n_samps = int(header[key]) * 4
                        except IOError:
                                print(&#39;File type not recognised&#39;)
                        f = open(filename_root, &#39;rb&#39;)
                        data = f.read()
                        st = data.find(b&#39;data_start&#39;) + len(&#39;data_start&#39;)
                        f.seek(st)
                        if fType == &#39;.log&#39;:
                                f.seek(0)
                        dt = np.dtype(self.axona_files[fType])
                        a = np.fromfile(f, dtype=dt, count=n_samps)
                        f.close()
                return a

        def getCluCut(self, tet):
                &#39;&#39;&#39;Load a clu file and return as an array of integers&#39;&#39;&#39;
                filename_root = self.filename_root + &#39;.&#39; + &#39;clu.&#39; + str(tet)
                dt = np.dtype([(&#39;data&#39;, &#39;&lt;i&#39;)])
                clu_data = np.loadtxt(filename_root, dtype=dt)
                return clu_data[&#39;data&#39;][1::]  # first entry is number of clusters found

        def getCut(self, tet):
                &#39;&#39;&#39;Returns the cut file as a list of integers&#39;&#39;&#39;
                a = []
                filename_root = self.filename_root + &#39;_&#39; + str(tet) + &#39;.cut&#39;
                if not os.path.exists(filename_root):
                        cut = self.getCluCut(tet)
                        return cut - 1
                with open(filename_root, &#39;r&#39;) as f:
                        cut_data = f.read()
                        f.close()
                tmp = cut_data.split(&#39;spikes: &#39;)
                tmp1 = tmp[1].split(&#39;\n&#39;)
                cut = tmp1[1:]
                for line in cut:
                        m = line.split()
                        for i in m:
                                a.append(int(i))
                return a

        def setHeader(self, filename_root: str, header: dict):
                &#39;&#39;&#39;
                Writes out the header to the specified file

                Parameters
                ------------
                filename_root - a fully qualified path to a file with the relevant suffix at
                the end (e.g. &#34;.set&#34;, &#34;.pos&#34; or whatever)

                header - a dict, an empty version of which can be loaded using getEmptyHeader above
                &#39;&#39;&#39;
                encoding = &#34;ISO-8859-1&#34;
                with open(filename_root, &#39;w&#39;) as f:
                        for key, val in header.items():
                                f.write(key)#, encoding))
                                f.write(&#34; &#34;)#, encoding))
                                if val is None:
                                        val = &#34;&#34;
                                f.write(val)#, encoding))
                                f.write(&#39;\r\n&#39;)#, encoding))
                        f.write(&#39;data_start&#39;)#, encoding))
                        f.write(&#39;\r\n&#39;)
                        f.write(&#39;data_end&#39;)
                        f.write(&#39;\r\n&#39;)

        def setData(self, filename_root: str, data: np.array):
                &#39;&#39;&#39;
                Writes data to the given filename
                Assumes the data is in the correct format
                &#39;&#39;&#39;
                encoding = &#34;ISO-8859-1&#34;
                fType = os.path.splitext(filename_root)[1]
                if fType in self.axona_files:
                        f = open(filename_root, &#39;rb+&#39;)
                        d = f.read()
                        st = d.find(b&#39;data_start&#39;) + len(&#39;data_start&#39;)
                        f.seek(st)
                        data.tofile(f)
                        f.close()
                        f = open(filename_root, &#39;a&#39;)
                        f.write(&#39;\r\n&#39;)
                        f.write(&#39;data_end&#39;)
                        f.write(&#39;\r\n&#39;)
                        f.close()

        def getHeader(self, filename_root):
                &#39;&#39;&#39;
                Returns the header of a specified data file as a dictionary

                Parameters
                ------------
                filename_root (str) - fully qualified filename of Axona type

                Returns
                -------
                A dictionary with key - value pairs of the header part of an Axona type file
                &#39;&#39;&#39;
                with open(filename_root, &#39;rb&#39;) as f:
                        data = f.read()
                        f.close()
                if os.path.splitext(filename_root)[1] != &#39;.set&#39;:
                        st = data.find(b&#39;data_start&#39;) + len(&#39;data_start&#39;)
                        header = data[0:st-len(&#39;data_start&#39;)-2]
                else:
                        header = data
                headerDict = {}
                lines = header.splitlines()
                for line in lines:
                        line = str(line.decode(&#34;ISO-8859-1&#34;)).rstrip()
                        line = line.split(&#39; &#39;, 1)
                        try:
                                headerDict[line[0]] = line[1]
                        except IndexError:
                                headerDict[line[0]] = &#39;&#39;
                return headerDict

        def getHeaderVal(self, header, key):
                &#39;&#39;&#39;
                Given a header and a key value string (&#39;timebase&#39;, &#39;sample_rate&#39;, etc)
                returns the associated value
                &#39;&#39;&#39;
                tmp = header[key]
                val = tmp.split(&#39; &#39;)
                val = val[0].split(&#39;.&#39;)
                val = int(val[0])
                return val</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ephysiopy.dacq2py.axonaIO.EEG" href="#ephysiopy.dacq2py.axonaIO.EEG">EEG</a></li>
<li><a title="ephysiopy.dacq2py.axonaIO.Pos" href="#ephysiopy.dacq2py.axonaIO.Pos">Pos</a></li>
<li><a title="ephysiopy.dacq2py.axonaIO.Stim" href="#ephysiopy.dacq2py.axonaIO.Stim">Stim</a></li>
<li><a title="ephysiopy.dacq2py.axonaIO.Tetrode" href="#ephysiopy.dacq2py.axonaIO.Tetrode">Tetrode</a></li>
<li><a title="ephysiopy.dacq2py.dacq2py_util.Trial" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial">Trial</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="ephysiopy.dacq2py.axonaIO.IO.axona_files"><code class="name">var <span class="ident">axona_files</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="ephysiopy.dacq2py.axonaIO.IO.other_files"><code class="name">var <span class="ident">other_files</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="ephysiopy.dacq2py.axonaIO.IO.tetrode_files"><code class="name">var <span class="ident">tetrode_files</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="ephysiopy.dacq2py.axonaIO.IO.getEmptyHeader"><code class="name flex">
<span>def <span class="ident">getEmptyHeader</span></span>(<span>ftype)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def getEmptyHeader(ftype: str)-&gt;dict:
        pname = empty_headers.get(ftype, &#39;&#39;)
        if os.path.isfile(pname):
                with open(pname, &#39;rb&#39;) as f:
                        return pickle.load(f)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ephysiopy.dacq2py.axonaIO.IO.getCluCut"><code class="name flex">
<span>def <span class="ident">getCluCut</span></span>(<span>self, tet)</span>
</code></dt>
<dd>
<section class="desc"><p>Load a clu file and return as an array of integers</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getCluCut(self, tet):
        &#39;&#39;&#39;Load a clu file and return as an array of integers&#39;&#39;&#39;
        filename_root = self.filename_root + &#39;.&#39; + &#39;clu.&#39; + str(tet)
        dt = np.dtype([(&#39;data&#39;, &#39;&lt;i&#39;)])
        clu_data = np.loadtxt(filename_root, dtype=dt)
        return clu_data[&#39;data&#39;][1::]  # first entry is number of clusters found</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.axonaIO.IO.getCut"><code class="name flex">
<span>def <span class="ident">getCut</span></span>(<span>self, tet)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the cut file as a list of integers</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getCut(self, tet):
        &#39;&#39;&#39;Returns the cut file as a list of integers&#39;&#39;&#39;
        a = []
        filename_root = self.filename_root + &#39;_&#39; + str(tet) + &#39;.cut&#39;
        if not os.path.exists(filename_root):
                cut = self.getCluCut(tet)
                return cut - 1
        with open(filename_root, &#39;r&#39;) as f:
                cut_data = f.read()
                f.close()
        tmp = cut_data.split(&#39;spikes: &#39;)
        tmp1 = tmp[1].split(&#39;\n&#39;)
        cut = tmp1[1:]
        for line in cut:
                m = line.split()
                for i in m:
                        a.append(int(i))
        return a</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.axonaIO.IO.getData"><code class="name flex">
<span>def <span class="ident">getData</span></span>(<span>self, filename_root)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the data part of an Axona data file i.e. from "data_start" to
"data_end"
Parameters</p>
<hr>
<dl>
<dt><strong><code>input</code></strong> :&ensp; <code>str</code></dt>
<dd>fully qualified path name to the data file</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>output</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>the data part of whatever file was fed in. Format specified from file type</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getData(self, filename_root):
        &#39;&#39;&#39;
        Returns the data part of an Axona data file i.e. from &#34;data_start&#34; to
        &#34;data_end&#34;
        Parameters
        ----------------------
        input:  str
                        fully qualified path name to the data file
        Returns
        ---------
        output: numpy.array
                        the data part of whatever file was fed in. Format specified from file type
        &#39;&#39;&#39;
        n_samps = -1
        fType = os.path.splitext(filename_root)[1]
        if fType in self.axona_files:
                try:
                        header = self.getHeader(filename_root)
                        for key in header.keys():
                                if len(fType) &gt; 2:
                                        if fnmatch.fnmatch(key, &#39;num_*_samples&#39;):
                                                n_samps = int(header[key])
                                else:
                                        if key.startswith(&#39;num_spikes&#39;):
                                                n_samps = int(header[key]) * 4
                except IOError:
                        print(&#39;File type not recognised&#39;)
                f = open(filename_root, &#39;rb&#39;)
                data = f.read()
                st = data.find(b&#39;data_start&#39;) + len(&#39;data_start&#39;)
                f.seek(st)
                if fType == &#39;.log&#39;:
                        f.seek(0)
                dt = np.dtype(self.axona_files[fType])
                a = np.fromfile(f, dtype=dt, count=n_samps)
                f.close()
        return a</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.axonaIO.IO.getHeader"><code class="name flex">
<span>def <span class="ident">getHeader</span></span>(<span>self, filename_root)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the header of a specified data file as a dictionary</p>
<h2 id="parameters">Parameters</h2>
<p>filename_root (str) - fully qualified filename of Axona type</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A</code> <code>dictionary</code> <code>with</code> <code>key</code> - <code>value</code> <code>pairs</code> of <code>the</code> <code>header</code> <code>part</code> of <code>an</code> <code>Axona</code> <code>type</code> <code>file</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getHeader(self, filename_root):
        &#39;&#39;&#39;
        Returns the header of a specified data file as a dictionary

        Parameters
        ------------
        filename_root (str) - fully qualified filename of Axona type

        Returns
        -------
        A dictionary with key - value pairs of the header part of an Axona type file
        &#39;&#39;&#39;
        with open(filename_root, &#39;rb&#39;) as f:
                data = f.read()
                f.close()
        if os.path.splitext(filename_root)[1] != &#39;.set&#39;:
                st = data.find(b&#39;data_start&#39;) + len(&#39;data_start&#39;)
                header = data[0:st-len(&#39;data_start&#39;)-2]
        else:
                header = data
        headerDict = {}
        lines = header.splitlines()
        for line in lines:
                line = str(line.decode(&#34;ISO-8859-1&#34;)).rstrip()
                line = line.split(&#39; &#39;, 1)
                try:
                        headerDict[line[0]] = line[1]
                except IndexError:
                        headerDict[line[0]] = &#39;&#39;
        return headerDict</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.axonaIO.IO.getHeaderVal"><code class="name flex">
<span>def <span class="ident">getHeaderVal</span></span>(<span>self, header, key)</span>
</code></dt>
<dd>
<section class="desc"><p>Given a header and a key value string ('timebase', 'sample_rate', etc)
returns the associated value</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getHeaderVal(self, header, key):
        &#39;&#39;&#39;
        Given a header and a key value string (&#39;timebase&#39;, &#39;sample_rate&#39;, etc)
        returns the associated value
        &#39;&#39;&#39;
        tmp = header[key]
        val = tmp.split(&#39; &#39;)
        val = val[0].split(&#39;.&#39;)
        val = int(val[0])
        return val</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.axonaIO.IO.setData"><code class="name flex">
<span>def <span class="ident">setData</span></span>(<span>self, filename_root, data)</span>
</code></dt>
<dd>
<section class="desc"><p>Writes data to the given filename
Assumes the data is in the correct format</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setData(self, filename_root: str, data: np.array):
        &#39;&#39;&#39;
        Writes data to the given filename
        Assumes the data is in the correct format
        &#39;&#39;&#39;
        encoding = &#34;ISO-8859-1&#34;
        fType = os.path.splitext(filename_root)[1]
        if fType in self.axona_files:
                f = open(filename_root, &#39;rb+&#39;)
                d = f.read()
                st = d.find(b&#39;data_start&#39;) + len(&#39;data_start&#39;)
                f.seek(st)
                data.tofile(f)
                f.close()
                f = open(filename_root, &#39;a&#39;)
                f.write(&#39;\r\n&#39;)
                f.write(&#39;data_end&#39;)
                f.write(&#39;\r\n&#39;)
                f.close()</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.axonaIO.IO.setHeader"><code class="name flex">
<span>def <span class="ident">setHeader</span></span>(<span>self, filename_root, header)</span>
</code></dt>
<dd>
<section class="desc"><p>Writes out the header to the specified file</p>
<h2 id="parameters">Parameters</h2>
<p>filename_root - a fully qualified path to a file with the relevant suffix at
the end (e.g. ".set", ".pos" or whatever)</p>
<p>header - a dict, an empty version of which can be loaded using getEmptyHeader above</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setHeader(self, filename_root: str, header: dict):
        &#39;&#39;&#39;
        Writes out the header to the specified file

        Parameters
        ------------
        filename_root - a fully qualified path to a file with the relevant suffix at
        the end (e.g. &#34;.set&#34;, &#34;.pos&#34; or whatever)

        header - a dict, an empty version of which can be loaded using getEmptyHeader above
        &#39;&#39;&#39;
        encoding = &#34;ISO-8859-1&#34;
        with open(filename_root, &#39;w&#39;) as f:
                for key, val in header.items():
                        f.write(key)#, encoding))
                        f.write(&#34; &#34;)#, encoding))
                        if val is None:
                                val = &#34;&#34;
                        f.write(val)#, encoding))
                        f.write(&#39;\r\n&#39;)#, encoding))
                f.write(&#39;data_start&#39;)#, encoding))
                f.write(&#39;\r\n&#39;)
                f.write(&#39;data_end&#39;)
                f.write(&#39;\r\n&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ephysiopy.dacq2py.axonaIO.Pos"><code class="flex name class">
<span>class <span class="ident">Pos</span></span>
<span>(</span><span>filename_root, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Class for reading data from Axona data acquisition system. Also
reads .clu files generated from KlustaKwik</p>
<p>Class attributes:
axona_files (dict): keys are axona format file suffixes
and the values are used as numpy dtypes to read the data.
NB it's assumed a .set file is <em>always</em> present</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Pos(IO):
        def __init__(self, filename_root, *args, **kwargs):
                self.filename_root = filename_root
                self.header = self.getHeader(filename_root + &#39;.pos&#39;)
                self.setheader = None
                try:
                        self.setheader = self.getHeader(filename_root + &#39;.set&#39;)
                except Exception:
                        pass
                self.posProcessed = False
                posData = self.getData(filename_root + &#39;.pos&#39;)
                self.nLEDs = 1
                if self.setheader is not None:
                        self.nLEDs = sum([self.getHeaderVal(self.setheader,&#39;colactive_1&#39;),
                                                          self.getHeaderVal(self.setheader,&#39;colactive_2&#39;)])
                if self.nLEDs == 1:
                        self.led_pos = np.ma.masked_values([posData[&#39;pos&#39;][:,0],posData[&#39;pos&#39;][:,1]],1023)
                        self.led_pix = np.ma.masked_values(posData[&#39;pos&#39;][:,4],1023)
                elif self.nLEDs == 2:
                        self.led_pos = np.ma.masked_values([posData[&#39;pos&#39;][:,0],posData[&#39;pos&#39;][:,1],
                                                                                         posData[&#39;pos&#39;][:,2],posData[&#39;pos&#39;][:,3]],1023)
                        self.led_pix = np.ma.masked_values([posData[&#39;pos&#39;][:,4],posData[&#39;pos&#39;][:,5]],1023)
                self.npos = len(self.led_pos[0])
                self.xy = np.ones([2,self.npos]) * np.nan
                self.dir = np.ones([self.npos]) * np.nan
                self.dir_disp = np.ones([self.npos]) * np.nan
                self.speed = np.ones([self.npos]) * np.nan
                self.pos_sample_rate = self.getHeaderVal(self.header, &#39;sample_rate&#39;)
                self._ppm = None
                if &#39;cm&#39; in kwargs:
                        self.cm = kwargs[&#39;cm&#39;]
                else:
                        self.cm = False # if True return xy in cm, otherwise in pixels (see end of postprocesspos)

        @property
        def ppm(self):
                if self._ppm is None:
                        try:
                                self._ppm = self.getHeaderVal(self.header, &#39;pixels_per_metre&#39;)
                        except IOError:
                                self._ppm = None
                return self._ppm

        @ppm.setter
        def ppm(self, value):
                self._ppm = value
                self.posProcessed = False
                self.postprocesspos()

        def __getitem__(self, key):
                try:
                        val = self.__dict__[key]
                        return val
                except:
                        pass

        def postprocesspos(self):
                &#39;&#39;&#39;post processes position data
                something isn&#39;t quite right here at least with 2 led data&#39;&#39;&#39;
                if self.posProcessed is True:
                        return
                elif self.posProcessed is False:
                        led_pos = self.led_pos
                        led_pix = self.led_pix
                        # as with AJ&#39;s implementation in mtint, calculate weights for a weighted mean
                        # of the front and back leds for when trials have poorly tracked trials
                        # NB could probably do this straight from the number of leds tracked which
                        # is available in the raw data
                        # need to mask all values of the array using logical or to replicate
                        # mtints way of filling in missing values
                        nLED_idx = self.nLEDs * 2
                        led_pos[0:nLED_idx].__setmask__(led_pos[0:nLED_idx].mask.any(axis=0))
                        weights = np.zeros(2)
                        weights[0] = float(np.sum(np.nonzero(led_pos[0:2]), axis=1)[0]) / self.npos
                        try:
                                weights[1] = float(np.sum(np.nonzero(led_pos[2:4]), axis=1)[0]) / self.npos
                        except IndexError:
                                pass
                        # need to deal with improperly tracked positions where the values are
                        # plainly ridiculous
                        # values less than 0 are masked
                        led_pos[led_pos &lt; 0] = np.ma.masked
                        # deal with values outside the range of the tracked window
                        led_pos[0, (led_pos[0] &gt; int(self.header[&#39;max_x&#39;]))] = np.ma.masked
                        led_pos[1, (led_pos[1] &gt; int(self.header[&#39;max_y&#39;]))] = np.ma.masked
                        # try and deal with other led if present
                        try:
                                led_pos[2, (led_pos[2] &gt; int(self.header[&#39;max_x&#39;]))] = np.ma.masked
                                led_pos[3, (led_pos[3] &gt; int(self.header[&#39;max_y&#39;]))] = np.ma.masked
                        except IndexError:
                                pass
                        if np.logical_and(np.any(np.nonzero(led_pix)), self.nLEDs==2):
                                swap_list = self.ledswapFilter(led_pos, led_pix)
                                tmp = led_pos[0:2, swap_list]
                                led_pos[0:2, swap_list] = led_pos[2:4, swap_list]
                                led_pos[2:4, swap_list] = tmp
                                tmp = led_pix[0, swap_list]
                                led_pix[0, swap_list] = led_pix[1, swap_list]
                                led_pix[1, swap_list] = tmp
                        ppm = self.ppm
                        max_ppm_per_sample = MAXSPEED * ppm / self.pos_sample_rate
                        led_pos = self.ledspeedFilter(led_pos,max_ppm_per_sample)
                        led_pos = self.interpNans(led_pos)
                        # get distances and angles of LEDs from rat
                        pos1 = np.arange(0,self.npos)
                        pos2 = np.arange(0,self.npos-1)
                        if self.nLEDs == 1:
                                self.xy[0:2,pos1] = led_pos[0:2,pos1]
                                self.xy[0,:] = sm.smooth(self.xy[0,:],BOXCAR,&#39;flat&#39;)
                                self.xy[1,:] = sm.smooth(self.xy[1,:],BOXCAR,&#39;flat&#39;)
                                self.dir[pos2] = np.mod(((180/math.pi) * (np.arctan2(-self.xy[1,pos2+1] + self.xy[1,pos2],+self.xy[0,pos2+1]-self.xy[0,pos2]))), 360)
                                self.dir[-1] = self.dir[-2]
                                self.dir_disp = self.dir
                        elif self.nLEDs == 2:
                                lightBearings = np.zeros([2,1])
                                lightBearings[0] = self.getHeaderVal(self.setheader,&#39;lightBearing_1&#39;)
                                lightBearings[1] = self.getHeaderVal(self.setheader,&#39;lightBearing_2&#39;)
                                front_back_xy_sm = np.zeros([4,self.npos])
                                for i in range(len(front_back_xy_sm)):
#                    front_back_xy_sm[i,pos1] = scipy.signal.convolve(led_pos[i, pos1], np.ones(BOXCAR) / BOXCAR, mode=&#39;same&#39;)
                                        front_back_xy_sm[i,pos1] = sm.smooth(led_pos[i,pos1],BOXCAR,&#39;flat&#39;)
                                correction = lightBearings[0]
                                self.dir[pos1] = np.mod((180/math.pi) * (np.arctan2(-front_back_xy_sm[1,pos1]+front_back_xy_sm[3,pos1],
                                                                  +front_back_xy_sm[0,pos1]-front_back_xy_sm[2,pos1])-correction),360)
                                # get xy from smoothed individual lights weighting for reliability
                                self.xy[0,pos1] = (weights[0]*front_back_xy_sm[0,pos1] + weights[1]*front_back_xy_sm[2,pos1]) / np.sum(weights)
                                self.xy[1,pos1] = (weights[0]*front_back_xy_sm[1,pos1] + weights[1]*front_back_xy_sm[3,pos1]) / np.sum(weights)
                                self.dir_disp[pos2] = np.mod(((180/math.pi) * (np.arctan2(-self.xy[1,pos2+1] + self.xy[1,pos2],+self.xy[0,pos2+1]-self.xy[0,pos2]))) ,360)
                                self.dir_disp[-1] = self.dir_disp[-2]

                        if self.cm:
                                self.xy = self.xy / ppm * 100 # xy now in cm
                        # calculate speed based on distance
                        self.speed[pos2] = np.sqrt(np.sum(np.power(np.diff(self.xy),2),0))
                        self.speed[self.npos-1] = self.speed[-1]
                        self.speed = self.speed * (100 * self.pos_sample_rate / ppm) # *100 to get into cm/s
                        if np.isnan(self.speed[-1]):
                                self.speed[-1] = 0

                        self.posProcessed = True

        def ledspeedFilter(self,led_pos,max_ppm_per_sample):
                &#39;&#39;&#39;
                Filters for impossibly fast tracked points
                input: masked led_pos array [x1,y1,x2,y2]
                max_ppm_per_sample
                led = big or small (1 or 2)
                output: number of jumpy points
                masked led_pos
                &#39;&#39;&#39;
                max_ppms_sqd = max_ppm_per_sample ** 2
                for i in range(0,len(led_pos),2):
                        ok_pos = led_pos[i,:]
                        prev_pos = ok_pos[0:-1]
                        cur_pos = ok_pos[1:]
                        pix_per_sample_sqd = (np.power((np.subtract(led_pos[i,cur_pos], led_pos[i,prev_pos])),2) + np.power((np.subtract(led_pos[i+1,cur_pos], led_pos[i+1,prev_pos])),2)) / np.power(np.subtract(cur_pos,prev_pos),2)
                        pix_per_sample_sqd = np.insert(pix_per_sample_sqd, -1, 0)
                        led_pos[i:i+2,pix_per_sample_sqd &gt; max_ppms_sqd] = np.ma.masked
                return led_pos

        def ledswapFilter(self,led_pos,led_pix):
                &#39;&#39;&#39;Checks for led swapping in 2-spot mode
                input: led_pos - a masked array of dims [4 x nPosSamples]
                format is x1,y1,x2,y2
                mskd_pix - a masked array of dims [2 x nPosSamples]
                format is nPix1, nPix2
                output: list of swapped positions&#39;&#39;&#39;
                thresh = 5
                mean_npix = led_pix.mean(axis=1).data
                std_npix = led_pix.std(axis=1).data
                pos = np.arange(1,led_pix.shape[1])
                #calculate distances
                dist12 = np.sqrt(np.nansum(((np.squeeze(led_pos[0:2,pos])-np.squeeze(led_pos[2:4,pos-1]))**2),axis=0))
                dist11 = np.sqrt(np.nansum(((np.squeeze(led_pos[0:2,pos])-np.squeeze(led_pos[0:2,pos-1]))**2),axis=0))
                dist21 = np.sqrt(np.nansum(((np.squeeze(led_pos[2:4,pos])-np.squeeze(led_pos[0:2,pos-1]))**2),axis=0))
                dist22 = np.sqrt(np.nansum(((np.squeeze(led_pos[2:4,pos])-np.squeeze(led_pos[2:4,pos-1]))**2),axis=0))
                switched = np.logical_or(np.logical_and((dist12 &lt; dist11 - thresh).data,led_pos[2,pos].mask),(dist21 &lt; dist22-thresh).data)
                z11 = (mean_npix[0] - led_pix[0,pos]) / std_npix[0]
                z12 = (led_pix[0,pos] - mean_npix[1]) / std_npix[1]
                shrunk = z11 &gt; z12
                swap_list = np.nonzero(np.logical_and(switched, shrunk.data))[0] + 1
                return swap_list

        def interpNans(self,led_pos):
                &#39;&#39;&#39;interpolates over missing values with the specified
                boxcar
                input: masked array (led_pos)
                output: smoothed, unmasked array (led_pos)&#39;&#39;&#39;
                for i in range(0,len(led_pos),2):
                        missing = led_pos[i:i+2].mask.any(axis=0)
                        ok = np.logical_not(missing)
                        ok_idx = ok.ravel().nonzero()[0]#gets the indices of ok poses
                        missing_idx = missing.ravel().nonzero()[0]#get the indices of missing poses
                        good_data = led_pos.data[i,ok_idx]
                        good_data1 = led_pos.data[i+1,ok_idx]
                        led_pos.data[i,missing_idx] = np.interp(missing_idx,ok_idx,good_data)#,left=np.min(good_data),right=np.max(good_data)
                        led_pos.data[i+1,missing_idx] = np.interp(missing_idx,ok_idx,good_data1) #,left=np.min(good_data1),right=np.max(good_data1) y coord
                #unmask the array
                led_pos.mask = 0
                return led_pos
        def filterPos(self, filterDict):
                &#39;&#39;&#39;
                Filters position data depending on the filter specified in fType
                Inputs:
                filterDict - a dict which contains the type(s) of filter to be used and the
                range of values to filter for. Values are pairs specifying the range
                of values to filter for NB can take multiple filters and iteratively apply them
                legal values are:
                Parameters
                ------------
                &#39;dir&#39; - the directional range to filter for NB this can contain &#39;w&#39;,&#39;e&#39;,&#39;s&#39; or &#39;n&#39;
                &#39;speed&#39; - min and max speed to filter for
                &#39;xrange&#39; - min and max values to filter x pos values
                &#39;yrange&#39; - same as xrange but for y pos
                &#39;time&#39; - the times to keep / remove specified in ms

                Returns
                --------
                the filtered indices i.e. those that should be kept
                &#39;&#39;&#39;
                if filterDict is None:
                        return
                nSamples = int(self.header[&#39;num_pos_samples&#39;])
                bool_arr = np.ones(shape=(len(filterDict), nSamples), dtype=np.bool)
                for idx, key in enumerate(filterDict):
                        if isinstance(filterDict[key], str):
                                if len(filterDict[key]) == 1 and &#39;dir&#39; in key:
                                        if &#39;w&#39; in filterDict[key]:
                                                filterDict[key] = (135, 225)
                                        elif &#39;e&#39; in filterDict[key]:
                                                filterDict[key] = (315, 45)
                                        elif &#39;s&#39; in filterDict[key]:
                                                filterDict[key] = (225, 315)
                                        elif &#39;n&#39; in filterDict[key]:
                                                filterDict[key] = (45, 135)
                                else:
                                        raise ValueError(&#34;filter must contain a key / value pair&#34;)
                                        return
                        if &#39;speed&#39; in key:
                                if filterDict[key][0] &gt; filterDict[key][1]:
                                        raise ValueError(&#34;First value must be less than the second one&#34;)
                                else:
                                        bool_arr[idx,:] = np.logical_and(self.speed &gt; filterDict[key][0],
                                                                         self.speed &lt; filterDict[key][1])
                        elif &#39;dir&#39; in key:
                                if filterDict[key][0] &lt; filterDict[key][1]:
                                        bool_arr[idx,:] = np.logical_and(self.dir &gt; filterDict[key][0],
                                                                                 self.dir &lt; filterDict[key][1])
                                else:
                                        bool_arr[idx,:] = np.logical_or(self.dir &gt; filterDict[key][0],
                                                                                self.dir &lt; filterDict[key][1])
                        elif &#39;xrange&#39; in key:
                                bool_arr[idx, :] = np.logical_and(self.xy[0, :] &gt; filterDict[key][0],
                                                                                self.xy[0, :] &lt; filterDict[key][1])
                        elif &#39;yrange&#39; in key:
                                bool_arr[idx, :] = np.logical_and(self.xy[1, :] &gt; filterDict[key][0],
                                                                                self.xy[1, :] &lt; filterDict[key][1])
                        elif &#39;time&#39; in key:
                                # takes the form of &#39;from&#39; - &#39;to&#39; times in SECONDS such that only pos&#39;s between these ranges are KEPT
                                filterDict[key] = filterDict[key]  * self.pos_sample_rate
                                if filterDict[key].ndim == 1:
                                        bool_arr[idx, filterDict[key][0]:filterDict[key][1]] = False
                                else:
                                        for i in filterDict[key]:
                                                bool_arr[idx, i[0]:i[1]] = False
                                bool_arr = ~bool_arr
                        else:
                                print(&#34;Unrecognised key in dict&#34;)
                                pass
                return np.expand_dims(np.any(~bool_arr, axis=0), 0)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ephysiopy.dacq2py.axonaIO.IO" href="#ephysiopy.dacq2py.axonaIO.IO">IO</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="ephysiopy.dacq2py.axonaIO.Pos.ppm"><code class="name">var <span class="ident">ppm</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ppm(self):
        if self._ppm is None:
                try:
                        self._ppm = self.getHeaderVal(self.header, &#39;pixels_per_metre&#39;)
                except IOError:
                        self._ppm = None
        return self._ppm</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ephysiopy.dacq2py.axonaIO.Pos.filterPos"><code class="name flex">
<span>def <span class="ident">filterPos</span></span>(<span>self, filterDict)</span>
</code></dt>
<dd>
<section class="desc"><p>Filters position data depending on the filter specified in fType
Inputs:
filterDict - a dict which contains the type(s) of filter to be used and the
range of values to filter for. Values are pairs specifying the range
of values to filter for NB can take multiple filters and iteratively apply them
legal values are:
Parameters</p>
<hr>
<p>'dir' - the directional range to filter for NB this can contain 'w','e','s' or 'n'
'speed' - min and max speed to filter for
'xrange' - min and max values to filter x pos values
'yrange' - same as xrange but for y pos
'time' - the times to keep / remove specified in ms</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>the</code> <code>filtered</code> <code>indices</code> <code>i.e.</code> <code>those</code> <code>that</code> <code>should</code> <code>be</code> <code>kept</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filterPos(self, filterDict):
        &#39;&#39;&#39;
        Filters position data depending on the filter specified in fType
        Inputs:
        filterDict - a dict which contains the type(s) of filter to be used and the
        range of values to filter for. Values are pairs specifying the range
        of values to filter for NB can take multiple filters and iteratively apply them
        legal values are:
        Parameters
        ------------
        &#39;dir&#39; - the directional range to filter for NB this can contain &#39;w&#39;,&#39;e&#39;,&#39;s&#39; or &#39;n&#39;
        &#39;speed&#39; - min and max speed to filter for
        &#39;xrange&#39; - min and max values to filter x pos values
        &#39;yrange&#39; - same as xrange but for y pos
        &#39;time&#39; - the times to keep / remove specified in ms

        Returns
        --------
        the filtered indices i.e. those that should be kept
        &#39;&#39;&#39;
        if filterDict is None:
                return
        nSamples = int(self.header[&#39;num_pos_samples&#39;])
        bool_arr = np.ones(shape=(len(filterDict), nSamples), dtype=np.bool)
        for idx, key in enumerate(filterDict):
                if isinstance(filterDict[key], str):
                        if len(filterDict[key]) == 1 and &#39;dir&#39; in key:
                                if &#39;w&#39; in filterDict[key]:
                                        filterDict[key] = (135, 225)
                                elif &#39;e&#39; in filterDict[key]:
                                        filterDict[key] = (315, 45)
                                elif &#39;s&#39; in filterDict[key]:
                                        filterDict[key] = (225, 315)
                                elif &#39;n&#39; in filterDict[key]:
                                        filterDict[key] = (45, 135)
                        else:
                                raise ValueError(&#34;filter must contain a key / value pair&#34;)
                                return
                if &#39;speed&#39; in key:
                        if filterDict[key][0] &gt; filterDict[key][1]:
                                raise ValueError(&#34;First value must be less than the second one&#34;)
                        else:
                                bool_arr[idx,:] = np.logical_and(self.speed &gt; filterDict[key][0],
                                                                 self.speed &lt; filterDict[key][1])
                elif &#39;dir&#39; in key:
                        if filterDict[key][0] &lt; filterDict[key][1]:
                                bool_arr[idx,:] = np.logical_and(self.dir &gt; filterDict[key][0],
                                                                         self.dir &lt; filterDict[key][1])
                        else:
                                bool_arr[idx,:] = np.logical_or(self.dir &gt; filterDict[key][0],
                                                                        self.dir &lt; filterDict[key][1])
                elif &#39;xrange&#39; in key:
                        bool_arr[idx, :] = np.logical_and(self.xy[0, :] &gt; filterDict[key][0],
                                                                        self.xy[0, :] &lt; filterDict[key][1])
                elif &#39;yrange&#39; in key:
                        bool_arr[idx, :] = np.logical_and(self.xy[1, :] &gt; filterDict[key][0],
                                                                        self.xy[1, :] &lt; filterDict[key][1])
                elif &#39;time&#39; in key:
                        # takes the form of &#39;from&#39; - &#39;to&#39; times in SECONDS such that only pos&#39;s between these ranges are KEPT
                        filterDict[key] = filterDict[key]  * self.pos_sample_rate
                        if filterDict[key].ndim == 1:
                                bool_arr[idx, filterDict[key][0]:filterDict[key][1]] = False
                        else:
                                for i in filterDict[key]:
                                        bool_arr[idx, i[0]:i[1]] = False
                        bool_arr = ~bool_arr
                else:
                        print(&#34;Unrecognised key in dict&#34;)
                        pass
        return np.expand_dims(np.any(~bool_arr, axis=0), 0)</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.axonaIO.Pos.interpNans"><code class="name flex">
<span>def <span class="ident">interpNans</span></span>(<span>self, led_pos)</span>
</code></dt>
<dd>
<section class="desc"><p>interpolates over missing values with the specified
boxcar
input: masked array (led_pos)
output: smoothed, unmasked array (led_pos)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpNans(self,led_pos):
        &#39;&#39;&#39;interpolates over missing values with the specified
        boxcar
        input: masked array (led_pos)
        output: smoothed, unmasked array (led_pos)&#39;&#39;&#39;
        for i in range(0,len(led_pos),2):
                missing = led_pos[i:i+2].mask.any(axis=0)
                ok = np.logical_not(missing)
                ok_idx = ok.ravel().nonzero()[0]#gets the indices of ok poses
                missing_idx = missing.ravel().nonzero()[0]#get the indices of missing poses
                good_data = led_pos.data[i,ok_idx]
                good_data1 = led_pos.data[i+1,ok_idx]
                led_pos.data[i,missing_idx] = np.interp(missing_idx,ok_idx,good_data)#,left=np.min(good_data),right=np.max(good_data)
                led_pos.data[i+1,missing_idx] = np.interp(missing_idx,ok_idx,good_data1) #,left=np.min(good_data1),right=np.max(good_data1) y coord
        #unmask the array
        led_pos.mask = 0
        return led_pos</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.axonaIO.Pos.ledspeedFilter"><code class="name flex">
<span>def <span class="ident">ledspeedFilter</span></span>(<span>self, led_pos, max_ppm_per_sample)</span>
</code></dt>
<dd>
<section class="desc"><p>Filters for impossibly fast tracked points
input: masked led_pos array [x1,y1,x2,y2]
max_ppm_per_sample
led = big or small (1 or 2)
output: number of jumpy points
masked led_pos</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ledspeedFilter(self,led_pos,max_ppm_per_sample):
        &#39;&#39;&#39;
        Filters for impossibly fast tracked points
        input: masked led_pos array [x1,y1,x2,y2]
        max_ppm_per_sample
        led = big or small (1 or 2)
        output: number of jumpy points
        masked led_pos
        &#39;&#39;&#39;
        max_ppms_sqd = max_ppm_per_sample ** 2
        for i in range(0,len(led_pos),2):
                ok_pos = led_pos[i,:]
                prev_pos = ok_pos[0:-1]
                cur_pos = ok_pos[1:]
                pix_per_sample_sqd = (np.power((np.subtract(led_pos[i,cur_pos], led_pos[i,prev_pos])),2) + np.power((np.subtract(led_pos[i+1,cur_pos], led_pos[i+1,prev_pos])),2)) / np.power(np.subtract(cur_pos,prev_pos),2)
                pix_per_sample_sqd = np.insert(pix_per_sample_sqd, -1, 0)
                led_pos[i:i+2,pix_per_sample_sqd &gt; max_ppms_sqd] = np.ma.masked
        return led_pos</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.axonaIO.Pos.ledswapFilter"><code class="name flex">
<span>def <span class="ident">ledswapFilter</span></span>(<span>self, led_pos, led_pix)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks for led swapping in 2-spot mode
input: led_pos - a masked array of dims [4 x nPosSamples]
format is x1,y1,x2,y2
mskd_pix - a masked array of dims [2 x nPosSamples]
format is nPix1, nPix2
output: list of swapped positions</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ledswapFilter(self,led_pos,led_pix):
        &#39;&#39;&#39;Checks for led swapping in 2-spot mode
        input: led_pos - a masked array of dims [4 x nPosSamples]
        format is x1,y1,x2,y2
        mskd_pix - a masked array of dims [2 x nPosSamples]
        format is nPix1, nPix2
        output: list of swapped positions&#39;&#39;&#39;
        thresh = 5
        mean_npix = led_pix.mean(axis=1).data
        std_npix = led_pix.std(axis=1).data
        pos = np.arange(1,led_pix.shape[1])
        #calculate distances
        dist12 = np.sqrt(np.nansum(((np.squeeze(led_pos[0:2,pos])-np.squeeze(led_pos[2:4,pos-1]))**2),axis=0))
        dist11 = np.sqrt(np.nansum(((np.squeeze(led_pos[0:2,pos])-np.squeeze(led_pos[0:2,pos-1]))**2),axis=0))
        dist21 = np.sqrt(np.nansum(((np.squeeze(led_pos[2:4,pos])-np.squeeze(led_pos[0:2,pos-1]))**2),axis=0))
        dist22 = np.sqrt(np.nansum(((np.squeeze(led_pos[2:4,pos])-np.squeeze(led_pos[2:4,pos-1]))**2),axis=0))
        switched = np.logical_or(np.logical_and((dist12 &lt; dist11 - thresh).data,led_pos[2,pos].mask),(dist21 &lt; dist22-thresh).data)
        z11 = (mean_npix[0] - led_pix[0,pos]) / std_npix[0]
        z12 = (led_pix[0,pos] - mean_npix[1]) / std_npix[1]
        shrunk = z11 &gt; z12
        swap_list = np.nonzero(np.logical_and(switched, shrunk.data))[0] + 1
        return swap_list</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.axonaIO.Pos.postprocesspos"><code class="name flex">
<span>def <span class="ident">postprocesspos</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>post processes position data
something isn't quite right here at least with 2 led data</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">        def postprocesspos(self):
                &#39;&#39;&#39;post processes position data
                something isn&#39;t quite right here at least with 2 led data&#39;&#39;&#39;
                if self.posProcessed is True:
                        return
                elif self.posProcessed is False:
                        led_pos = self.led_pos
                        led_pix = self.led_pix
                        # as with AJ&#39;s implementation in mtint, calculate weights for a weighted mean
                        # of the front and back leds for when trials have poorly tracked trials
                        # NB could probably do this straight from the number of leds tracked which
                        # is available in the raw data
                        # need to mask all values of the array using logical or to replicate
                        # mtints way of filling in missing values
                        nLED_idx = self.nLEDs * 2
                        led_pos[0:nLED_idx].__setmask__(led_pos[0:nLED_idx].mask.any(axis=0))
                        weights = np.zeros(2)
                        weights[0] = float(np.sum(np.nonzero(led_pos[0:2]), axis=1)[0]) / self.npos
                        try:
                                weights[1] = float(np.sum(np.nonzero(led_pos[2:4]), axis=1)[0]) / self.npos
                        except IndexError:
                                pass
                        # need to deal with improperly tracked positions where the values are
                        # plainly ridiculous
                        # values less than 0 are masked
                        led_pos[led_pos &lt; 0] = np.ma.masked
                        # deal with values outside the range of the tracked window
                        led_pos[0, (led_pos[0] &gt; int(self.header[&#39;max_x&#39;]))] = np.ma.masked
                        led_pos[1, (led_pos[1] &gt; int(self.header[&#39;max_y&#39;]))] = np.ma.masked
                        # try and deal with other led if present
                        try:
                                led_pos[2, (led_pos[2] &gt; int(self.header[&#39;max_x&#39;]))] = np.ma.masked
                                led_pos[3, (led_pos[3] &gt; int(self.header[&#39;max_y&#39;]))] = np.ma.masked
                        except IndexError:
                                pass
                        if np.logical_and(np.any(np.nonzero(led_pix)), self.nLEDs==2):
                                swap_list = self.ledswapFilter(led_pos, led_pix)
                                tmp = led_pos[0:2, swap_list]
                                led_pos[0:2, swap_list] = led_pos[2:4, swap_list]
                                led_pos[2:4, swap_list] = tmp
                                tmp = led_pix[0, swap_list]
                                led_pix[0, swap_list] = led_pix[1, swap_list]
                                led_pix[1, swap_list] = tmp
                        ppm = self.ppm
                        max_ppm_per_sample = MAXSPEED * ppm / self.pos_sample_rate
                        led_pos = self.ledspeedFilter(led_pos,max_ppm_per_sample)
                        led_pos = self.interpNans(led_pos)
                        # get distances and angles of LEDs from rat
                        pos1 = np.arange(0,self.npos)
                        pos2 = np.arange(0,self.npos-1)
                        if self.nLEDs == 1:
                                self.xy[0:2,pos1] = led_pos[0:2,pos1]
                                self.xy[0,:] = sm.smooth(self.xy[0,:],BOXCAR,&#39;flat&#39;)
                                self.xy[1,:] = sm.smooth(self.xy[1,:],BOXCAR,&#39;flat&#39;)
                                self.dir[pos2] = np.mod(((180/math.pi) * (np.arctan2(-self.xy[1,pos2+1] + self.xy[1,pos2],+self.xy[0,pos2+1]-self.xy[0,pos2]))), 360)
                                self.dir[-1] = self.dir[-2]
                                self.dir_disp = self.dir
                        elif self.nLEDs == 2:
                                lightBearings = np.zeros([2,1])
                                lightBearings[0] = self.getHeaderVal(self.setheader,&#39;lightBearing_1&#39;)
                                lightBearings[1] = self.getHeaderVal(self.setheader,&#39;lightBearing_2&#39;)
                                front_back_xy_sm = np.zeros([4,self.npos])
                                for i in range(len(front_back_xy_sm)):
#                    front_back_xy_sm[i,pos1] = scipy.signal.convolve(led_pos[i, pos1], np.ones(BOXCAR) / BOXCAR, mode=&#39;same&#39;)
                                        front_back_xy_sm[i,pos1] = sm.smooth(led_pos[i,pos1],BOXCAR,&#39;flat&#39;)
                                correction = lightBearings[0]
                                self.dir[pos1] = np.mod((180/math.pi) * (np.arctan2(-front_back_xy_sm[1,pos1]+front_back_xy_sm[3,pos1],
                                                                  +front_back_xy_sm[0,pos1]-front_back_xy_sm[2,pos1])-correction),360)
                                # get xy from smoothed individual lights weighting for reliability
                                self.xy[0,pos1] = (weights[0]*front_back_xy_sm[0,pos1] + weights[1]*front_back_xy_sm[2,pos1]) / np.sum(weights)
                                self.xy[1,pos1] = (weights[0]*front_back_xy_sm[1,pos1] + weights[1]*front_back_xy_sm[3,pos1]) / np.sum(weights)
                                self.dir_disp[pos2] = np.mod(((180/math.pi) * (np.arctan2(-self.xy[1,pos2+1] + self.xy[1,pos2],+self.xy[0,pos2+1]-self.xy[0,pos2]))) ,360)
                                self.dir_disp[-1] = self.dir_disp[-2]

                        if self.cm:
                                self.xy = self.xy / ppm * 100 # xy now in cm
                        # calculate speed based on distance
                        self.speed[pos2] = np.sqrt(np.sum(np.power(np.diff(self.xy),2),0))
                        self.speed[self.npos-1] = self.speed[-1]
                        self.speed = self.speed * (100 * self.pos_sample_rate / ppm) # *100 to get into cm/s
                        if np.isnan(self.speed[-1]):
                                self.speed[-1] = 0

                        self.posProcessed = True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ephysiopy.dacq2py.axonaIO.IO" href="#ephysiopy.dacq2py.axonaIO.IO">IO</a></b></code>:
<ul class="hlist">
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.getCluCut" href="#ephysiopy.dacq2py.axonaIO.IO.getCluCut">getCluCut</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.getCut" href="#ephysiopy.dacq2py.axonaIO.IO.getCut">getCut</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.getData" href="#ephysiopy.dacq2py.axonaIO.IO.getData">getData</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.getHeader" href="#ephysiopy.dacq2py.axonaIO.IO.getHeader">getHeader</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.getHeaderVal" href="#ephysiopy.dacq2py.axonaIO.IO.getHeaderVal">getHeaderVal</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.setData" href="#ephysiopy.dacq2py.axonaIO.IO.setData">setData</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.setHeader" href="#ephysiopy.dacq2py.axonaIO.IO.setHeader">setHeader</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ephysiopy.dacq2py.axonaIO.Stim"><code class="flex name class">
<span>class <span class="ident">Stim</span></span>
<span>(</span><span>filename_root, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Stim(dict, IO):
        def __init__(self, filename_root, *args, **kwargs):
                self.update(*args, **kwargs)
                self.filename_root = filename_root
                stmData = self.getData(filename_root + &#39;.stm&#39;)
                self.__setitem__(&#39;on&#39;, stmData[&#39;ts&#39;])
                stmHdr = self.getHeader(filename_root + &#39;.stm&#39;)
                for k,v in stmHdr.items():
                        self.__setitem__(k, v)
                tb = int(self[&#39;timebase&#39;].split(&#39; &#39;)[0])
                self.timebase = tb

        def update(self, *args, **kwargs):
                for k, v in dict(*args, **kwargs).iteritems():
                        self[k] = v

        def __getitem__(self, key):
                try:
                        val = dict.__getitem__(self, key)
                        return val
                except KeyError:
                        print(&#39;KeyError&#39;)

        def __setitem__(self, key, val):
                dict.__setitem__(self, key, val)

        def getTS(self):
                return self[&#39;on&#39;] / int(self.timebase / 1000)# in ms

        def getPosIdx(self):
                &#39;&#39;&#39;
                these get* methods will only work once the Stim object has been
                instantiated from within the dacq2py_util.Trial class - see its _STM
                property there for details about what this update entails
                &#39;&#39;&#39;
                scale = self.timebase / float(self[&#39;posSampRate&#39;])
                return self[&#39;on&#39;] / scale

        def getEEGIdx(self):
                scale = self.timebase / float(self[&#39;eegSampRate&#39;])
                return (self[&#39;on&#39;] / scale).astype(int)

        def getEGFIdx(self):
                scale = self.timebase / float(self[&#39;egfSampRate&#39;])
                return (self[&#39;on&#39;] / scale).astype(int)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
<li><a title="ephysiopy.dacq2py.axonaIO.IO" href="#ephysiopy.dacq2py.axonaIO.IO">IO</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ephysiopy.dacq2py.axonaIO.Stim.getEEGIdx"><code class="name flex">
<span>def <span class="ident">getEEGIdx</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getEEGIdx(self):
        scale = self.timebase / float(self[&#39;eegSampRate&#39;])
        return (self[&#39;on&#39;] / scale).astype(int)</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.axonaIO.Stim.getEGFIdx"><code class="name flex">
<span>def <span class="ident">getEGFIdx</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getEGFIdx(self):
        scale = self.timebase / float(self[&#39;egfSampRate&#39;])
        return (self[&#39;on&#39;] / scale).astype(int)</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.axonaIO.Stim.getPosIdx"><code class="name flex">
<span>def <span class="ident">getPosIdx</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>these get* methods will only work once the Stim object has been
instantiated from within the dacq2py_util.Trial class - see its _STM
property there for details about what this update entails</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPosIdx(self):
        &#39;&#39;&#39;
        these get* methods will only work once the Stim object has been
        instantiated from within the dacq2py_util.Trial class - see its _STM
        property there for details about what this update entails
        &#39;&#39;&#39;
        scale = self.timebase / float(self[&#39;posSampRate&#39;])
        return self[&#39;on&#39;] / scale</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.axonaIO.Stim.getTS"><code class="name flex">
<span>def <span class="ident">getTS</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getTS(self):
        return self[&#39;on&#39;] / int(self.timebase / 1000)# in ms</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.axonaIO.Stim.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>D.update([E, ]**F) -&gt; None.
Update D from dict/iterable E and F.
If E is present and has a .keys() method, then does:
for k in E: D[k] = E[k]
If E is present and lacks a .keys() method, then does:
for k, v in E: D[k] = v
In either case, this is followed by: for k in F:
D[k] = F[k]</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, *args, **kwargs):
        for k, v in dict(*args, **kwargs).iteritems():
                self[k] = v</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ephysiopy.dacq2py.axonaIO.IO" href="#ephysiopy.dacq2py.axonaIO.IO">IO</a></b></code>:
<ul class="hlist">
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.getCluCut" href="#ephysiopy.dacq2py.axonaIO.IO.getCluCut">getCluCut</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.getCut" href="#ephysiopy.dacq2py.axonaIO.IO.getCut">getCut</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.getData" href="#ephysiopy.dacq2py.axonaIO.IO.getData">getData</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.getHeader" href="#ephysiopy.dacq2py.axonaIO.IO.getHeader">getHeader</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.getHeaderVal" href="#ephysiopy.dacq2py.axonaIO.IO.getHeaderVal">getHeaderVal</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.setData" href="#ephysiopy.dacq2py.axonaIO.IO.setData">setData</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.setHeader" href="#ephysiopy.dacq2py.axonaIO.IO.setHeader">setHeader</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ephysiopy.dacq2py.axonaIO.Tetrode"><code class="flex name class">
<span>class <span class="ident">Tetrode</span></span>
<span>(</span><span>filename_root, tetrode, volts=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Class for reading data from Axona data acquisition system. Also
reads .clu files generated from KlustaKwik</p>
<p>Class attributes:
axona_files (dict): keys are axona format file suffixes
and the values are used as numpy dtypes to read the data.
NB it's assumed a .set file is <em>always</em> present</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tetrode(IO, SpikeCalcs):
        def __init__(self, filename_root, tetrode, volts=True):
                self.filename_root = filename_root
                self.tetrode = tetrode
                self.volts = volts
                self.header = self.getHeader(self.filename_root + &#39;.&#39; + str(tetrode))
                data = self.getData(filename_root + &#39;.&#39; + str(tetrode))
                self.spk_ts = data[&#39;ts&#39;][::4]
                self.nChans = self.getHeaderVal(self.header, &#39;num_chans&#39;)
                self.samples = self.getHeaderVal(self.header, &#39;samples_per_spike&#39;)
                self.nSpikes = self.getHeaderVal(self.header, &#39;num_spikes&#39;)
                self.posSampleRate = self.getHeaderVal(self.getHeader(self.filename_root + &#39;.&#39; + &#39;pos&#39;), &#39;sample_rate&#39;)
                self.waveforms = data[&#39;waveform&#39;].reshape(self.nSpikes, self.nChans, self.samples)
                del data
                if volts:
                        set_header = self.getHeader(self.filename_root + &#39;.set&#39;)
                        gains = np.zeros(4)
                        st = (tetrode - 1) * 4
                        for i, g in enumerate(np.arange(st, st+4)):
                                gains[i] = int(set_header[&#39;gain_ch_&#39; + str(g)])
                        ADC_mv = int(set_header[&#39;ADC_fullscale_mv&#39;])
                        scaling = (ADC_mv/1000.) / gains
                        self.scaling = scaling
                        self.gains = gains
                        self.waveforms = (self.waveforms / 128.) * scaling[:,np.newaxis]# waveforms now in volts
                self.timebase = self.getHeaderVal(self.header, &#39;timebase&#39;)
                try:
                        cut = np.array(self.getCut(self.tetrode), dtype=int)
                        self.cut = cut
                        self.clusters = np.unique(self.cut)
                except IOError:
                        try:
                                cut = self.getCluCut(self.tetrode)
                                cut = np.array(cut) - 1
                                self.cut = cut
                                self.clusters = np.unique(self.cut)
                        except IOError:
                                self.cut = None
                self.pos_samples = None

        def getSpkTS(self):
                &#39;&#39;&#39;
                Returns the list of timestamps a series of spike events occured on a tetrode
                &#39;&#39;&#39;
                return np.ma.compressed(self.spk_ts)

        def getClustTS(self, cluster=None):
                &#39;&#39;&#39;
                Returns the timestamps for a cluster on a tetrode
                &#39;&#39;&#39;
                # Return all of the timestamps if no cluster given
                if cluster is None:
                        clustTS = self.getSpkTS()
                else:
                        if self.cut is None:
                                try:
                                        cut = np.array(self.getCut(self.tetrode),dtype=int)
                                except IOError:
                                        cut = self.getCluCut(self.tetrode)
                                        cut = np.array(cut) - 1
                                self.cut = cut
                        self.getSpkTS()
                        clustTS = np.ma.compressed(self.spk_ts[self.cut==cluster])
                return clustTS

        def getPosSamples(self):
                &#39;&#39;&#39;
                Returns the pos samples at which the spikes were captured
                &#39;&#39;&#39;
                self.pos_samples = np.floor(self.getSpkTS() / float(self.timebase) * self.posSampleRate).astype(int)
                return np.ma.compressed(self.pos_samples)

        def getClustSpks(self, cluster):
                &#39;&#39;&#39;
                Returns the waveforms of the asked for cluster
                &#39;&#39;&#39;
                if self.cut is None:
                        self.getClustTS(cluster)
                return self.waveforms[self.cut==cluster, :, :]#taking the mean of this along axis=0 gives mean waveform on each channel for a cluster

        def getClustIdx(self, cluster):
                &#39;&#39;&#39;
                Returns the pos samples corresponding to the cluster
                &#39;&#39;&#39;
                if self.cut is None:
                        try:
                                cut = np.array(self.getCut(self.tetrode), dtype=int)
                        except IOError:
                                cut = self.getCluCut(self.tetrode)
                                cut = np.array(cut) - 1
                        self.cut = cut
                if self.pos_samples is None:
                        self.getPosSamples()
                return self.pos_samples[self.cut == cluster].astype(int)

        def getUniqueClusters(self):
                &#39;&#39;&#39;
                Returns an array of the unique clusters in the cut file associated
                with the tetrode
                &#39;&#39;&#39;
                if self.cut is None:
                        try:
                                cut = np.array(self.getCut(self.tetrode), dtype=int)
                        except IOError:
                                cut = self.getCluCut(self.tetrode)
                                cut = np.array(cut) - 1
                        self.cut = cut
                else:
                        cut = self.cut
                return np.unique(cut)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ephysiopy.dacq2py.axonaIO.IO" href="#ephysiopy.dacq2py.axonaIO.IO">IO</a></li>
<li><a title="ephysiopy.dacq2py.spikecalcs.SpikeCalcs" href="spikecalcs.html#ephysiopy.dacq2py.spikecalcs.SpikeCalcs">SpikeCalcs</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ephysiopy.dacq2py.axonaIO.Tetrode.getClustIdx"><code class="name flex">
<span>def <span class="ident">getClustIdx</span></span>(<span>self, cluster)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the pos samples corresponding to the cluster</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getClustIdx(self, cluster):
        &#39;&#39;&#39;
        Returns the pos samples corresponding to the cluster
        &#39;&#39;&#39;
        if self.cut is None:
                try:
                        cut = np.array(self.getCut(self.tetrode), dtype=int)
                except IOError:
                        cut = self.getCluCut(self.tetrode)
                        cut = np.array(cut) - 1
                self.cut = cut
        if self.pos_samples is None:
                self.getPosSamples()
        return self.pos_samples[self.cut == cluster].astype(int)</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.axonaIO.Tetrode.getClustSpks"><code class="name flex">
<span>def <span class="ident">getClustSpks</span></span>(<span>self, cluster)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the waveforms of the asked for cluster</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getClustSpks(self, cluster):
        &#39;&#39;&#39;
        Returns the waveforms of the asked for cluster
        &#39;&#39;&#39;
        if self.cut is None:
                self.getClustTS(cluster)
        return self.waveforms[self.cut==cluster, :, :]#taking the mean of this along axis=0 gives mean waveform on each channel for a cluster</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.axonaIO.Tetrode.getClustTS"><code class="name flex">
<span>def <span class="ident">getClustTS</span></span>(<span>self, cluster=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the timestamps for a cluster on a tetrode</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getClustTS(self, cluster=None):
        &#39;&#39;&#39;
        Returns the timestamps for a cluster on a tetrode
        &#39;&#39;&#39;
        # Return all of the timestamps if no cluster given
        if cluster is None:
                clustTS = self.getSpkTS()
        else:
                if self.cut is None:
                        try:
                                cut = np.array(self.getCut(self.tetrode),dtype=int)
                        except IOError:
                                cut = self.getCluCut(self.tetrode)
                                cut = np.array(cut) - 1
                        self.cut = cut
                self.getSpkTS()
                clustTS = np.ma.compressed(self.spk_ts[self.cut==cluster])
        return clustTS</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.axonaIO.Tetrode.getPosSamples"><code class="name flex">
<span>def <span class="ident">getPosSamples</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the pos samples at which the spikes were captured</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPosSamples(self):
        &#39;&#39;&#39;
        Returns the pos samples at which the spikes were captured
        &#39;&#39;&#39;
        self.pos_samples = np.floor(self.getSpkTS() / float(self.timebase) * self.posSampleRate).astype(int)
        return np.ma.compressed(self.pos_samples)</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.axonaIO.Tetrode.getSpkTS"><code class="name flex">
<span>def <span class="ident">getSpkTS</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the list of timestamps a series of spike events occured on a tetrode</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getSpkTS(self):
        &#39;&#39;&#39;
        Returns the list of timestamps a series of spike events occured on a tetrode
        &#39;&#39;&#39;
        return np.ma.compressed(self.spk_ts)</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.axonaIO.Tetrode.getUniqueClusters"><code class="name flex">
<span>def <span class="ident">getUniqueClusters</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns an array of the unique clusters in the cut file associated
with the tetrode</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getUniqueClusters(self):
        &#39;&#39;&#39;
        Returns an array of the unique clusters in the cut file associated
        with the tetrode
        &#39;&#39;&#39;
        if self.cut is None:
                try:
                        cut = np.array(self.getCut(self.tetrode), dtype=int)
                except IOError:
                        cut = self.getCluCut(self.tetrode)
                        cut = np.array(cut) - 1
                self.cut = cut
        else:
                cut = self.cut
        return np.unique(cut)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ephysiopy.dacq2py.axonaIO.IO" href="#ephysiopy.dacq2py.axonaIO.IO">IO</a></b></code>:
<ul class="hlist">
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.getCluCut" href="#ephysiopy.dacq2py.axonaIO.IO.getCluCut">getCluCut</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.getCut" href="#ephysiopy.dacq2py.axonaIO.IO.getCut">getCut</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.getData" href="#ephysiopy.dacq2py.axonaIO.IO.getData">getData</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.getHeader" href="#ephysiopy.dacq2py.axonaIO.IO.getHeader">getHeader</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.getHeaderVal" href="#ephysiopy.dacq2py.axonaIO.IO.getHeaderVal">getHeaderVal</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.setData" href="#ephysiopy.dacq2py.axonaIO.IO.setData">setData</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.setHeader" href="#ephysiopy.dacq2py.axonaIO.IO.setHeader">setHeader</a></code></li>
</ul>
</li>
<li><code><b><a title="ephysiopy.dacq2py.spikecalcs.SpikeCalcs" href="spikecalcs.html#ephysiopy.dacq2py.spikecalcs.SpikeCalcs">SpikeCalcs</a></b></code>:
<ul class="hlist">
<li><code><a title="ephysiopy.dacq2py.spikecalcs.SpikeCalcs.clusterQuality" href="spikecalcs.html#ephysiopy.dacq2py.spikecalcs.SpikeCalcs.clusterQuality">clusterQuality</a></code></li>
<li><code><a title="ephysiopy.dacq2py.spikecalcs.SpikeCalcs.getMeanWaveform" href="spikecalcs.html#ephysiopy.dacq2py.spikecalcs.SpikeCalcs.getMeanWaveform">getMeanWaveform</a></code></li>
<li><code><a title="ephysiopy.dacq2py.spikecalcs.SpikeCalcs.getParam" href="spikecalcs.html#ephysiopy.dacq2py.spikecalcs.SpikeCalcs.getParam">getParam</a></code></li>
<li><code><a title="ephysiopy.dacq2py.spikecalcs.SpikeCalcs.half_amp_dur" href="spikecalcs.html#ephysiopy.dacq2py.spikecalcs.SpikeCalcs.half_amp_dur">half_amp_dur</a></code></li>
<li><code><a title="ephysiopy.dacq2py.spikecalcs.SpikeCalcs.ifr_sp_corr" href="spikecalcs.html#ephysiopy.dacq2py.spikecalcs.SpikeCalcs.ifr_sp_corr">ifr_sp_corr</a></code></li>
<li><code><a title="ephysiopy.dacq2py.spikecalcs.SpikeCalcs.mean_autoCorr" href="spikecalcs.html#ephysiopy.dacq2py.spikecalcs.SpikeCalcs.mean_autoCorr">mean_autoCorr</a></code></li>
<li><code><a title="ephysiopy.dacq2py.spikecalcs.SpikeCalcs.p2t_time" href="spikecalcs.html#ephysiopy.dacq2py.spikecalcs.SpikeCalcs.p2t_time">p2t_time</a></code></li>
<li><code><a title="ephysiopy.dacq2py.spikecalcs.SpikeCalcs.plotClusterSpace" href="spikecalcs.html#ephysiopy.dacq2py.spikecalcs.SpikeCalcs.plotClusterSpace">plotClusterSpace</a></code></li>
<li><code><a title="ephysiopy.dacq2py.spikecalcs.SpikeCalcs.smoothSpikePosCount" href="spikecalcs.html#ephysiopy.dacq2py.spikecalcs.SpikeCalcs.smoothSpikePosCount">smoothSpikePosCount</a></code></li>
<li><code><a title="ephysiopy.dacq2py.spikecalcs.SpikeCalcs.thetaBandMaxFreq" href="spikecalcs.html#ephysiopy.dacq2py.spikecalcs.SpikeCalcs.thetaBandMaxFreq">thetaBandMaxFreq</a></code></li>
<li><code><a title="ephysiopy.dacq2py.spikecalcs.SpikeCalcs.thetaModIdx" href="spikecalcs.html#ephysiopy.dacq2py.spikecalcs.SpikeCalcs.thetaModIdx">thetaModIdx</a></code></li>
<li><code><a title="ephysiopy.dacq2py.spikecalcs.SpikeCalcs.thetaModIdxV2" href="spikecalcs.html#ephysiopy.dacq2py.spikecalcs.SpikeCalcs.thetaModIdxV2">thetaModIdxV2</a></code></li>
<li><code><a title="ephysiopy.dacq2py.spikecalcs.SpikeCalcs.trial_av_firing_rate" href="spikecalcs.html#ephysiopy.dacq2py.spikecalcs.SpikeCalcs.trial_av_firing_rate">trial_av_firing_rate</a></code></li>
<li><code><a title="ephysiopy.dacq2py.spikecalcs.SpikeCalcs.xcorr" href="spikecalcs.html#ephysiopy.dacq2py.spikecalcs.SpikeCalcs.xcorr">xcorr</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ephysiopy.dacq2py" href="index.html">ephysiopy.dacq2py</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ephysiopy.dacq2py.axonaIO.EEG" href="#ephysiopy.dacq2py.axonaIO.EEG">EEG</a></code></h4>
<ul class="">
<li><code><a title="ephysiopy.dacq2py.axonaIO.EEG.eegfilter" href="#ephysiopy.dacq2py.axonaIO.EEG.eegfilter">eegfilter</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.EEG.nextpow2" href="#ephysiopy.dacq2py.axonaIO.EEG.nextpow2">nextpow2</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.EEG.thetaAmpPhase" href="#ephysiopy.dacq2py.axonaIO.EEG.thetaAmpPhase">thetaAmpPhase</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ephysiopy.dacq2py.axonaIO.IO" href="#ephysiopy.dacq2py.axonaIO.IO">IO</a></code></h4>
<ul class="two-column">
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.axona_files" href="#ephysiopy.dacq2py.axonaIO.IO.axona_files">axona_files</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.getCluCut" href="#ephysiopy.dacq2py.axonaIO.IO.getCluCut">getCluCut</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.getCut" href="#ephysiopy.dacq2py.axonaIO.IO.getCut">getCut</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.getData" href="#ephysiopy.dacq2py.axonaIO.IO.getData">getData</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.getEmptyHeader" href="#ephysiopy.dacq2py.axonaIO.IO.getEmptyHeader">getEmptyHeader</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.getHeader" href="#ephysiopy.dacq2py.axonaIO.IO.getHeader">getHeader</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.getHeaderVal" href="#ephysiopy.dacq2py.axonaIO.IO.getHeaderVal">getHeaderVal</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.other_files" href="#ephysiopy.dacq2py.axonaIO.IO.other_files">other_files</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.setData" href="#ephysiopy.dacq2py.axonaIO.IO.setData">setData</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.setHeader" href="#ephysiopy.dacq2py.axonaIO.IO.setHeader">setHeader</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.IO.tetrode_files" href="#ephysiopy.dacq2py.axonaIO.IO.tetrode_files">tetrode_files</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ephysiopy.dacq2py.axonaIO.Pos" href="#ephysiopy.dacq2py.axonaIO.Pos">Pos</a></code></h4>
<ul class="two-column">
<li><code><a title="ephysiopy.dacq2py.axonaIO.Pos.filterPos" href="#ephysiopy.dacq2py.axonaIO.Pos.filterPos">filterPos</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.Pos.interpNans" href="#ephysiopy.dacq2py.axonaIO.Pos.interpNans">interpNans</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.Pos.ledspeedFilter" href="#ephysiopy.dacq2py.axonaIO.Pos.ledspeedFilter">ledspeedFilter</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.Pos.ledswapFilter" href="#ephysiopy.dacq2py.axonaIO.Pos.ledswapFilter">ledswapFilter</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.Pos.postprocesspos" href="#ephysiopy.dacq2py.axonaIO.Pos.postprocesspos">postprocesspos</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.Pos.ppm" href="#ephysiopy.dacq2py.axonaIO.Pos.ppm">ppm</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ephysiopy.dacq2py.axonaIO.Stim" href="#ephysiopy.dacq2py.axonaIO.Stim">Stim</a></code></h4>
<ul class="">
<li><code><a title="ephysiopy.dacq2py.axonaIO.Stim.getEEGIdx" href="#ephysiopy.dacq2py.axonaIO.Stim.getEEGIdx">getEEGIdx</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.Stim.getEGFIdx" href="#ephysiopy.dacq2py.axonaIO.Stim.getEGFIdx">getEGFIdx</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.Stim.getPosIdx" href="#ephysiopy.dacq2py.axonaIO.Stim.getPosIdx">getPosIdx</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.Stim.getTS" href="#ephysiopy.dacq2py.axonaIO.Stim.getTS">getTS</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.Stim.update" href="#ephysiopy.dacq2py.axonaIO.Stim.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ephysiopy.dacq2py.axonaIO.Tetrode" href="#ephysiopy.dacq2py.axonaIO.Tetrode">Tetrode</a></code></h4>
<ul class="two-column">
<li><code><a title="ephysiopy.dacq2py.axonaIO.Tetrode.getClustIdx" href="#ephysiopy.dacq2py.axonaIO.Tetrode.getClustIdx">getClustIdx</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.Tetrode.getClustSpks" href="#ephysiopy.dacq2py.axonaIO.Tetrode.getClustSpks">getClustSpks</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.Tetrode.getClustTS" href="#ephysiopy.dacq2py.axonaIO.Tetrode.getClustTS">getClustTS</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.Tetrode.getPosSamples" href="#ephysiopy.dacq2py.axonaIO.Tetrode.getPosSamples">getPosSamples</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.Tetrode.getSpkTS" href="#ephysiopy.dacq2py.axonaIO.Tetrode.getSpkTS">getSpkTS</a></code></li>
<li><code><a title="ephysiopy.dacq2py.axonaIO.Tetrode.getUniqueClusters" href="#ephysiopy.dacq2py.axonaIO.Tetrode.getUniqueClusters">getUniqueClusters</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>