<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>ephysiopy.dacq2py.utils API documentation</title>
<meta name="description" content="Created on Thu Sep 20 17:00:57 2012 â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ephysiopy.dacq2py.utils</code></h1>
</header>
<section id="section-intro">
<p>Created on Thu Sep 20 17:00:57 2012</p>
<p>@author: robin</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Thu Sep 20 17:00:57 2012

@author: robin
&#34;&#34;&#34;
import numpy as np
import scipy.interpolate
import scipy.ndimage
import math
from scipy.signal import boxcar
from scipy.signal import convolve


def smooth(x, window_len=9, window=&#39;hanning&#39;):
    &#34;&#34;&#34;
        Smooth the data using a window with requested size.
    
    This method is based on the convolution of a scaled window with the signal.
    The signal is prepared by introducing reflected copies of the signal 
    (with the window size) in both ends so that transient parts are minimized
    in the begining and end part of the output signal.
    
    Parameters
        ----------
        x : array_like
                the input signal 
        window_len : int
                The length of the smoothing window
        window : str
                The type of window from &#39;flat&#39;, &#39;hanning&#39;, &#39;hamming&#39;, &#39;bartlett&#39;, &#39;blackman&#39;
                &#39;flat&#39; window will produce a moving average smoothing.

    Returns
        -------
    out : The smoothed signal
        
    Example
        -------

    &gt;&gt;&gt; t=linspace(-2,2,0.1)
    &gt;&gt;&gt; x=sin(t)+randn(len(t))*0.1
    &gt;&gt;&gt; y=smooth(x)
    
    See Also
        --------
    
    numpy.hanning, numpy.hamming, numpy.bartlett, numpy.blackman, numpy.convolve
    scipy.signal.lfilter
 
    TODO: the window parameter could be the window itself if an array instead of a string   
    &#34;&#34;&#34;

    if type(x) == type([]):
        x = np.array(x)

    if x.ndim != 1:
        raise ValueError(&#34;smooth only accepts 1 dimension arrays.&#34;)

    if x.size &lt; window_len:
        raise ValueError(&#34;Input vector needs to be bigger than window size.&#34;)
    if window_len &lt; 3:
        return x

    if (window_len % 2) == 0:
        window_len = window_len + 1

    if not window in [&#39;flat&#39;, &#39;hanning&#39;, &#39;hamming&#39;, &#39;bartlett&#39;, &#39;blackman&#39;]:
        raise ValueError(
            &#34;Window is on of &#39;flat&#39;, &#39;hanning&#39;, &#39;hamming&#39;, &#39;bartlett&#39;, &#39;blackman&#39;&#34;)

    s = np.r_[2*x[0]-x[window_len:1:-1], x, 2*x[-1]-x[-1:-window_len:-1]]

    if window == &#39;flat&#39;:  # moving average
        w = np.ones(window_len, &#39;d&#39;)
    else:
        w = eval(&#39;np.&#39;+window+&#39;(window_len)&#39;)
    from astropy.convolution import convolve
    y = convolve(x, w/w.sum(), normalize_kernel=False, boundary=&#39;extend&#39;)
    # return the smoothed signal
    return y

def blur_image(im, n, ny=None, ftype=&#39;boxcar&#39;):
        &#34;&#34;&#34; blurs the image by convolving with a filter (&#39;gaussian&#39; or
                &#39;boxcar&#39;) of
                size n. The optional keyword argument ny allows for a different
                size in the y direction.
        &#34;&#34;&#34;
        n = int(n)
        if not ny:
                ny = n
        else:
                ny = int(ny)
        #  keep track of nans
        nan_idx = np.isnan(im)
        im[nan_idx] = 0
        if ftype == &#39;boxcar&#39;:
                if np.ndim(im) == 1:
                        g = boxcar(n) / float(n)
                elif np.ndim(im) == 2:
                        g = boxcar([n, ny]) / float(n)
        elif ftype == &#39;gaussian&#39;:
                x, y = np.mgrid[-n:n+1, -ny:ny+1]
                g = np.exp(-(x**2/float(n) + y**2/float(ny)))
                if np.ndim(im) == 1:
                        g = g[n, :]
                g = g / g.sum()
        improc = convolve(im, g, mode=&#39;same&#39;)
        improc[nan_idx] = np.nan
        return improc 

def count_to(self, n):
        &#34;&#34;&#34;By example:

                #    0  1  2  3  4  5  6  7  8
                n = [0, 0, 3, 0, 0, 2, 0, 2, 1]
                res = [0, 1, 2, 0, 1, 0, 1, 0]

        That is it is equivalent to something like this :

                hstack((arange(n_i) for n_i in n))

        This version seems quite a bit faster, at least for some
        possible inputs, and at any rate it encapsulates a task
        in a function.
        &#34;&#34;&#34;
        if n.ndim != 1:
                raise Exception(&#34;n is supposed to be 1d array.&#34;)

        n_mask = n.astype(bool)
        n_cumsum = np.cumsum(n)
        ret = np.ones(n_cumsum[-1]+1,dtype=int)
        ret[n_cumsum[n_mask]] -= n[n_mask]
        ret[0] -= 1
        return np.cumsum(ret)[:-1]

def repeat_ind(self, n):
        &#34;&#34;&#34;By example:

                #    0  1  2  3  4  5  6  7  8
                n = [0, 0, 3, 0, 0, 2, 0, 2, 1]
                res = [2, 2, 2, 5, 5, 7, 7, 8]

        That is the input specifies how many times to repeat the given index.

        It is equivalent to something like this :

                hstack((zeros(n_i,dtype=int)+i for i, n_i in enumerate(n)))

        But this version seems to be faster, and probably scales better, at
        any rate it encapsulates a task in a function.
        &#34;&#34;&#34;
        if n.ndim != 1:
                raise Exception(&#34;n is supposed to be 1d array.&#34;)

        n_mask = n.astype(bool)
        n_inds = np.nonzero(n_mask)[0]
        n_inds[1:] = n_inds[1:]-n_inds[:-1] # take diff and leave 0th value in place
        n_cumsum = np.empty(len(n)+1,dtype=int)
        n_cumsum[0] = 0
        n_cumsum[1:] = np.cumsum(n)
        ret = np.zeros(n_cumsum[-1],dtype=int)
        ret[n_cumsum[n_mask]] = n_inds # note that n_mask is 1 element shorter than n_cumsum
        return np.cumsum(ret)

def rect(r, w, deg=0):
        &#34;&#34;&#34;
        Convert from polar (r,w) to rectangular (x,y)
        x = r cos(w)
        y = r sin(w)
        &#34;&#34;&#34;
        # radian if deg=0; degree if deg=1 
        if deg: w = np.pi * w / 180.0 
        return r * np.cos(w), r * np.sin(w)
        
def polar(x, y, deg=0): 
        &#34;&#34;&#34;
        Converts from rectangular coordinates to polar ones

        Parameters
        ----------
        x, y : array_like, list_like
                The x and y coordinates
        deg : int
                radian if deg=0; degree if deg=1

        Returns
        -------
        p : array_like
                The polar version of x and y    
        &#34;&#34;&#34;
        if deg:
                return np.hypot(x, y), 180.0 * np.arctan2(y, x) / np.pi
        else:
                return np.hypot(x, y), np.arctan2(y, x)

def spiral(self, X, Y):
        &#39;&#39;&#39;
        Given an array of shape X x Y this returns the coordinates needed to step
        out from the centre of the array to the edge in a spiral fashion:
                see http://stackoverflow.com/questions/398299/looping-in-a-spiral?rq=1
                for original code and question/ solution(s)
        &#39;&#39;&#39;
        x = 0
        y = 0
        dx = 0
        dy = -1
        x_out = []
        y_out = []
        for i in range(max(X, Y)**2):
                x_out.append(x)
                y_out.append(y)
                if x == y or (x &lt; 0 and x == -y) or (x &gt; 0 and x == 1-y):
                        dx, dy = -dy, dx
                x, y = x+dx, y+dy
                
        return np.array(x_out), np.array(y_out)
        
class bcolors:
        HEADER = &#39;\033[95m&#39;
        OKBLUE = &#39;\033[94m&#39;
        OKGREEN = &#39;\033[92m&#39;
        WARNING = &#39;\033[93m&#39;
        FAIL = &#39;\033[91m&#39;
        ENDC = &#39;\033[0m&#39;

        def disable(self):
                self.HEADER = &#39;&#39;
                self.OKBLUE = &#39;&#39;
                self.OKGREEN = &#39;&#39;
                self.WARNING = &#39;&#39;
                self.FAIL = &#39;&#39;
                self.ENDC = &#39;&#39;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ephysiopy.dacq2py.utils.blur_image"><code class="name flex">
<span>def <span class="ident">blur_image</span></span>(<span>im, n, ny=None, ftype='boxcar')</span>
</code></dt>
<dd>
<section class="desc"><p>blurs the image by convolving with a filter ('gaussian' or
'boxcar') of
size n. The optional keyword argument ny allows for a different
size in the y direction.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def blur_image(im, n, ny=None, ftype=&#39;boxcar&#39;):
        &#34;&#34;&#34; blurs the image by convolving with a filter (&#39;gaussian&#39; or
                &#39;boxcar&#39;) of
                size n. The optional keyword argument ny allows for a different
                size in the y direction.
        &#34;&#34;&#34;
        n = int(n)
        if not ny:
                ny = n
        else:
                ny = int(ny)
        #  keep track of nans
        nan_idx = np.isnan(im)
        im[nan_idx] = 0
        if ftype == &#39;boxcar&#39;:
                if np.ndim(im) == 1:
                        g = boxcar(n) / float(n)
                elif np.ndim(im) == 2:
                        g = boxcar([n, ny]) / float(n)
        elif ftype == &#39;gaussian&#39;:
                x, y = np.mgrid[-n:n+1, -ny:ny+1]
                g = np.exp(-(x**2/float(n) + y**2/float(ny)))
                if np.ndim(im) == 1:
                        g = g[n, :]
                g = g / g.sum()
        improc = convolve(im, g, mode=&#39;same&#39;)
        improc[nan_idx] = np.nan
        return improc </code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.utils.count_to"><code class="name flex">
<span>def <span class="ident">count_to</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<section class="desc"><p>By example:</p>
<pre><code>    #    0  1  2  3  4  5  6  7  8
    n = [0, 0, 3, 0, 0, 2, 0, 2, 1]
    res = [0, 1, 2, 0, 1, 0, 1, 0]
</code></pre>
<p>That is it is equivalent to something like this :</p>
<pre><code>    hstack((arange(n_i) for n_i in n))
</code></pre>
<p>This version seems quite a bit faster, at least for some
possible inputs, and at any rate it encapsulates a task
in a function.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count_to(self, n):
        &#34;&#34;&#34;By example:

                #    0  1  2  3  4  5  6  7  8
                n = [0, 0, 3, 0, 0, 2, 0, 2, 1]
                res = [0, 1, 2, 0, 1, 0, 1, 0]

        That is it is equivalent to something like this :

                hstack((arange(n_i) for n_i in n))

        This version seems quite a bit faster, at least for some
        possible inputs, and at any rate it encapsulates a task
        in a function.
        &#34;&#34;&#34;
        if n.ndim != 1:
                raise Exception(&#34;n is supposed to be 1d array.&#34;)

        n_mask = n.astype(bool)
        n_cumsum = np.cumsum(n)
        ret = np.ones(n_cumsum[-1]+1,dtype=int)
        ret[n_cumsum[n_mask]] -= n[n_mask]
        ret[0] -= 1
        return np.cumsum(ret)[:-1]</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.utils.polar"><code class="name flex">
<span>def <span class="ident">polar</span></span>(<span>x, y, deg=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts from rectangular coordinates to polar ones</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong>, <strong><code>y</code></strong> :&ensp;<code>array_like</code>, <code>list_like</code></dt>
<dd>The x and y coordinates</dd>
<dt><strong><code>deg</code></strong> :&ensp;<code>int</code></dt>
<dd>radian if deg=0; degree if deg=1</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>p</code></strong> :&ensp;<code>array_like</code></dt>
<dd>The polar version of x and y</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def polar(x, y, deg=0): 
        &#34;&#34;&#34;
        Converts from rectangular coordinates to polar ones

        Parameters
        ----------
        x, y : array_like, list_like
                The x and y coordinates
        deg : int
                radian if deg=0; degree if deg=1

        Returns
        -------
        p : array_like
                The polar version of x and y    
        &#34;&#34;&#34;
        if deg:
                return np.hypot(x, y), 180.0 * np.arctan2(y, x) / np.pi
        else:
                return np.hypot(x, y), np.arctan2(y, x)</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.utils.rect"><code class="name flex">
<span>def <span class="ident">rect</span></span>(<span>r, w, deg=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Convert from polar (r,w) to rectangular (x,y)
x = r cos(w)
y = r sin(w)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rect(r, w, deg=0):
        &#34;&#34;&#34;
        Convert from polar (r,w) to rectangular (x,y)
        x = r cos(w)
        y = r sin(w)
        &#34;&#34;&#34;
        # radian if deg=0; degree if deg=1 
        if deg: w = np.pi * w / 180.0 
        return r * np.cos(w), r * np.sin(w)</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.utils.repeat_ind"><code class="name flex">
<span>def <span class="ident">repeat_ind</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<section class="desc"><p>By example:</p>
<pre><code>    #    0  1  2  3  4  5  6  7  8
    n = [0, 0, 3, 0, 0, 2, 0, 2, 1]
    res = [2, 2, 2, 5, 5, 7, 7, 8]
</code></pre>
<p>That is the input specifies how many times to repeat the given index.</p>
<p>It is equivalent to something like this :</p>
<pre><code>    hstack((zeros(n_i,dtype=int)+i for i, n_i in enumerate(n)))
</code></pre>
<p>But this version seems to be faster, and probably scales better, at
any rate it encapsulates a task in a function.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def repeat_ind(self, n):
        &#34;&#34;&#34;By example:

                #    0  1  2  3  4  5  6  7  8
                n = [0, 0, 3, 0, 0, 2, 0, 2, 1]
                res = [2, 2, 2, 5, 5, 7, 7, 8]

        That is the input specifies how many times to repeat the given index.

        It is equivalent to something like this :

                hstack((zeros(n_i,dtype=int)+i for i, n_i in enumerate(n)))

        But this version seems to be faster, and probably scales better, at
        any rate it encapsulates a task in a function.
        &#34;&#34;&#34;
        if n.ndim != 1:
                raise Exception(&#34;n is supposed to be 1d array.&#34;)

        n_mask = n.astype(bool)
        n_inds = np.nonzero(n_mask)[0]
        n_inds[1:] = n_inds[1:]-n_inds[:-1] # take diff and leave 0th value in place
        n_cumsum = np.empty(len(n)+1,dtype=int)
        n_cumsum[0] = 0
        n_cumsum[1:] = np.cumsum(n)
        ret = np.zeros(n_cumsum[-1],dtype=int)
        ret[n_cumsum[n_mask]] = n_inds # note that n_mask is 1 element shorter than n_cumsum
        return np.cumsum(ret)</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.utils.smooth"><code class="name flex">
<span>def <span class="ident">smooth</span></span>(<span>x, window_len=9, window='hanning')</span>
</code></dt>
<dd>
<section class="desc"><p>Smooth the data using a window with requested size.</p>
<p>This method is based on the convolution of a scaled window with the signal.
The signal is prepared by introducing reflected copies of the signal
(with the window size) in both ends so that transient parts are minimized
in the begining and end part of the output signal.</p>
<p>Parameters
----------
x : array_like
the input signal
window_len : int
The length of the smoothing window
window : str
The type of window from 'flat', 'hanning', 'hamming', 'bartlett', 'blackman'
'flat' window will produce a moving average smoothing.</p>
<p>Returns
-------
out : The smoothed signal</p>
<p>Example
-------</p>
<pre><code>&gt;&gt;&gt; t=linspace(-2,2,0.1)
&gt;&gt;&gt; x=sin(t)+randn(len(t))*0.1
&gt;&gt;&gt; y=smooth(x)
</code></pre>
<p>See Also
--------</p>
<p>numpy.hanning, numpy.hamming, numpy.bartlett, numpy.blackman, numpy.convolve
scipy.signal.lfilter</p>
<p>TODO: the window parameter could be the window itself if an array instead of a string</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def smooth(x, window_len=9, window=&#39;hanning&#39;):
    &#34;&#34;&#34;
        Smooth the data using a window with requested size.
    
    This method is based on the convolution of a scaled window with the signal.
    The signal is prepared by introducing reflected copies of the signal 
    (with the window size) in both ends so that transient parts are minimized
    in the begining and end part of the output signal.
    
    Parameters
        ----------
        x : array_like
                the input signal 
        window_len : int
                The length of the smoothing window
        window : str
                The type of window from &#39;flat&#39;, &#39;hanning&#39;, &#39;hamming&#39;, &#39;bartlett&#39;, &#39;blackman&#39;
                &#39;flat&#39; window will produce a moving average smoothing.

    Returns
        -------
    out : The smoothed signal
        
    Example
        -------

    &gt;&gt;&gt; t=linspace(-2,2,0.1)
    &gt;&gt;&gt; x=sin(t)+randn(len(t))*0.1
    &gt;&gt;&gt; y=smooth(x)
    
    See Also
        --------
    
    numpy.hanning, numpy.hamming, numpy.bartlett, numpy.blackman, numpy.convolve
    scipy.signal.lfilter
 
    TODO: the window parameter could be the window itself if an array instead of a string   
    &#34;&#34;&#34;

    if type(x) == type([]):
        x = np.array(x)

    if x.ndim != 1:
        raise ValueError(&#34;smooth only accepts 1 dimension arrays.&#34;)

    if x.size &lt; window_len:
        raise ValueError(&#34;Input vector needs to be bigger than window size.&#34;)
    if window_len &lt; 3:
        return x

    if (window_len % 2) == 0:
        window_len = window_len + 1

    if not window in [&#39;flat&#39;, &#39;hanning&#39;, &#39;hamming&#39;, &#39;bartlett&#39;, &#39;blackman&#39;]:
        raise ValueError(
            &#34;Window is on of &#39;flat&#39;, &#39;hanning&#39;, &#39;hamming&#39;, &#39;bartlett&#39;, &#39;blackman&#39;&#34;)

    s = np.r_[2*x[0]-x[window_len:1:-1], x, 2*x[-1]-x[-1:-window_len:-1]]

    if window == &#39;flat&#39;:  # moving average
        w = np.ones(window_len, &#39;d&#39;)
    else:
        w = eval(&#39;np.&#39;+window+&#39;(window_len)&#39;)
    from astropy.convolution import convolve
    y = convolve(x, w/w.sum(), normalize_kernel=False, boundary=&#39;extend&#39;)
    # return the smoothed signal
    return y</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.utils.spiral"><code class="name flex">
<span>def <span class="ident">spiral</span></span>(<span>self, X, Y)</span>
</code></dt>
<dd>
<section class="desc"><p>Given an array of shape X x Y this returns the coordinates needed to step
out from the centre of the array to the edge in a spiral fashion:
see <a href="http://stackoverflow.com/questions/398299/looping-in-a-spiral?rq=1">http://stackoverflow.com/questions/398299/looping-in-a-spiral?rq=1</a>
for original code and question/ solution(s)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spiral(self, X, Y):
        &#39;&#39;&#39;
        Given an array of shape X x Y this returns the coordinates needed to step
        out from the centre of the array to the edge in a spiral fashion:
                see http://stackoverflow.com/questions/398299/looping-in-a-spiral?rq=1
                for original code and question/ solution(s)
        &#39;&#39;&#39;
        x = 0
        y = 0
        dx = 0
        dy = -1
        x_out = []
        y_out = []
        for i in range(max(X, Y)**2):
                x_out.append(x)
                y_out.append(y)
                if x == y or (x &lt; 0 and x == -y) or (x &gt; 0 and x == 1-y):
                        dx, dy = -dy, dx
                x, y = x+dx, y+dy
                
        return np.array(x_out), np.array(y_out)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ephysiopy.dacq2py.utils.bcolors"><code class="flex name class">
<span>class <span class="ident">bcolors</span></span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class bcolors:
        HEADER = &#39;\033[95m&#39;
        OKBLUE = &#39;\033[94m&#39;
        OKGREEN = &#39;\033[92m&#39;
        WARNING = &#39;\033[93m&#39;
        FAIL = &#39;\033[91m&#39;
        ENDC = &#39;\033[0m&#39;

        def disable(self):
                self.HEADER = &#39;&#39;
                self.OKBLUE = &#39;&#39;
                self.OKGREEN = &#39;&#39;
                self.WARNING = &#39;&#39;
                self.FAIL = &#39;&#39;
                self.ENDC = &#39;&#39;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="ephysiopy.dacq2py.utils.bcolors.ENDC"><code class="name">var <span class="ident">ENDC</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="ephysiopy.dacq2py.utils.bcolors.FAIL"><code class="name">var <span class="ident">FAIL</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="ephysiopy.dacq2py.utils.bcolors.HEADER"><code class="name">var <span class="ident">HEADER</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="ephysiopy.dacq2py.utils.bcolors.OKBLUE"><code class="name">var <span class="ident">OKBLUE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="ephysiopy.dacq2py.utils.bcolors.OKGREEN"><code class="name">var <span class="ident">OKGREEN</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="ephysiopy.dacq2py.utils.bcolors.WARNING"><code class="name">var <span class="ident">WARNING</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ephysiopy.dacq2py.utils.bcolors.disable"><code class="name flex">
<span>def <span class="ident">disable</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable(self):
        self.HEADER = &#39;&#39;
        self.OKBLUE = &#39;&#39;
        self.OKGREEN = &#39;&#39;
        self.WARNING = &#39;&#39;
        self.FAIL = &#39;&#39;
        self.ENDC = &#39;&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ephysiopy.dacq2py" href="index.html">ephysiopy.dacq2py</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="ephysiopy.dacq2py.utils.blur_image" href="#ephysiopy.dacq2py.utils.blur_image">blur_image</a></code></li>
<li><code><a title="ephysiopy.dacq2py.utils.count_to" href="#ephysiopy.dacq2py.utils.count_to">count_to</a></code></li>
<li><code><a title="ephysiopy.dacq2py.utils.polar" href="#ephysiopy.dacq2py.utils.polar">polar</a></code></li>
<li><code><a title="ephysiopy.dacq2py.utils.rect" href="#ephysiopy.dacq2py.utils.rect">rect</a></code></li>
<li><code><a title="ephysiopy.dacq2py.utils.repeat_ind" href="#ephysiopy.dacq2py.utils.repeat_ind">repeat_ind</a></code></li>
<li><code><a title="ephysiopy.dacq2py.utils.smooth" href="#ephysiopy.dacq2py.utils.smooth">smooth</a></code></li>
<li><code><a title="ephysiopy.dacq2py.utils.spiral" href="#ephysiopy.dacq2py.utils.spiral">spiral</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ephysiopy.dacq2py.utils.bcolors" href="#ephysiopy.dacq2py.utils.bcolors">bcolors</a></code></h4>
<ul class="two-column">
<li><code><a title="ephysiopy.dacq2py.utils.bcolors.ENDC" href="#ephysiopy.dacq2py.utils.bcolors.ENDC">ENDC</a></code></li>
<li><code><a title="ephysiopy.dacq2py.utils.bcolors.FAIL" href="#ephysiopy.dacq2py.utils.bcolors.FAIL">FAIL</a></code></li>
<li><code><a title="ephysiopy.dacq2py.utils.bcolors.HEADER" href="#ephysiopy.dacq2py.utils.bcolors.HEADER">HEADER</a></code></li>
<li><code><a title="ephysiopy.dacq2py.utils.bcolors.OKBLUE" href="#ephysiopy.dacq2py.utils.bcolors.OKBLUE">OKBLUE</a></code></li>
<li><code><a title="ephysiopy.dacq2py.utils.bcolors.OKGREEN" href="#ephysiopy.dacq2py.utils.bcolors.OKGREEN">OKGREEN</a></code></li>
<li><code><a title="ephysiopy.dacq2py.utils.bcolors.WARNING" href="#ephysiopy.dacq2py.utils.bcolors.WARNING">WARNING</a></code></li>
<li><code><a title="ephysiopy.dacq2py.utils.bcolors.disable" href="#ephysiopy.dacq2py.utils.bcolors.disable">disable</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>