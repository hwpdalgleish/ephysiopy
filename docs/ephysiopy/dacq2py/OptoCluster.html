<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>ephysiopy.dacq2py.OptoCluster API documentation</title>
<meta name="description" content="Created on Mon May 23 16:27:31 2016 â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ephysiopy.dacq2py.OptoCluster</code></h1>
</header>
<section id="section-intro">
<p>Created on Mon May 23 16:27:31 2016</p>
<p>@author: robin</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Mon May 23 16:27:31 2016

@author: robin
&#34;&#34;&#34;
import numpy as np
from ephysiopy.dacq2py.dacq2py_util import Trial
from ephysiopy.dacq2py.eegcalcs import EEGCalcs
import matplotlib.pyplot as plt
import yaml
import os

class OptoClusterSummary(Trial):
        &#34;&#34;&#34;
        docs
        &#34;&#34;&#34;
        def __init__(self, filename_root, *args, **kwargs):
                super(OptoClusterSummary, self).__init__(filename_root, *args, **kwargs)

        def __repr__(self):
           return &#34;{0}.{1}(filename_root=r\&#39;{2}\&#39;)&#34;.format(self.__class__.__module__, self.__class__.__name__, self.filename_root)

        def plotLaserFilteredSpectrogram(self, eeg_file=&#39;eeg&#39;, ymax=50, ax=None, secsPerBin=2, **kwargs):
                pass

        def plotFiringRateChange(self, tet, clust, n=50):
                &#39;&#39;&#39;
                Produces a bar graph of the firing rate in the n ms before laser onset
                and 50 ms after laser offset
                TODO: THIS IS BROKEN
                &#39;&#39;&#39;
                spkTimes_ms = self.TETRODE[tet].getClustTS(clust) / (self.TETRODE[tet].timebase / 1000)
                spkTimes_ms.sort()
                stm_timebase = int(self.STM[&#39;timebase&#39;].split()[0])
                stm_on = self.STM[&#39;on&#39;] / float(stm_timebase) * 1000
                stm_on.sort()
                stm_off = self.STM[&#39;off&#39;] / float(stm_timebase) * 1000
#        stm_off.sort()
                Trange_to_onset = np.array([-n, 0])
                Trange_to_offset = np.array([0, n])
                irange_to_onset = spkTimes_ms[:, np.newaxis] + Trange_to_onset[np.newaxis, :]
                irange_to_offset = spkTimes_ms[:, np.newaxis] + Trange_to_offset[np.newaxis, :]
                dts_to_onset = np.searchsorted(stm_on, irange_to_onset)
                dts_to_offset = np.searchsorted(stm_off, irange_to_offset)
                counts_to_onset = []
                counts_to_offset = []
                for i, t in enumerate(dts_to_onset):
                        counts_to_onset.extend(stm_on[t[0]:t[1]] - spkTimes_ms[i])
                for i, t in enumerate(dts_to_offset):
                        counts_to_offset.extend(stm_off[t[0]:t[1]] - spkTimes_ms[i])

                print(&#39;\nMean firing rate {0}ms before laser = {1:.2f} Hz&#39;.format(n, np.mean(np.abs(counts_to_offset))))
                print(&#39;Mean firing rate {0}ms after laser  = {1:.2f} Hz&#39;.format(n, np.mean(np.abs(counts_to_onset))))

                return counts_to_onset, counts_to_offset

        def getFiringRateDuringLaser(self, tet, clust, n=50):
                &#39;&#39;&#39;
                Returns a number which is the difference divided by the sum of the mean firing rate
                in the 50ms (or n ms) prior to laser onset and the firing rate during the stim period
                &#39;&#39;&#39;
                spkTimes_ms = self.TETRODE[tet].getClustTS(clust) / (self.TETRODE[tet].timebase / 1000)
                spkTimes_ms.sort()
                stm_timebase = int(self.STM[&#39;timebase&#39;].split()[0])
                stm_on = self.STM[&#39;on&#39;] / float(stm_timebase) * 1000
                stm_on.sort()
                stm_off = self.STM[&#39;off&#39;] / float(stm_timebase) * 1000
#        stm_off.sort()
                Trange_to_onset = np.array([-n, 0])
                Trange_to_offset = np.array([0, 10])
                irange_to_onset = spkTimes_ms[:, np.newaxis] + Trange_to_onset[np.newaxis, :]
                irange_to_offset = spkTimes_ms[:, np.newaxis] + Trange_to_offset[np.newaxis, :]
                dts_to_onset = np.searchsorted(stm_on, irange_to_onset)
                dts_to_offset = np.searchsorted(stm_on, irange_to_offset)
                counts_to_onset = []
                counts_to_offset = []
                for i, t in enumerate(dts_to_onset):
                        counts_to_onset.extend(stm_on[t[0]:t[1]] - spkTimes_ms[i])
                for i, t in enumerate(dts_to_offset):
                        counts_to_offset.extend(stm_on[t[0]:t[1]] - spkTimes_ms[i])
                before_rate = np.mean(np.abs(counts_to_offset))
                after_rate = np.mean(np.abs(counts_to_onset))
                change = float(before_rate - after_rate) / float(before_rate + after_rate)
                return before_rate, after_rate,change

        def plotAllPhasesXCorr(self, tet, clust, savename=None):
                fig, axes = plt.subplots(nrows=1, ncols=3, figsize=(5.845, 4.135))
                ax0 = axes[0]
                ax1 = axes[1]
                ax2 = axes[2]
                self._filterForStm(laser=0)
                # Split the posFilter into A and A&#39;
                phaseA = self.posFilter[&#39;time&#39;][0,:] / 50
                phaseAprime = self.posFilter[&#39;time&#39;][1,:] / 50

                self.posFilter = {&#39;time&#39;: phaseA}
                ax0, xcorr0 = super(OptoClusterSummary, self).plotXCorr(tet, clust, ax=ax0, annotate=False)
                self.posFilter = {&#39;time&#39;: phaseAprime}
                ax2, xcorr2 = super(OptoClusterSummary, self).plotXCorr(tet, clust, ax=ax2, annotate=False)
                self._filterForStm(laser=1)
                ax1, xcorr1 = super(OptoClusterSummary, self).plotXCorr(tet, clust, ax=ax1, annotate=False)
                A_vs_Aprime = self.fieldcalcs.corr_maps(xcorr0[0], xcorr2[0])
                A_vs_B = self.fieldcalcs.corr_maps(xcorr0[0], xcorr1[0])
                Aprime_vs_B = self.fieldcalcs.corr_maps(xcorr2[0], xcorr1[0])
                arrow_args = dict(arrowstyle=&#39;|-|&#39;, connectionstyle=&#34;Bar,armA=2,armB=2,fraction=.2&#34;)
                ax1.annotate(&#39;&#39;, xy=(0.5, 1.05), xycoords=ax0.transAxes,
                                  xytext=(0.5,1.05), textcoords=ax1.transAxes, arrowprops=arrow_args)
                ax2.annotate(&#39;&#39;, xy=(0.5, 1.05), xycoords=ax1.transAxes,
                                  xytext=(0.5,1.05), textcoords=ax2.transAxes, arrowprops=arrow_args)
                arrow_args = dict(arrowstyle=&#39;|-|&#39;, connectionstyle=&#34;Bar,armA=2,armB=2,fraction=-.1&#34;)
                ax2.annotate(&#39;&#39;, xy=(0.5, -0.025), xycoords=ax0.transAxes,
                                  xytext=(0.5,-0.025), textcoords=ax2.transAxes, arrowprops=arrow_args)
                ax0.text(1.0,1.4,&#39;{:.2f}&#39;.format(A_vs_B),transform=ax0.transAxes)
                ax1.text(1.0,1.4,&#39;{:.2f}&#39;.format(Aprime_vs_B),transform=ax1.transAxes)
                ax1.text(0.5,-.4,&#39;{:.2f}&#39;.format(A_vs_Aprime),transform=ax1.transAxes,ha=&#39;center&#39;)
                if savename is not None:
                        fig.savefig(savename)
                return fig

        def plotAllPhases(self, tet, clusts, savename=None, var2bin=&#39;pos&#39;,vmax=&#39;auto&#39;):
                &#39;&#39;&#39;
                Plots all phases i.e. A, B A&#39;
                &#39;&#39;&#39;
                if &#39;dir&#39; in var2bin:
                        fig, axes = plt.subplots(nrows=1, ncols=3, figsize=(5.845, 4.135),subplot_kw={&#34;projection&#34;:&#34;polar&#34;})
                else:
                        fig, axes = plt.subplots(nrows=1, ncols=3, figsize=(5.845, 4.135))
                ax0 = axes[0]
                ax1 = axes[1]
                ax2 = axes[2]
                self._filterForStm(laser=0)
                # Split the posFilter into A and A&#39;
                phaseA = self.posFilter[&#39;time&#39;][0,:] / 50
                phaseAprime = self.posFilter[&#39;time&#39;][1,:] / 50

                # normalizing the ratemaps has to be done in a two-pass operation
                # first-pass - get ratemap
                self.posFilter = {&#39;time&#39;: phaseA}
                rmap0 = self._getMap(tet, clusts)[0]
                self.posFilter = {&#39;time&#39;: phaseAprime}
                rmap2 = self._getMap(tet, clusts)[0]
                self._filterForStm(laser=1)
                rmap1 = self._getMap(tet, clusts)[0]
                # get the max value in all ratemaps to scale the others
                if &#39;auto&#39; in vmax:
                        vmax = np.nanmax([rmap0.ravel(), rmap1.ravel(), rmap2.ravel()])
                        vmax1 = vmax
                        vmax2 = vmax
                else:
                        vmax = np.nanmax(rmap0.ravel())
                        vmax1 = np.nanmax(rmap1.ravel())
                        vmax2 = np.nanmax(rmap2.ravel())
#               vmax=10.0
                print(&#39;vmax = {}&#39;.format(vmax))
                self.posFilter = {&#39;time&#39;: phaseA}
                ax0, rmap0 = super(OptoClusterSummary, self)._plotMap(tet, clusts, ax=ax0, var2bin=var2bin, binsize=3, smooth_sz=5, smooth=True,vmax=vmax,add_mrv=True)
                self.posFilter = {&#39;time&#39;: phaseAprime}
                ax2, rmap2 = super(OptoClusterSummary, self)._plotMap(tet, clusts, ax=ax2, var2bin=var2bin, binsize=3, smooth_sz=5, smooth=True,vmax=vmax1,add_mrv=True)
                self._filterForStm(laser=1)
                ax1, rmap1 = super(OptoClusterSummary, self)._plotMap(tet, clusts, ax=ax1, var2bin=var2bin, binsize=3, smooth_sz=5, smooth=True,vmax=vmax2,add_mrv=True)

                # annotate the figure with arrows and correlation values
                # get the correlation values
                A_vs_Aprime = self.fieldcalcs.corr_maps(rmap0, rmap2)
                A_vs_B = self.fieldcalcs.corr_maps(rmap0, rmap1)
                Aprime_vs_B = self.fieldcalcs.corr_maps(rmap2, rmap1)
                arrow_args = dict(arrowstyle=&#39;|-|&#39;, connectionstyle=&#34;Bar,armA=2,armB=2,fraction=.2&#34;)
                ax1.annotate(&#39;&#39;, xy=(0.5, 1.05), xycoords=ax0.transAxes,
                                  xytext=(0.5,1.05), textcoords=ax1.transAxes, arrowprops=arrow_args)
                ax2.annotate(&#39;&#39;, xy=(0.5, 1.05), xycoords=ax1.transAxes,
                                  xytext=(0.5,1.05), textcoords=ax2.transAxes, arrowprops=arrow_args)
                arrow_args = dict(arrowstyle=&#39;|-|&#39;, connectionstyle=&#34;Bar,armA=2,armB=2,fraction=-.1&#34;)
                ax2.annotate(&#39;&#39;, xy=(0.5, -0.025), xycoords=ax0.transAxes,
                                  xytext=(0.5,-0.025), textcoords=ax2.transAxes, arrowprops=arrow_args)
                ax0.text(1.0,1.4,&#39;{:.2f}&#39;.format(A_vs_B),transform=ax0.transAxes)
                ax1.text(1.0,1.4,&#39;{:.2f}&#39;.format(Aprime_vs_B),transform=ax1.transAxes)
                ax1.text(0.5,-.4,&#39;{:.2f}&#39;.format(A_vs_Aprime),transform=ax1.transAxes,ha=&#39;center&#39;)
                if savename is not None:
                        fig.savefig(savename)
                return fig

        def plotLaserPhasesRatemap(self, tet, clusts, var2bin=&#39;pos&#39;, binsize=3,
                                smooth_sz=5, smooth=True, laser=None, **kwargs):
                fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(5.845, 4.135))
                self._filterForStm(laser=0)
                ax1, rmap1 = super(OptoClusterSummary, self)._plotMap(tet, clusts, ax=ax1, var2bin=&#39;pos&#39;, binsize=3, smooth_sz=5, smooth=True)
                ax1.set_xlabel(&#39;Laser off&#39;)
                self._filterForStm(laser=1)
                ax2, rmap2 = super(OptoClusterSummary, self)._plotMap(tet, clusts, ax=ax2, var2bin=&#39;pos&#39;, binsize=3, smooth_sz=5, smooth=True)
                ax2.set_xlabel(&#39;Laser on&#39;)

        def plotLaserPhasesSpikesOnPath(self, tet, clusts):
                fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(5.845, 4.135))
                self._filterForStm(laser=0)
                ax1 = super(OptoClusterSummary, self).plotSpikesOnPath(tet, clusts, ax=ax1)
                ax1.set_xlabel(&#39;Laser off&#39;)
                self._filterForStm(laser=1)
                ax2 = super(OptoClusterSummary, self).plotSpikesOnPath(tet, clusts, ax=ax2)
                ax2.set_xlabel(&#39;Laser on&#39;)

        def plotLaserPhasesSpeedVsRate(self, tet, clusts):
                fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(5.845, 4.535))
                self._filterForStm(laser=0)
                super(OptoClusterSummary, self).plotRateVSpeed(tet, clusts, plot=True, ax=ax1)
                ax1.set_xlabel(&#39;Laser off&#39;)
                self._filterForStm(laser=1)
                super(OptoClusterSummary, self).plotRateVSpeed(tet, clusts, plot=True, ax=ax2)
                ax2.set_xlabel(&#39;Laser on&#39;)
                ax2.set_ylabel(&#39;&#39;)

        def plotAllSpeedVsRate(self, tet, clust):
                &#39;&#39;&#39;
                plots the speed vs rate graphs for all three sections of a stim
                trial on the same line graph
                &#39;&#39;&#39;
                fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(4.135, 5.845))
                self._filterForStm(laser=0)
                # Split the posFilter into A and A&#39;
                phaseA = self.posFilter[&#39;time&#39;][0,:] / 50
                phaseAprime = self.posFilter[&#39;time&#39;][1,:] / 50
                self.posFilter = {&#39;time&#39;: phaseA}
                res, spd_binsA, mn_rateA = self.plotRateVSpeed(tet,clust,plot=False, getData=True)
#               ax.plot(spd_binsA, mn_rateA, &#39;k&#39;)
                self.posFilter = {&#39;time&#39;: phaseAprime}
                res, spd_binsAp, mn_rateAp = self.plotRateVSpeed(tet,clust,plot=False, getData=True)
#               ax.plot(spd_binsAp, mn_rateAp, &#39;k--&#39;)
                self._filterForStm(laser=1)
                res, spd_binsB, mn_rateB = self.plotRateVSpeed(tet,clust,plot=False, getData=True)
                line0, = ax.plot(spd_binsA, mn_rateA, &#39;k&#39;)
                line1, = ax.plot(spd_binsAp, mn_rateAp, &#39;k--&#39;)
                line2, = ax.plot(spd_binsB, mn_rateB, &#39;b--&#39;)

                ax.set_ylabel(&#34;Firing rate(Hz)&#34;)
                ax.set_xlabel(&#34;Speed(cm/s)&#34;)
                ylabels = ax.get_yticklabels()
                for i in range(1, len(ylabels)-1):
                        ylabels[i].set_visible(False)
                yticks = ax.get_yticklines()
                for i in range(1, len(yticks)-1):
                        yticks[i].set_visible(False)
                xlabels = ax.get_xticklabels()
                for i in range(1, len(xlabels)-1):
                        xlabels[i].set_visible(False)
                xticks = ax.get_xticklines()
                for i in range(1, len(xticks)-1):
                        xticks[i].set_visible(False)
                ax.spines[&#39;right&#39;].set_visible(False)
                ax.spines[&#39;top&#39;].set_visible(False)
                ax.yaxis.set_ticks_position(&#39;left&#39;)
                ax.xaxis.set_ticks_position(&#39;bottom&#39;)
                ax.legend((line0,line2,line1),[&#39;Laser off (1)&#39;,&#39;Laser on&#39;,&#39;Laser off (2)&#39;],loc=2)
                return fig

        def plotLaserPhasesSAC(self, tetrode, clusters, ax=None, binsize=3, **kwargs):
                fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(5.845, 4.135))
                self._filterForStm(laser=0)
                ax1 = super(OptoClusterSummary, self).plotSAC(tetrode, clusters, ax=ax1, binsize=3, **kwargs)
                ax1.set_xlabel(&#39;Laser off&#39;)
                self._filterForStm(laser=1)
                ax2 = super(OptoClusterSummary, self).plotSAC(tetrode, clusters, ax=ax2, binsize=3, **kwargs)
                ax2.set_xlabel(&#39;Laser on&#39;)

        def plotLaserPhasesFreqVSpeed(self, minSp=5, maxSp=50, spStep=5, ax=None, laserFilter=None, **kwargs):
                &#39;&#39;&#39;
                Plots both phases for an opto trial ie laser on *and* off on same axes
                Scales axes so y is same on both
                Note that kwargs can contain values that affect the filtering of the EEG
                such as &#39;width&#39;, &#39;dip&#39; and &#39;stimFreq&#39; which will change the coefficients of
                the Kaisser filter
                &#39;&#39;&#39;
                fig, (ax1, ax2) = plt.subplots(nrows=2, ncols=1, figsize=(4.135, 5.845))
                self._filterForStm(laser=0)
                ax1, intercept, slope = super(OptoClusterSummary, self).plotFreqVSpeed(minSp=minSp, maxSp=maxSp, spStep=spStep, ax=ax1, laserFilter=None, **kwargs)
                ax1.set_title(&#39;Laser off\nIntercept: {0:.3f}    Slope: {1:.5f}&#39;.format(intercept, slope))
                self._filterForStm(laser=1)
                sf = self.getStimFreq()
                ax2, intercept, slope = super(OptoClusterSummary, self).plotFreqVSpeed(minSp=minSp, maxSp=maxSp, spStep=spStep, ax=ax2, laserFilter=True, stimFreq=sf, **kwargs)
                ax2.set_title(&#39;Laser on\nIntercept: {0:.3f}    Slope: {1:.5f}&#39;.format(intercept, slope))
                ax1ylims = ax1.get_ylim()
                ax2ylims = ax2.get_ylim()
                ylims = (np.min((ax1ylims, ax2ylims)), np.max((ax1ylims, ax2ylims)))
                ax1.set_ylim(ylims)
                ax2.set_ylim(ylims)
                ax1.set_xlabel(&#39;&#39;)
                ax1.tick_params(axis=&#39;x&#39;,which=&#39;both&#39;, bottom=&#39;off&#39;, labelbottom=&#39;off&#39;)

        def plotFreqVSpeed(self, minSp=5, maxSp=50, spStep=5, ax=None, laser=None, **kwargs):
                &#39;&#39;&#39;
                Overrides the same method in the Trial class by filtering for
                presence/ absence of laser stimulation and modifying the title
                of the resulting plot to say whether laser was on /off / 
                not present (nothing added to title)
                &#39;&#39;&#39;
                self._filterForStm(laser)
                ax, intercept, slope = super(OptoClusterSummary, self).plotFreqVSpeed(minSp=minSp, maxSp=maxSp, spStep=spStep, ax=ax, **kwargs)
                if laser == 1:
                        ax.set_title(&#39;Laser on\nIntercept: {0:.3f}    Slope: {1:.5f}&#39;.format(intercept, slope))
                elif laser == 0:
                        ax.set_title(&#39;Laser off\nIntercept: {0:.3f}    Slope: {1:.5f}&#39;.format(intercept, slope))
                else:
                        ax.set_title(&#39;Intercept: {0:.3f}    Slope: {1:.5f}&#39;.format(intercept, slope))
                return ax

        def plotLaserPhasesEEGPower(self, width=0.125, dip=15.0, laserFilter=True):
                &#39;&#39;&#39;
                Overrides the same method in the Trial class by filtering for
                presence/ absence of laser stimulation and modifying the title
                of the resulting plot to say whether laser was on /off / 
                not present (nothing added to title)
                &#39;&#39;&#39;
                EE = EEGCalcs(self.filename_root,thetaRange=[6,12])
                self._filterForStm(laser=0)
                if np.ma.is_masked(self.EEG.eeg):
                        eeg = np.ma.compressed(self.EEG.eeg)
                else:
                        eeg = self.EEG.eeg
#        if laserFilter:
#            sf = self.getStimFreq()
#            fx = EE.filterForLaser(E=eeg, width=width, dip=dip, stimFreq=sf)
#        else:
#            fx = eeg
                fx = eeg
                fig, (ax1, ax2) = plt.subplots(nrows=2, ncols=1, figsize=(4.135, 5.845))
                ax1 = super(OptoClusterSummary, self).plotEEGPower(E=fx, sample_rate=250.0, freqBand=(6,12), ax=ax1)
                ax1.set_title(&#34;Laser off\nwidth = {0}, dip = {1}&#34;.format(width, dip))
                ax1.set_xlabel(&#39;&#39;)
                ax1.tick_params(axis=&#39;x&#39;,which=&#39;both&#39;, bottom=&#39;off&#39;, labelbottom=&#39;off&#39;)

                self._filterForStm(laser=1)
                if np.ma.is_masked(self.EEG.eeg):
                        eeg = np.ma.compressed(self.EEG.eeg)
                else:
                        eeg = self.EEG.eeg
                if laserFilter:
                        sf = self.getStimFreq()
                        fx = EE.filterForLaser(E=eeg, width=width, dip=dip, stimFreq=sf)
                else:
                        fx = eeg
                ax2 = super(OptoClusterSummary, self).plotEEGPower(E=fx, sample_rate=250.0, freqBand=(6,12), ax=ax2)
                ax2.set_title(&#34;Laser on\nwidth = {0}, dip = {1}&#34;.format(width, dip))

        def getStimFreq(self):
                &#39;&#39;&#39;
                Looks in the STM dict and calculates the stimulation frequency in Hz
                Note that at the moment this only returns the first phase that isn&#39;t a
                &#39;Pause (no stimulation)&#39; phase i.e. if multiple stimulation phases are 
                used this (and other functions) will need re-writing
                &#39;&#39;&#39;
                if self.STM:
                        for phase in self.STM[&#39;stim_params&#39;]:
                                if &#39;Pause&#39; not in self.STM[&#39;stim_params&#39;][phase][&#39;name&#39;]:
                                        pulsePause = self.STM[&#39;stim_params&#39;][phase][&#39;pulsePause&#39;]
                                        pulseWidth = self.STM[&#39;stim_params&#39;][phase][&#39;pulseWidth&#39;]
                                        stimFreq = (float(pulseWidth) / pulsePause) * 100
                                        return stimFreq

        def read_yaml(self):
                &#34;&#34;&#34;
                method to read data in from a yaml file
                &#34;&#34;&#34;
                yaml_file = r&#39;/media/robin/data/Dropbox/Science/Analysis/Mouse optogenetics/SST_Cre_grid_cell_project/grid_cell.yaml&#39;
                stream = open(yaml_file, &#39;r&#39;)
                yaml_data = yaml.load_all(stream)
                return yaml_data

        def plot(self):
                &#34;&#34;&#34;
                main plotting method
                &#34;&#34;&#34;
                savedir = r&#39;/home/robin/Desktop&#39;
                plot_items = ([&#39;plotClusterSpace&#39;, &#39;plotWaveforms&#39;, &#39;plotXCorr&#39;,
                                          &#39;plotEEGPower&#39;, &#39;plotMap&#39;, &#39;plotFullSAC&#39;,
                                          &#39;plotRaster&#39;, &#39;plot_event_EEG&#39;])
                n_rows = 4
                n_cols = 2
                for i, tet_clust in enumerate(zip(self.tetrodes, self.clusters)):
                        fig = plt.figure(figsize=(4.135, 11.6))  # A4 landscape
                        for idx, item in enumerate(plot_items):
                                ax = fig.add_subplot(n_rows, n_cols, idx+1, frame_on=True)
                                ax.axis(&#39;off&#39;)
                                rect = ax.get_position().bounds
                                if &#39;XCorr&#39; in item:
                                        ax.axis(&#39;on&#39;)
                                if np.logical_or(&#39;Cluster&#39; in item, &#39;Wave&#39; in item):
                                        ax.axis(frame_on=False)
                                        eval(&#39;self.&#39; + item + &#39;(tetrode=tet_clust[0], clusters=tet_clust[1], ax=ax, figure=fig)&#39;)
                                elif np.logical_or(&#39;Raster&#39; in item, &#39;EEG&#39; in item):
                                        ax.axis(frame_on=True)
                                        ax.axis(&#39;on&#39;)
                                        eval(&#34;self.&#34; + item + &#34;(tetrode=tet_clust[0], clusters=tet_clust[1],  ax=ax)&#34;)
                                else:
                                        eval(&#39;self.&#39; + item + &#39;(tetrode=tet_clust[0], clusters=tet_clust[1], ax=ax)&#39;)
                        fig.text(0.5, 0.95, (os.path.split(self.filename_root)[-1] + &#39;\nTetrode: &#39; +
                                                                str(tet_clust[0]) + &#39; Cluster: &#39; + str(tet_clust[1])),
                                                                transform = fig.transFigure, fontsize=20,
                                                                va=&#39;top&#39;, ha=&#39;center&#39;)
                        fig.subplots_adjust(hspace=0.5, wspace=0.5)
                        fig.savefig(os.path.join(savedir, (os.path.split(self.filename_root)[-1] + &#39;_t&#39; + str(tet_clust[0])
                                                                                                + &#39;_c&#39; + str(tet_clust[1]) + &#39;.png&#39;)))
                plt.show()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ephysiopy.dacq2py.OptoCluster.OptoClusterSummary"><code class="flex name class">
<span>class <span class="ident">OptoClusterSummary</span></span>
<span>(</span><span>filename_root, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>docs</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename_root</code></strong> :&ensp;<code>str</code></dt>
<dd>The absolute filename without any suffix attached
i.e. C:\Robin\mytrial<pre><code>Note that when RH is using this can be just the trial name as the getFullFile method
tries to find the trial given the folder layout and the filename - see that method
for details
</code></pre>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>T</code></strong> :&ensp;<code>object</code></dt>
<dd>a dacq2py_util.Trial object</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; T = dacq2py_util.Trial(r'/media/robin/data/Dropbox/Science/Recordings/M851/M851_140908t1rh')
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OptoClusterSummary(Trial):
        &#34;&#34;&#34;
        docs
        &#34;&#34;&#34;
        def __init__(self, filename_root, *args, **kwargs):
                super(OptoClusterSummary, self).__init__(filename_root, *args, **kwargs)

        def __repr__(self):
           return &#34;{0}.{1}(filename_root=r\&#39;{2}\&#39;)&#34;.format(self.__class__.__module__, self.__class__.__name__, self.filename_root)

        def plotLaserFilteredSpectrogram(self, eeg_file=&#39;eeg&#39;, ymax=50, ax=None, secsPerBin=2, **kwargs):
                pass

        def plotFiringRateChange(self, tet, clust, n=50):
                &#39;&#39;&#39;
                Produces a bar graph of the firing rate in the n ms before laser onset
                and 50 ms after laser offset
                TODO: THIS IS BROKEN
                &#39;&#39;&#39;
                spkTimes_ms = self.TETRODE[tet].getClustTS(clust) / (self.TETRODE[tet].timebase / 1000)
                spkTimes_ms.sort()
                stm_timebase = int(self.STM[&#39;timebase&#39;].split()[0])
                stm_on = self.STM[&#39;on&#39;] / float(stm_timebase) * 1000
                stm_on.sort()
                stm_off = self.STM[&#39;off&#39;] / float(stm_timebase) * 1000
#        stm_off.sort()
                Trange_to_onset = np.array([-n, 0])
                Trange_to_offset = np.array([0, n])
                irange_to_onset = spkTimes_ms[:, np.newaxis] + Trange_to_onset[np.newaxis, :]
                irange_to_offset = spkTimes_ms[:, np.newaxis] + Trange_to_offset[np.newaxis, :]
                dts_to_onset = np.searchsorted(stm_on, irange_to_onset)
                dts_to_offset = np.searchsorted(stm_off, irange_to_offset)
                counts_to_onset = []
                counts_to_offset = []
                for i, t in enumerate(dts_to_onset):
                        counts_to_onset.extend(stm_on[t[0]:t[1]] - spkTimes_ms[i])
                for i, t in enumerate(dts_to_offset):
                        counts_to_offset.extend(stm_off[t[0]:t[1]] - spkTimes_ms[i])

                print(&#39;\nMean firing rate {0}ms before laser = {1:.2f} Hz&#39;.format(n, np.mean(np.abs(counts_to_offset))))
                print(&#39;Mean firing rate {0}ms after laser  = {1:.2f} Hz&#39;.format(n, np.mean(np.abs(counts_to_onset))))

                return counts_to_onset, counts_to_offset

        def getFiringRateDuringLaser(self, tet, clust, n=50):
                &#39;&#39;&#39;
                Returns a number which is the difference divided by the sum of the mean firing rate
                in the 50ms (or n ms) prior to laser onset and the firing rate during the stim period
                &#39;&#39;&#39;
                spkTimes_ms = self.TETRODE[tet].getClustTS(clust) / (self.TETRODE[tet].timebase / 1000)
                spkTimes_ms.sort()
                stm_timebase = int(self.STM[&#39;timebase&#39;].split()[0])
                stm_on = self.STM[&#39;on&#39;] / float(stm_timebase) * 1000
                stm_on.sort()
                stm_off = self.STM[&#39;off&#39;] / float(stm_timebase) * 1000
#        stm_off.sort()
                Trange_to_onset = np.array([-n, 0])
                Trange_to_offset = np.array([0, 10])
                irange_to_onset = spkTimes_ms[:, np.newaxis] + Trange_to_onset[np.newaxis, :]
                irange_to_offset = spkTimes_ms[:, np.newaxis] + Trange_to_offset[np.newaxis, :]
                dts_to_onset = np.searchsorted(stm_on, irange_to_onset)
                dts_to_offset = np.searchsorted(stm_on, irange_to_offset)
                counts_to_onset = []
                counts_to_offset = []
                for i, t in enumerate(dts_to_onset):
                        counts_to_onset.extend(stm_on[t[0]:t[1]] - spkTimes_ms[i])
                for i, t in enumerate(dts_to_offset):
                        counts_to_offset.extend(stm_on[t[0]:t[1]] - spkTimes_ms[i])
                before_rate = np.mean(np.abs(counts_to_offset))
                after_rate = np.mean(np.abs(counts_to_onset))
                change = float(before_rate - after_rate) / float(before_rate + after_rate)
                return before_rate, after_rate,change

        def plotAllPhasesXCorr(self, tet, clust, savename=None):
                fig, axes = plt.subplots(nrows=1, ncols=3, figsize=(5.845, 4.135))
                ax0 = axes[0]
                ax1 = axes[1]
                ax2 = axes[2]
                self._filterForStm(laser=0)
                # Split the posFilter into A and A&#39;
                phaseA = self.posFilter[&#39;time&#39;][0,:] / 50
                phaseAprime = self.posFilter[&#39;time&#39;][1,:] / 50

                self.posFilter = {&#39;time&#39;: phaseA}
                ax0, xcorr0 = super(OptoClusterSummary, self).plotXCorr(tet, clust, ax=ax0, annotate=False)
                self.posFilter = {&#39;time&#39;: phaseAprime}
                ax2, xcorr2 = super(OptoClusterSummary, self).plotXCorr(tet, clust, ax=ax2, annotate=False)
                self._filterForStm(laser=1)
                ax1, xcorr1 = super(OptoClusterSummary, self).plotXCorr(tet, clust, ax=ax1, annotate=False)
                A_vs_Aprime = self.fieldcalcs.corr_maps(xcorr0[0], xcorr2[0])
                A_vs_B = self.fieldcalcs.corr_maps(xcorr0[0], xcorr1[0])
                Aprime_vs_B = self.fieldcalcs.corr_maps(xcorr2[0], xcorr1[0])
                arrow_args = dict(arrowstyle=&#39;|-|&#39;, connectionstyle=&#34;Bar,armA=2,armB=2,fraction=.2&#34;)
                ax1.annotate(&#39;&#39;, xy=(0.5, 1.05), xycoords=ax0.transAxes,
                                  xytext=(0.5,1.05), textcoords=ax1.transAxes, arrowprops=arrow_args)
                ax2.annotate(&#39;&#39;, xy=(0.5, 1.05), xycoords=ax1.transAxes,
                                  xytext=(0.5,1.05), textcoords=ax2.transAxes, arrowprops=arrow_args)
                arrow_args = dict(arrowstyle=&#39;|-|&#39;, connectionstyle=&#34;Bar,armA=2,armB=2,fraction=-.1&#34;)
                ax2.annotate(&#39;&#39;, xy=(0.5, -0.025), xycoords=ax0.transAxes,
                                  xytext=(0.5,-0.025), textcoords=ax2.transAxes, arrowprops=arrow_args)
                ax0.text(1.0,1.4,&#39;{:.2f}&#39;.format(A_vs_B),transform=ax0.transAxes)
                ax1.text(1.0,1.4,&#39;{:.2f}&#39;.format(Aprime_vs_B),transform=ax1.transAxes)
                ax1.text(0.5,-.4,&#39;{:.2f}&#39;.format(A_vs_Aprime),transform=ax1.transAxes,ha=&#39;center&#39;)
                if savename is not None:
                        fig.savefig(savename)
                return fig

        def plotAllPhases(self, tet, clusts, savename=None, var2bin=&#39;pos&#39;,vmax=&#39;auto&#39;):
                &#39;&#39;&#39;
                Plots all phases i.e. A, B A&#39;
                &#39;&#39;&#39;
                if &#39;dir&#39; in var2bin:
                        fig, axes = plt.subplots(nrows=1, ncols=3, figsize=(5.845, 4.135),subplot_kw={&#34;projection&#34;:&#34;polar&#34;})
                else:
                        fig, axes = plt.subplots(nrows=1, ncols=3, figsize=(5.845, 4.135))
                ax0 = axes[0]
                ax1 = axes[1]
                ax2 = axes[2]
                self._filterForStm(laser=0)
                # Split the posFilter into A and A&#39;
                phaseA = self.posFilter[&#39;time&#39;][0,:] / 50
                phaseAprime = self.posFilter[&#39;time&#39;][1,:] / 50

                # normalizing the ratemaps has to be done in a two-pass operation
                # first-pass - get ratemap
                self.posFilter = {&#39;time&#39;: phaseA}
                rmap0 = self._getMap(tet, clusts)[0]
                self.posFilter = {&#39;time&#39;: phaseAprime}
                rmap2 = self._getMap(tet, clusts)[0]
                self._filterForStm(laser=1)
                rmap1 = self._getMap(tet, clusts)[0]
                # get the max value in all ratemaps to scale the others
                if &#39;auto&#39; in vmax:
                        vmax = np.nanmax([rmap0.ravel(), rmap1.ravel(), rmap2.ravel()])
                        vmax1 = vmax
                        vmax2 = vmax
                else:
                        vmax = np.nanmax(rmap0.ravel())
                        vmax1 = np.nanmax(rmap1.ravel())
                        vmax2 = np.nanmax(rmap2.ravel())
#               vmax=10.0
                print(&#39;vmax = {}&#39;.format(vmax))
                self.posFilter = {&#39;time&#39;: phaseA}
                ax0, rmap0 = super(OptoClusterSummary, self)._plotMap(tet, clusts, ax=ax0, var2bin=var2bin, binsize=3, smooth_sz=5, smooth=True,vmax=vmax,add_mrv=True)
                self.posFilter = {&#39;time&#39;: phaseAprime}
                ax2, rmap2 = super(OptoClusterSummary, self)._plotMap(tet, clusts, ax=ax2, var2bin=var2bin, binsize=3, smooth_sz=5, smooth=True,vmax=vmax1,add_mrv=True)
                self._filterForStm(laser=1)
                ax1, rmap1 = super(OptoClusterSummary, self)._plotMap(tet, clusts, ax=ax1, var2bin=var2bin, binsize=3, smooth_sz=5, smooth=True,vmax=vmax2,add_mrv=True)

                # annotate the figure with arrows and correlation values
                # get the correlation values
                A_vs_Aprime = self.fieldcalcs.corr_maps(rmap0, rmap2)
                A_vs_B = self.fieldcalcs.corr_maps(rmap0, rmap1)
                Aprime_vs_B = self.fieldcalcs.corr_maps(rmap2, rmap1)
                arrow_args = dict(arrowstyle=&#39;|-|&#39;, connectionstyle=&#34;Bar,armA=2,armB=2,fraction=.2&#34;)
                ax1.annotate(&#39;&#39;, xy=(0.5, 1.05), xycoords=ax0.transAxes,
                                  xytext=(0.5,1.05), textcoords=ax1.transAxes, arrowprops=arrow_args)
                ax2.annotate(&#39;&#39;, xy=(0.5, 1.05), xycoords=ax1.transAxes,
                                  xytext=(0.5,1.05), textcoords=ax2.transAxes, arrowprops=arrow_args)
                arrow_args = dict(arrowstyle=&#39;|-|&#39;, connectionstyle=&#34;Bar,armA=2,armB=2,fraction=-.1&#34;)
                ax2.annotate(&#39;&#39;, xy=(0.5, -0.025), xycoords=ax0.transAxes,
                                  xytext=(0.5,-0.025), textcoords=ax2.transAxes, arrowprops=arrow_args)
                ax0.text(1.0,1.4,&#39;{:.2f}&#39;.format(A_vs_B),transform=ax0.transAxes)
                ax1.text(1.0,1.4,&#39;{:.2f}&#39;.format(Aprime_vs_B),transform=ax1.transAxes)
                ax1.text(0.5,-.4,&#39;{:.2f}&#39;.format(A_vs_Aprime),transform=ax1.transAxes,ha=&#39;center&#39;)
                if savename is not None:
                        fig.savefig(savename)
                return fig

        def plotLaserPhasesRatemap(self, tet, clusts, var2bin=&#39;pos&#39;, binsize=3,
                                smooth_sz=5, smooth=True, laser=None, **kwargs):
                fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(5.845, 4.135))
                self._filterForStm(laser=0)
                ax1, rmap1 = super(OptoClusterSummary, self)._plotMap(tet, clusts, ax=ax1, var2bin=&#39;pos&#39;, binsize=3, smooth_sz=5, smooth=True)
                ax1.set_xlabel(&#39;Laser off&#39;)
                self._filterForStm(laser=1)
                ax2, rmap2 = super(OptoClusterSummary, self)._plotMap(tet, clusts, ax=ax2, var2bin=&#39;pos&#39;, binsize=3, smooth_sz=5, smooth=True)
                ax2.set_xlabel(&#39;Laser on&#39;)

        def plotLaserPhasesSpikesOnPath(self, tet, clusts):
                fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(5.845, 4.135))
                self._filterForStm(laser=0)
                ax1 = super(OptoClusterSummary, self).plotSpikesOnPath(tet, clusts, ax=ax1)
                ax1.set_xlabel(&#39;Laser off&#39;)
                self._filterForStm(laser=1)
                ax2 = super(OptoClusterSummary, self).plotSpikesOnPath(tet, clusts, ax=ax2)
                ax2.set_xlabel(&#39;Laser on&#39;)

        def plotLaserPhasesSpeedVsRate(self, tet, clusts):
                fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(5.845, 4.535))
                self._filterForStm(laser=0)
                super(OptoClusterSummary, self).plotRateVSpeed(tet, clusts, plot=True, ax=ax1)
                ax1.set_xlabel(&#39;Laser off&#39;)
                self._filterForStm(laser=1)
                super(OptoClusterSummary, self).plotRateVSpeed(tet, clusts, plot=True, ax=ax2)
                ax2.set_xlabel(&#39;Laser on&#39;)
                ax2.set_ylabel(&#39;&#39;)

        def plotAllSpeedVsRate(self, tet, clust):
                &#39;&#39;&#39;
                plots the speed vs rate graphs for all three sections of a stim
                trial on the same line graph
                &#39;&#39;&#39;
                fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(4.135, 5.845))
                self._filterForStm(laser=0)
                # Split the posFilter into A and A&#39;
                phaseA = self.posFilter[&#39;time&#39;][0,:] / 50
                phaseAprime = self.posFilter[&#39;time&#39;][1,:] / 50
                self.posFilter = {&#39;time&#39;: phaseA}
                res, spd_binsA, mn_rateA = self.plotRateVSpeed(tet,clust,plot=False, getData=True)
#               ax.plot(spd_binsA, mn_rateA, &#39;k&#39;)
                self.posFilter = {&#39;time&#39;: phaseAprime}
                res, spd_binsAp, mn_rateAp = self.plotRateVSpeed(tet,clust,plot=False, getData=True)
#               ax.plot(spd_binsAp, mn_rateAp, &#39;k--&#39;)
                self._filterForStm(laser=1)
                res, spd_binsB, mn_rateB = self.plotRateVSpeed(tet,clust,plot=False, getData=True)
                line0, = ax.plot(spd_binsA, mn_rateA, &#39;k&#39;)
                line1, = ax.plot(spd_binsAp, mn_rateAp, &#39;k--&#39;)
                line2, = ax.plot(spd_binsB, mn_rateB, &#39;b--&#39;)

                ax.set_ylabel(&#34;Firing rate(Hz)&#34;)
                ax.set_xlabel(&#34;Speed(cm/s)&#34;)
                ylabels = ax.get_yticklabels()
                for i in range(1, len(ylabels)-1):
                        ylabels[i].set_visible(False)
                yticks = ax.get_yticklines()
                for i in range(1, len(yticks)-1):
                        yticks[i].set_visible(False)
                xlabels = ax.get_xticklabels()
                for i in range(1, len(xlabels)-1):
                        xlabels[i].set_visible(False)
                xticks = ax.get_xticklines()
                for i in range(1, len(xticks)-1):
                        xticks[i].set_visible(False)
                ax.spines[&#39;right&#39;].set_visible(False)
                ax.spines[&#39;top&#39;].set_visible(False)
                ax.yaxis.set_ticks_position(&#39;left&#39;)
                ax.xaxis.set_ticks_position(&#39;bottom&#39;)
                ax.legend((line0,line2,line1),[&#39;Laser off (1)&#39;,&#39;Laser on&#39;,&#39;Laser off (2)&#39;],loc=2)
                return fig

        def plotLaserPhasesSAC(self, tetrode, clusters, ax=None, binsize=3, **kwargs):
                fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(5.845, 4.135))
                self._filterForStm(laser=0)
                ax1 = super(OptoClusterSummary, self).plotSAC(tetrode, clusters, ax=ax1, binsize=3, **kwargs)
                ax1.set_xlabel(&#39;Laser off&#39;)
                self._filterForStm(laser=1)
                ax2 = super(OptoClusterSummary, self).plotSAC(tetrode, clusters, ax=ax2, binsize=3, **kwargs)
                ax2.set_xlabel(&#39;Laser on&#39;)

        def plotLaserPhasesFreqVSpeed(self, minSp=5, maxSp=50, spStep=5, ax=None, laserFilter=None, **kwargs):
                &#39;&#39;&#39;
                Plots both phases for an opto trial ie laser on *and* off on same axes
                Scales axes so y is same on both
                Note that kwargs can contain values that affect the filtering of the EEG
                such as &#39;width&#39;, &#39;dip&#39; and &#39;stimFreq&#39; which will change the coefficients of
                the Kaisser filter
                &#39;&#39;&#39;
                fig, (ax1, ax2) = plt.subplots(nrows=2, ncols=1, figsize=(4.135, 5.845))
                self._filterForStm(laser=0)
                ax1, intercept, slope = super(OptoClusterSummary, self).plotFreqVSpeed(minSp=minSp, maxSp=maxSp, spStep=spStep, ax=ax1, laserFilter=None, **kwargs)
                ax1.set_title(&#39;Laser off\nIntercept: {0:.3f}    Slope: {1:.5f}&#39;.format(intercept, slope))
                self._filterForStm(laser=1)
                sf = self.getStimFreq()
                ax2, intercept, slope = super(OptoClusterSummary, self).plotFreqVSpeed(minSp=minSp, maxSp=maxSp, spStep=spStep, ax=ax2, laserFilter=True, stimFreq=sf, **kwargs)
                ax2.set_title(&#39;Laser on\nIntercept: {0:.3f}    Slope: {1:.5f}&#39;.format(intercept, slope))
                ax1ylims = ax1.get_ylim()
                ax2ylims = ax2.get_ylim()
                ylims = (np.min((ax1ylims, ax2ylims)), np.max((ax1ylims, ax2ylims)))
                ax1.set_ylim(ylims)
                ax2.set_ylim(ylims)
                ax1.set_xlabel(&#39;&#39;)
                ax1.tick_params(axis=&#39;x&#39;,which=&#39;both&#39;, bottom=&#39;off&#39;, labelbottom=&#39;off&#39;)

        def plotFreqVSpeed(self, minSp=5, maxSp=50, spStep=5, ax=None, laser=None, **kwargs):
                &#39;&#39;&#39;
                Overrides the same method in the Trial class by filtering for
                presence/ absence of laser stimulation and modifying the title
                of the resulting plot to say whether laser was on /off / 
                not present (nothing added to title)
                &#39;&#39;&#39;
                self._filterForStm(laser)
                ax, intercept, slope = super(OptoClusterSummary, self).plotFreqVSpeed(minSp=minSp, maxSp=maxSp, spStep=spStep, ax=ax, **kwargs)
                if laser == 1:
                        ax.set_title(&#39;Laser on\nIntercept: {0:.3f}    Slope: {1:.5f}&#39;.format(intercept, slope))
                elif laser == 0:
                        ax.set_title(&#39;Laser off\nIntercept: {0:.3f}    Slope: {1:.5f}&#39;.format(intercept, slope))
                else:
                        ax.set_title(&#39;Intercept: {0:.3f}    Slope: {1:.5f}&#39;.format(intercept, slope))
                return ax

        def plotLaserPhasesEEGPower(self, width=0.125, dip=15.0, laserFilter=True):
                &#39;&#39;&#39;
                Overrides the same method in the Trial class by filtering for
                presence/ absence of laser stimulation and modifying the title
                of the resulting plot to say whether laser was on /off / 
                not present (nothing added to title)
                &#39;&#39;&#39;
                EE = EEGCalcs(self.filename_root,thetaRange=[6,12])
                self._filterForStm(laser=0)
                if np.ma.is_masked(self.EEG.eeg):
                        eeg = np.ma.compressed(self.EEG.eeg)
                else:
                        eeg = self.EEG.eeg
#        if laserFilter:
#            sf = self.getStimFreq()
#            fx = EE.filterForLaser(E=eeg, width=width, dip=dip, stimFreq=sf)
#        else:
#            fx = eeg
                fx = eeg
                fig, (ax1, ax2) = plt.subplots(nrows=2, ncols=1, figsize=(4.135, 5.845))
                ax1 = super(OptoClusterSummary, self).plotEEGPower(E=fx, sample_rate=250.0, freqBand=(6,12), ax=ax1)
                ax1.set_title(&#34;Laser off\nwidth = {0}, dip = {1}&#34;.format(width, dip))
                ax1.set_xlabel(&#39;&#39;)
                ax1.tick_params(axis=&#39;x&#39;,which=&#39;both&#39;, bottom=&#39;off&#39;, labelbottom=&#39;off&#39;)

                self._filterForStm(laser=1)
                if np.ma.is_masked(self.EEG.eeg):
                        eeg = np.ma.compressed(self.EEG.eeg)
                else:
                        eeg = self.EEG.eeg
                if laserFilter:
                        sf = self.getStimFreq()
                        fx = EE.filterForLaser(E=eeg, width=width, dip=dip, stimFreq=sf)
                else:
                        fx = eeg
                ax2 = super(OptoClusterSummary, self).plotEEGPower(E=fx, sample_rate=250.0, freqBand=(6,12), ax=ax2)
                ax2.set_title(&#34;Laser on\nwidth = {0}, dip = {1}&#34;.format(width, dip))

        def getStimFreq(self):
                &#39;&#39;&#39;
                Looks in the STM dict and calculates the stimulation frequency in Hz
                Note that at the moment this only returns the first phase that isn&#39;t a
                &#39;Pause (no stimulation)&#39; phase i.e. if multiple stimulation phases are 
                used this (and other functions) will need re-writing
                &#39;&#39;&#39;
                if self.STM:
                        for phase in self.STM[&#39;stim_params&#39;]:
                                if &#39;Pause&#39; not in self.STM[&#39;stim_params&#39;][phase][&#39;name&#39;]:
                                        pulsePause = self.STM[&#39;stim_params&#39;][phase][&#39;pulsePause&#39;]
                                        pulseWidth = self.STM[&#39;stim_params&#39;][phase][&#39;pulseWidth&#39;]
                                        stimFreq = (float(pulseWidth) / pulsePause) * 100
                                        return stimFreq

        def read_yaml(self):
                &#34;&#34;&#34;
                method to read data in from a yaml file
                &#34;&#34;&#34;
                yaml_file = r&#39;/media/robin/data/Dropbox/Science/Analysis/Mouse optogenetics/SST_Cre_grid_cell_project/grid_cell.yaml&#39;
                stream = open(yaml_file, &#39;r&#39;)
                yaml_data = yaml.load_all(stream)
                return yaml_data

        def plot(self):
                &#34;&#34;&#34;
                main plotting method
                &#34;&#34;&#34;
                savedir = r&#39;/home/robin/Desktop&#39;
                plot_items = ([&#39;plotClusterSpace&#39;, &#39;plotWaveforms&#39;, &#39;plotXCorr&#39;,
                                          &#39;plotEEGPower&#39;, &#39;plotMap&#39;, &#39;plotFullSAC&#39;,
                                          &#39;plotRaster&#39;, &#39;plot_event_EEG&#39;])
                n_rows = 4
                n_cols = 2
                for i, tet_clust in enumerate(zip(self.tetrodes, self.clusters)):
                        fig = plt.figure(figsize=(4.135, 11.6))  # A4 landscape
                        for idx, item in enumerate(plot_items):
                                ax = fig.add_subplot(n_rows, n_cols, idx+1, frame_on=True)
                                ax.axis(&#39;off&#39;)
                                rect = ax.get_position().bounds
                                if &#39;XCorr&#39; in item:
                                        ax.axis(&#39;on&#39;)
                                if np.logical_or(&#39;Cluster&#39; in item, &#39;Wave&#39; in item):
                                        ax.axis(frame_on=False)
                                        eval(&#39;self.&#39; + item + &#39;(tetrode=tet_clust[0], clusters=tet_clust[1], ax=ax, figure=fig)&#39;)
                                elif np.logical_or(&#39;Raster&#39; in item, &#39;EEG&#39; in item):
                                        ax.axis(frame_on=True)
                                        ax.axis(&#39;on&#39;)
                                        eval(&#34;self.&#34; + item + &#34;(tetrode=tet_clust[0], clusters=tet_clust[1],  ax=ax)&#34;)
                                else:
                                        eval(&#39;self.&#39; + item + &#39;(tetrode=tet_clust[0], clusters=tet_clust[1], ax=ax)&#39;)
                        fig.text(0.5, 0.95, (os.path.split(self.filename_root)[-1] + &#39;\nTetrode: &#39; +
                                                                str(tet_clust[0]) + &#39; Cluster: &#39; + str(tet_clust[1])),
                                                                transform = fig.transFigure, fontsize=20,
                                                                va=&#39;top&#39;, ha=&#39;center&#39;)
                        fig.subplots_adjust(hspace=0.5, wspace=0.5)
                        fig.savefig(os.path.join(savedir, (os.path.split(self.filename_root)[-1] + &#39;_t&#39; + str(tet_clust[0])
                                                                                                + &#39;_c&#39; + str(tet_clust[1]) + &#39;.png&#39;)))
                plt.show()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ephysiopy.dacq2py.dacq2py_util.Trial" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial">Trial</a></li>
<li><a title="ephysiopy.dacq2py.axonaIO.IO" href="axonaIO.html#ephysiopy.dacq2py.axonaIO.IO">IO</a></li>
<li><a title="ephysiopy.ephys_generic.gridcell.SAC" href="../ephys_generic/gridcell.html#ephysiopy.ephys_generic.gridcell.SAC">SAC</a></li>
<li>builtins.dict</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.getFiringRateDuringLaser"><code class="name flex">
<span>def <span class="ident">getFiringRateDuringLaser</span></span>(<span>self, tet, clust, n=50)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a number which is the difference divided by the sum of the mean firing rate
in the 50ms (or n ms) prior to laser onset and the firing rate during the stim period</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">        def getFiringRateDuringLaser(self, tet, clust, n=50):
                &#39;&#39;&#39;
                Returns a number which is the difference divided by the sum of the mean firing rate
                in the 50ms (or n ms) prior to laser onset and the firing rate during the stim period
                &#39;&#39;&#39;
                spkTimes_ms = self.TETRODE[tet].getClustTS(clust) / (self.TETRODE[tet].timebase / 1000)
                spkTimes_ms.sort()
                stm_timebase = int(self.STM[&#39;timebase&#39;].split()[0])
                stm_on = self.STM[&#39;on&#39;] / float(stm_timebase) * 1000
                stm_on.sort()
                stm_off = self.STM[&#39;off&#39;] / float(stm_timebase) * 1000
#        stm_off.sort()
                Trange_to_onset = np.array([-n, 0])
                Trange_to_offset = np.array([0, 10])
                irange_to_onset = spkTimes_ms[:, np.newaxis] + Trange_to_onset[np.newaxis, :]
                irange_to_offset = spkTimes_ms[:, np.newaxis] + Trange_to_offset[np.newaxis, :]
                dts_to_onset = np.searchsorted(stm_on, irange_to_onset)
                dts_to_offset = np.searchsorted(stm_on, irange_to_offset)
                counts_to_onset = []
                counts_to_offset = []
                for i, t in enumerate(dts_to_onset):
                        counts_to_onset.extend(stm_on[t[0]:t[1]] - spkTimes_ms[i])
                for i, t in enumerate(dts_to_offset):
                        counts_to_offset.extend(stm_on[t[0]:t[1]] - spkTimes_ms[i])
                before_rate = np.mean(np.abs(counts_to_offset))
                after_rate = np.mean(np.abs(counts_to_onset))
                change = float(before_rate - after_rate) / float(before_rate + after_rate)
                return before_rate, after_rate,change</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.getStimFreq"><code class="name flex">
<span>def <span class="ident">getStimFreq</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Looks in the STM dict and calculates the stimulation frequency in Hz
Note that at the moment this only returns the first phase that isn't a
'Pause (no stimulation)' phase i.e. if multiple stimulation phases are
used this (and other functions) will need re-writing</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getStimFreq(self):
        &#39;&#39;&#39;
        Looks in the STM dict and calculates the stimulation frequency in Hz
        Note that at the moment this only returns the first phase that isn&#39;t a
        &#39;Pause (no stimulation)&#39; phase i.e. if multiple stimulation phases are 
        used this (and other functions) will need re-writing
        &#39;&#39;&#39;
        if self.STM:
                for phase in self.STM[&#39;stim_params&#39;]:
                        if &#39;Pause&#39; not in self.STM[&#39;stim_params&#39;][phase][&#39;name&#39;]:
                                pulsePause = self.STM[&#39;stim_params&#39;][phase][&#39;pulsePause&#39;]
                                pulseWidth = self.STM[&#39;stim_params&#39;][phase][&#39;pulseWidth&#39;]
                                stimFreq = (float(pulseWidth) / pulsePause) * 100
                                return stimFreq</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>main plotting method</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self):
        &#34;&#34;&#34;
        main plotting method
        &#34;&#34;&#34;
        savedir = r&#39;/home/robin/Desktop&#39;
        plot_items = ([&#39;plotClusterSpace&#39;, &#39;plotWaveforms&#39;, &#39;plotXCorr&#39;,
                                  &#39;plotEEGPower&#39;, &#39;plotMap&#39;, &#39;plotFullSAC&#39;,
                                  &#39;plotRaster&#39;, &#39;plot_event_EEG&#39;])
        n_rows = 4
        n_cols = 2
        for i, tet_clust in enumerate(zip(self.tetrodes, self.clusters)):
                fig = plt.figure(figsize=(4.135, 11.6))  # A4 landscape
                for idx, item in enumerate(plot_items):
                        ax = fig.add_subplot(n_rows, n_cols, idx+1, frame_on=True)
                        ax.axis(&#39;off&#39;)
                        rect = ax.get_position().bounds
                        if &#39;XCorr&#39; in item:
                                ax.axis(&#39;on&#39;)
                        if np.logical_or(&#39;Cluster&#39; in item, &#39;Wave&#39; in item):
                                ax.axis(frame_on=False)
                                eval(&#39;self.&#39; + item + &#39;(tetrode=tet_clust[0], clusters=tet_clust[1], ax=ax, figure=fig)&#39;)
                        elif np.logical_or(&#39;Raster&#39; in item, &#39;EEG&#39; in item):
                                ax.axis(frame_on=True)
                                ax.axis(&#39;on&#39;)
                                eval(&#34;self.&#34; + item + &#34;(tetrode=tet_clust[0], clusters=tet_clust[1],  ax=ax)&#34;)
                        else:
                                eval(&#39;self.&#39; + item + &#39;(tetrode=tet_clust[0], clusters=tet_clust[1], ax=ax)&#39;)
                fig.text(0.5, 0.95, (os.path.split(self.filename_root)[-1] + &#39;\nTetrode: &#39; +
                                                        str(tet_clust[0]) + &#39; Cluster: &#39; + str(tet_clust[1])),
                                                        transform = fig.transFigure, fontsize=20,
                                                        va=&#39;top&#39;, ha=&#39;center&#39;)
                fig.subplots_adjust(hspace=0.5, wspace=0.5)
                fig.savefig(os.path.join(savedir, (os.path.split(self.filename_root)[-1] + &#39;_t&#39; + str(tet_clust[0])
                                                                                        + &#39;_c&#39; + str(tet_clust[1]) + &#39;.png&#39;)))
        plt.show()</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotAllPhases"><code class="name flex">
<span>def <span class="ident">plotAllPhases</span></span>(<span>self, tet, clusts, savename=None, var2bin='pos', vmax='auto')</span>
</code></dt>
<dd>
<section class="desc"><p>Plots all phases i.e. A, B A'</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">        def plotAllPhases(self, tet, clusts, savename=None, var2bin=&#39;pos&#39;,vmax=&#39;auto&#39;):
                &#39;&#39;&#39;
                Plots all phases i.e. A, B A&#39;
                &#39;&#39;&#39;
                if &#39;dir&#39; in var2bin:
                        fig, axes = plt.subplots(nrows=1, ncols=3, figsize=(5.845, 4.135),subplot_kw={&#34;projection&#34;:&#34;polar&#34;})
                else:
                        fig, axes = plt.subplots(nrows=1, ncols=3, figsize=(5.845, 4.135))
                ax0 = axes[0]
                ax1 = axes[1]
                ax2 = axes[2]
                self._filterForStm(laser=0)
                # Split the posFilter into A and A&#39;
                phaseA = self.posFilter[&#39;time&#39;][0,:] / 50
                phaseAprime = self.posFilter[&#39;time&#39;][1,:] / 50

                # normalizing the ratemaps has to be done in a two-pass operation
                # first-pass - get ratemap
                self.posFilter = {&#39;time&#39;: phaseA}
                rmap0 = self._getMap(tet, clusts)[0]
                self.posFilter = {&#39;time&#39;: phaseAprime}
                rmap2 = self._getMap(tet, clusts)[0]
                self._filterForStm(laser=1)
                rmap1 = self._getMap(tet, clusts)[0]
                # get the max value in all ratemaps to scale the others
                if &#39;auto&#39; in vmax:
                        vmax = np.nanmax([rmap0.ravel(), rmap1.ravel(), rmap2.ravel()])
                        vmax1 = vmax
                        vmax2 = vmax
                else:
                        vmax = np.nanmax(rmap0.ravel())
                        vmax1 = np.nanmax(rmap1.ravel())
                        vmax2 = np.nanmax(rmap2.ravel())
#               vmax=10.0
                print(&#39;vmax = {}&#39;.format(vmax))
                self.posFilter = {&#39;time&#39;: phaseA}
                ax0, rmap0 = super(OptoClusterSummary, self)._plotMap(tet, clusts, ax=ax0, var2bin=var2bin, binsize=3, smooth_sz=5, smooth=True,vmax=vmax,add_mrv=True)
                self.posFilter = {&#39;time&#39;: phaseAprime}
                ax2, rmap2 = super(OptoClusterSummary, self)._plotMap(tet, clusts, ax=ax2, var2bin=var2bin, binsize=3, smooth_sz=5, smooth=True,vmax=vmax1,add_mrv=True)
                self._filterForStm(laser=1)
                ax1, rmap1 = super(OptoClusterSummary, self)._plotMap(tet, clusts, ax=ax1, var2bin=var2bin, binsize=3, smooth_sz=5, smooth=True,vmax=vmax2,add_mrv=True)

                # annotate the figure with arrows and correlation values
                # get the correlation values
                A_vs_Aprime = self.fieldcalcs.corr_maps(rmap0, rmap2)
                A_vs_B = self.fieldcalcs.corr_maps(rmap0, rmap1)
                Aprime_vs_B = self.fieldcalcs.corr_maps(rmap2, rmap1)
                arrow_args = dict(arrowstyle=&#39;|-|&#39;, connectionstyle=&#34;Bar,armA=2,armB=2,fraction=.2&#34;)
                ax1.annotate(&#39;&#39;, xy=(0.5, 1.05), xycoords=ax0.transAxes,
                                  xytext=(0.5,1.05), textcoords=ax1.transAxes, arrowprops=arrow_args)
                ax2.annotate(&#39;&#39;, xy=(0.5, 1.05), xycoords=ax1.transAxes,
                                  xytext=(0.5,1.05), textcoords=ax2.transAxes, arrowprops=arrow_args)
                arrow_args = dict(arrowstyle=&#39;|-|&#39;, connectionstyle=&#34;Bar,armA=2,armB=2,fraction=-.1&#34;)
                ax2.annotate(&#39;&#39;, xy=(0.5, -0.025), xycoords=ax0.transAxes,
                                  xytext=(0.5,-0.025), textcoords=ax2.transAxes, arrowprops=arrow_args)
                ax0.text(1.0,1.4,&#39;{:.2f}&#39;.format(A_vs_B),transform=ax0.transAxes)
                ax1.text(1.0,1.4,&#39;{:.2f}&#39;.format(Aprime_vs_B),transform=ax1.transAxes)
                ax1.text(0.5,-.4,&#39;{:.2f}&#39;.format(A_vs_Aprime),transform=ax1.transAxes,ha=&#39;center&#39;)
                if savename is not None:
                        fig.savefig(savename)
                return fig</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotAllPhasesXCorr"><code class="name flex">
<span>def <span class="ident">plotAllPhasesXCorr</span></span>(<span>self, tet, clust, savename=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotAllPhasesXCorr(self, tet, clust, savename=None):
        fig, axes = plt.subplots(nrows=1, ncols=3, figsize=(5.845, 4.135))
        ax0 = axes[0]
        ax1 = axes[1]
        ax2 = axes[2]
        self._filterForStm(laser=0)
        # Split the posFilter into A and A&#39;
        phaseA = self.posFilter[&#39;time&#39;][0,:] / 50
        phaseAprime = self.posFilter[&#39;time&#39;][1,:] / 50

        self.posFilter = {&#39;time&#39;: phaseA}
        ax0, xcorr0 = super(OptoClusterSummary, self).plotXCorr(tet, clust, ax=ax0, annotate=False)
        self.posFilter = {&#39;time&#39;: phaseAprime}
        ax2, xcorr2 = super(OptoClusterSummary, self).plotXCorr(tet, clust, ax=ax2, annotate=False)
        self._filterForStm(laser=1)
        ax1, xcorr1 = super(OptoClusterSummary, self).plotXCorr(tet, clust, ax=ax1, annotate=False)
        A_vs_Aprime = self.fieldcalcs.corr_maps(xcorr0[0], xcorr2[0])
        A_vs_B = self.fieldcalcs.corr_maps(xcorr0[0], xcorr1[0])
        Aprime_vs_B = self.fieldcalcs.corr_maps(xcorr2[0], xcorr1[0])
        arrow_args = dict(arrowstyle=&#39;|-|&#39;, connectionstyle=&#34;Bar,armA=2,armB=2,fraction=.2&#34;)
        ax1.annotate(&#39;&#39;, xy=(0.5, 1.05), xycoords=ax0.transAxes,
                          xytext=(0.5,1.05), textcoords=ax1.transAxes, arrowprops=arrow_args)
        ax2.annotate(&#39;&#39;, xy=(0.5, 1.05), xycoords=ax1.transAxes,
                          xytext=(0.5,1.05), textcoords=ax2.transAxes, arrowprops=arrow_args)
        arrow_args = dict(arrowstyle=&#39;|-|&#39;, connectionstyle=&#34;Bar,armA=2,armB=2,fraction=-.1&#34;)
        ax2.annotate(&#39;&#39;, xy=(0.5, -0.025), xycoords=ax0.transAxes,
                          xytext=(0.5,-0.025), textcoords=ax2.transAxes, arrowprops=arrow_args)
        ax0.text(1.0,1.4,&#39;{:.2f}&#39;.format(A_vs_B),transform=ax0.transAxes)
        ax1.text(1.0,1.4,&#39;{:.2f}&#39;.format(Aprime_vs_B),transform=ax1.transAxes)
        ax1.text(0.5,-.4,&#39;{:.2f}&#39;.format(A_vs_Aprime),transform=ax1.transAxes,ha=&#39;center&#39;)
        if savename is not None:
                fig.savefig(savename)
        return fig</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotAllSpeedVsRate"><code class="name flex">
<span>def <span class="ident">plotAllSpeedVsRate</span></span>(<span>self, tet, clust)</span>
</code></dt>
<dd>
<section class="desc"><p>plots the speed vs rate graphs for all three sections of a stim
trial on the same line graph</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">        def plotAllSpeedVsRate(self, tet, clust):
                &#39;&#39;&#39;
                plots the speed vs rate graphs for all three sections of a stim
                trial on the same line graph
                &#39;&#39;&#39;
                fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(4.135, 5.845))
                self._filterForStm(laser=0)
                # Split the posFilter into A and A&#39;
                phaseA = self.posFilter[&#39;time&#39;][0,:] / 50
                phaseAprime = self.posFilter[&#39;time&#39;][1,:] / 50
                self.posFilter = {&#39;time&#39;: phaseA}
                res, spd_binsA, mn_rateA = self.plotRateVSpeed(tet,clust,plot=False, getData=True)
#               ax.plot(spd_binsA, mn_rateA, &#39;k&#39;)
                self.posFilter = {&#39;time&#39;: phaseAprime}
                res, spd_binsAp, mn_rateAp = self.plotRateVSpeed(tet,clust,plot=False, getData=True)
#               ax.plot(spd_binsAp, mn_rateAp, &#39;k--&#39;)
                self._filterForStm(laser=1)
                res, spd_binsB, mn_rateB = self.plotRateVSpeed(tet,clust,plot=False, getData=True)
                line0, = ax.plot(spd_binsA, mn_rateA, &#39;k&#39;)
                line1, = ax.plot(spd_binsAp, mn_rateAp, &#39;k--&#39;)
                line2, = ax.plot(spd_binsB, mn_rateB, &#39;b--&#39;)

                ax.set_ylabel(&#34;Firing rate(Hz)&#34;)
                ax.set_xlabel(&#34;Speed(cm/s)&#34;)
                ylabels = ax.get_yticklabels()
                for i in range(1, len(ylabels)-1):
                        ylabels[i].set_visible(False)
                yticks = ax.get_yticklines()
                for i in range(1, len(yticks)-1):
                        yticks[i].set_visible(False)
                xlabels = ax.get_xticklabels()
                for i in range(1, len(xlabels)-1):
                        xlabels[i].set_visible(False)
                xticks = ax.get_xticklines()
                for i in range(1, len(xticks)-1):
                        xticks[i].set_visible(False)
                ax.spines[&#39;right&#39;].set_visible(False)
                ax.spines[&#39;top&#39;].set_visible(False)
                ax.yaxis.set_ticks_position(&#39;left&#39;)
                ax.xaxis.set_ticks_position(&#39;bottom&#39;)
                ax.legend((line0,line2,line1),[&#39;Laser off (1)&#39;,&#39;Laser on&#39;,&#39;Laser off (2)&#39;],loc=2)
                return fig</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotFiringRateChange"><code class="name flex">
<span>def <span class="ident">plotFiringRateChange</span></span>(<span>self, tet, clust, n=50)</span>
</code></dt>
<dd>
<section class="desc"><p>Produces a bar graph of the firing rate in the n ms before laser onset
and 50 ms after laser offset
TODO: THIS IS BROKEN</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">        def plotFiringRateChange(self, tet, clust, n=50):
                &#39;&#39;&#39;
                Produces a bar graph of the firing rate in the n ms before laser onset
                and 50 ms after laser offset
                TODO: THIS IS BROKEN
                &#39;&#39;&#39;
                spkTimes_ms = self.TETRODE[tet].getClustTS(clust) / (self.TETRODE[tet].timebase / 1000)
                spkTimes_ms.sort()
                stm_timebase = int(self.STM[&#39;timebase&#39;].split()[0])
                stm_on = self.STM[&#39;on&#39;] / float(stm_timebase) * 1000
                stm_on.sort()
                stm_off = self.STM[&#39;off&#39;] / float(stm_timebase) * 1000
#        stm_off.sort()
                Trange_to_onset = np.array([-n, 0])
                Trange_to_offset = np.array([0, n])
                irange_to_onset = spkTimes_ms[:, np.newaxis] + Trange_to_onset[np.newaxis, :]
                irange_to_offset = spkTimes_ms[:, np.newaxis] + Trange_to_offset[np.newaxis, :]
                dts_to_onset = np.searchsorted(stm_on, irange_to_onset)
                dts_to_offset = np.searchsorted(stm_off, irange_to_offset)
                counts_to_onset = []
                counts_to_offset = []
                for i, t in enumerate(dts_to_onset):
                        counts_to_onset.extend(stm_on[t[0]:t[1]] - spkTimes_ms[i])
                for i, t in enumerate(dts_to_offset):
                        counts_to_offset.extend(stm_off[t[0]:t[1]] - spkTimes_ms[i])

                print(&#39;\nMean firing rate {0}ms before laser = {1:.2f} Hz&#39;.format(n, np.mean(np.abs(counts_to_offset))))
                print(&#39;Mean firing rate {0}ms after laser  = {1:.2f} Hz&#39;.format(n, np.mean(np.abs(counts_to_onset))))

                return counts_to_onset, counts_to_offset</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotFreqVSpeed"><code class="name flex">
<span>def <span class="ident">plotFreqVSpeed</span></span>(<span>self, minSp=5, maxSp=50, spStep=5, ax=None, laser=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Overrides the same method in the Trial class by filtering for
presence/ absence of laser stimulation and modifying the title
of the resulting plot to say whether laser was on /off /
not present (nothing added to title)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotFreqVSpeed(self, minSp=5, maxSp=50, spStep=5, ax=None, laser=None, **kwargs):
        &#39;&#39;&#39;
        Overrides the same method in the Trial class by filtering for
        presence/ absence of laser stimulation and modifying the title
        of the resulting plot to say whether laser was on /off / 
        not present (nothing added to title)
        &#39;&#39;&#39;
        self._filterForStm(laser)
        ax, intercept, slope = super(OptoClusterSummary, self).plotFreqVSpeed(minSp=minSp, maxSp=maxSp, spStep=spStep, ax=ax, **kwargs)
        if laser == 1:
                ax.set_title(&#39;Laser on\nIntercept: {0:.3f}    Slope: {1:.5f}&#39;.format(intercept, slope))
        elif laser == 0:
                ax.set_title(&#39;Laser off\nIntercept: {0:.3f}    Slope: {1:.5f}&#39;.format(intercept, slope))
        else:
                ax.set_title(&#39;Intercept: {0:.3f}    Slope: {1:.5f}&#39;.format(intercept, slope))
        return ax</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotLaserFilteredSpectrogram"><code class="name flex">
<span>def <span class="ident">plotLaserFilteredSpectrogram</span></span>(<span>self, eeg_file='eeg', ymax=50, ax=None, secsPerBin=2, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotLaserFilteredSpectrogram(self, eeg_file=&#39;eeg&#39;, ymax=50, ax=None, secsPerBin=2, **kwargs):
        pass</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotLaserPhasesEEGPower"><code class="name flex">
<span>def <span class="ident">plotLaserPhasesEEGPower</span></span>(<span>self, width=0.125, dip=15.0, laserFilter=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Overrides the same method in the Trial class by filtering for
presence/ absence of laser stimulation and modifying the title
of the resulting plot to say whether laser was on /off /
not present (nothing added to title)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">        def plotLaserPhasesEEGPower(self, width=0.125, dip=15.0, laserFilter=True):
                &#39;&#39;&#39;
                Overrides the same method in the Trial class by filtering for
                presence/ absence of laser stimulation and modifying the title
                of the resulting plot to say whether laser was on /off / 
                not present (nothing added to title)
                &#39;&#39;&#39;
                EE = EEGCalcs(self.filename_root,thetaRange=[6,12])
                self._filterForStm(laser=0)
                if np.ma.is_masked(self.EEG.eeg):
                        eeg = np.ma.compressed(self.EEG.eeg)
                else:
                        eeg = self.EEG.eeg
#        if laserFilter:
#            sf = self.getStimFreq()
#            fx = EE.filterForLaser(E=eeg, width=width, dip=dip, stimFreq=sf)
#        else:
#            fx = eeg
                fx = eeg
                fig, (ax1, ax2) = plt.subplots(nrows=2, ncols=1, figsize=(4.135, 5.845))
                ax1 = super(OptoClusterSummary, self).plotEEGPower(E=fx, sample_rate=250.0, freqBand=(6,12), ax=ax1)
                ax1.set_title(&#34;Laser off\nwidth = {0}, dip = {1}&#34;.format(width, dip))
                ax1.set_xlabel(&#39;&#39;)
                ax1.tick_params(axis=&#39;x&#39;,which=&#39;both&#39;, bottom=&#39;off&#39;, labelbottom=&#39;off&#39;)

                self._filterForStm(laser=1)
                if np.ma.is_masked(self.EEG.eeg):
                        eeg = np.ma.compressed(self.EEG.eeg)
                else:
                        eeg = self.EEG.eeg
                if laserFilter:
                        sf = self.getStimFreq()
                        fx = EE.filterForLaser(E=eeg, width=width, dip=dip, stimFreq=sf)
                else:
                        fx = eeg
                ax2 = super(OptoClusterSummary, self).plotEEGPower(E=fx, sample_rate=250.0, freqBand=(6,12), ax=ax2)
                ax2.set_title(&#34;Laser on\nwidth = {0}, dip = {1}&#34;.format(width, dip))</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotLaserPhasesFreqVSpeed"><code class="name flex">
<span>def <span class="ident">plotLaserPhasesFreqVSpeed</span></span>(<span>self, minSp=5, maxSp=50, spStep=5, ax=None, laserFilter=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots both phases for an opto trial ie laser on <em>and</em> off on same axes
Scales axes so y is same on both
Note that kwargs can contain values that affect the filtering of the EEG
such as 'width', 'dip' and 'stimFreq' which will change the coefficients of
the Kaisser filter</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotLaserPhasesFreqVSpeed(self, minSp=5, maxSp=50, spStep=5, ax=None, laserFilter=None, **kwargs):
        &#39;&#39;&#39;
        Plots both phases for an opto trial ie laser on *and* off on same axes
        Scales axes so y is same on both
        Note that kwargs can contain values that affect the filtering of the EEG
        such as &#39;width&#39;, &#39;dip&#39; and &#39;stimFreq&#39; which will change the coefficients of
        the Kaisser filter
        &#39;&#39;&#39;
        fig, (ax1, ax2) = plt.subplots(nrows=2, ncols=1, figsize=(4.135, 5.845))
        self._filterForStm(laser=0)
        ax1, intercept, slope = super(OptoClusterSummary, self).plotFreqVSpeed(minSp=minSp, maxSp=maxSp, spStep=spStep, ax=ax1, laserFilter=None, **kwargs)
        ax1.set_title(&#39;Laser off\nIntercept: {0:.3f}    Slope: {1:.5f}&#39;.format(intercept, slope))
        self._filterForStm(laser=1)
        sf = self.getStimFreq()
        ax2, intercept, slope = super(OptoClusterSummary, self).plotFreqVSpeed(minSp=minSp, maxSp=maxSp, spStep=spStep, ax=ax2, laserFilter=True, stimFreq=sf, **kwargs)
        ax2.set_title(&#39;Laser on\nIntercept: {0:.3f}    Slope: {1:.5f}&#39;.format(intercept, slope))
        ax1ylims = ax1.get_ylim()
        ax2ylims = ax2.get_ylim()
        ylims = (np.min((ax1ylims, ax2ylims)), np.max((ax1ylims, ax2ylims)))
        ax1.set_ylim(ylims)
        ax2.set_ylim(ylims)
        ax1.set_xlabel(&#39;&#39;)
        ax1.tick_params(axis=&#39;x&#39;,which=&#39;both&#39;, bottom=&#39;off&#39;, labelbottom=&#39;off&#39;)</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotLaserPhasesRatemap"><code class="name flex">
<span>def <span class="ident">plotLaserPhasesRatemap</span></span>(<span>self, tet, clusts, var2bin='pos', binsize=3, smooth_sz=5, smooth=True, laser=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotLaserPhasesRatemap(self, tet, clusts, var2bin=&#39;pos&#39;, binsize=3,
                        smooth_sz=5, smooth=True, laser=None, **kwargs):
        fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(5.845, 4.135))
        self._filterForStm(laser=0)
        ax1, rmap1 = super(OptoClusterSummary, self)._plotMap(tet, clusts, ax=ax1, var2bin=&#39;pos&#39;, binsize=3, smooth_sz=5, smooth=True)
        ax1.set_xlabel(&#39;Laser off&#39;)
        self._filterForStm(laser=1)
        ax2, rmap2 = super(OptoClusterSummary, self)._plotMap(tet, clusts, ax=ax2, var2bin=&#39;pos&#39;, binsize=3, smooth_sz=5, smooth=True)
        ax2.set_xlabel(&#39;Laser on&#39;)</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotLaserPhasesSAC"><code class="name flex">
<span>def <span class="ident">plotLaserPhasesSAC</span></span>(<span>self, tetrode, clusters, ax=None, binsize=3, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotLaserPhasesSAC(self, tetrode, clusters, ax=None, binsize=3, **kwargs):
        fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(5.845, 4.135))
        self._filterForStm(laser=0)
        ax1 = super(OptoClusterSummary, self).plotSAC(tetrode, clusters, ax=ax1, binsize=3, **kwargs)
        ax1.set_xlabel(&#39;Laser off&#39;)
        self._filterForStm(laser=1)
        ax2 = super(OptoClusterSummary, self).plotSAC(tetrode, clusters, ax=ax2, binsize=3, **kwargs)
        ax2.set_xlabel(&#39;Laser on&#39;)</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotLaserPhasesSpeedVsRate"><code class="name flex">
<span>def <span class="ident">plotLaserPhasesSpeedVsRate</span></span>(<span>self, tet, clusts)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotLaserPhasesSpeedVsRate(self, tet, clusts):
        fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(5.845, 4.535))
        self._filterForStm(laser=0)
        super(OptoClusterSummary, self).plotRateVSpeed(tet, clusts, plot=True, ax=ax1)
        ax1.set_xlabel(&#39;Laser off&#39;)
        self._filterForStm(laser=1)
        super(OptoClusterSummary, self).plotRateVSpeed(tet, clusts, plot=True, ax=ax2)
        ax2.set_xlabel(&#39;Laser on&#39;)
        ax2.set_ylabel(&#39;&#39;)</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotLaserPhasesSpikesOnPath"><code class="name flex">
<span>def <span class="ident">plotLaserPhasesSpikesOnPath</span></span>(<span>self, tet, clusts)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotLaserPhasesSpikesOnPath(self, tet, clusts):
        fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(5.845, 4.135))
        self._filterForStm(laser=0)
        ax1 = super(OptoClusterSummary, self).plotSpikesOnPath(tet, clusts, ax=ax1)
        ax1.set_xlabel(&#39;Laser off&#39;)
        self._filterForStm(laser=1)
        ax2 = super(OptoClusterSummary, self).plotSpikesOnPath(tet, clusts, ax=ax2)
        ax2.set_xlabel(&#39;Laser on&#39;)</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.read_yaml"><code class="name flex">
<span>def <span class="ident">read_yaml</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>method to read data in from a yaml file</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_yaml(self):
        &#34;&#34;&#34;
        method to read data in from a yaml file
        &#34;&#34;&#34;
        yaml_file = r&#39;/media/robin/data/Dropbox/Science/Analysis/Mouse optogenetics/SST_Cre_grid_cell_project/grid_cell.yaml&#39;
        stream = open(yaml_file, &#39;r&#39;)
        yaml_data = yaml.load_all(stream)
        return yaml_data</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ephysiopy.dacq2py.dacq2py_util.Trial" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial">Trial</a></b></code>:
<ul class="hlist">
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.EEG" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.EEG">EEG</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.EGF" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.EGF">EGF</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.POS" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.POS">POS</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.STM" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.STM">STM</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.adjust_median_speed" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.adjust_median_speed">adjust_median_speed</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.autoCorr2D" href="../ephys_generic/gridcell.html#ephysiopy.ephys_generic.gridcell.SAC.autoCorr2D">autoCorr2D</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.crossCorr2D" href="../ephys_generic/gridcell.html#ephysiopy.ephys_generic.gridcell.SAC.crossCorr2D">crossCorr2D</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.deformSAC" href="../ephys_generic/gridcell.html#ephysiopy.ephys_generic.gridcell.SAC.deformSAC">deformSAC</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getBorderScore" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getBorderScore">getBorderScore</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getCluCut" href="axonaIO.html#ephysiopy.dacq2py.axonaIO.IO.getCluCut">getCluCut</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getCut" href="axonaIO.html#ephysiopy.dacq2py.axonaIO.IO.getCut">getCut</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getData" href="axonaIO.html#ephysiopy.dacq2py.axonaIO.IO.getData">getData</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getFieldRuns" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getFieldRuns">getFieldRuns</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getFullFile" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getFullFile">getFullFile</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getHeader" href="axonaIO.html#ephysiopy.dacq2py.axonaIO.IO.getHeader">getHeader</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getHeaderVal" href="axonaIO.html#ephysiopy.dacq2py.axonaIO.IO.getHeaderVal">getHeaderVal</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getMeasures" href="../ephys_generic/gridcell.html#ephysiopy.ephys_generic.gridcell.SAC.getMeasures">getMeasures</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getRasterHist" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getRasterHist">getRasterHist</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getThetaModIdx" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getThetaModIdx">getThetaModIdx</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getThetaModIdx2" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getThetaModIdx2">getThetaModIdx2</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getThigmotaxisIndex" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getThigmotaxisIndex">getThigmotaxisIndex</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getTsAndCs" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getTsAndCs">getTsAndCs</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getcircR" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getcircR">getcircR</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getcoherence" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getcoherence">getcoherence</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getgridness" href="../ephys_generic/gridcell.html#ephysiopy.ephys_generic.gridcell.SAC.getgridness">getgridness</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getkldiv" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getkldiv">getkldiv</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getmrv" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getmrv">getmrv</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getorientation" href="../ephys_generic/gridcell.html#ephysiopy.ephys_generic.gridcell.SAC.getorientation">getorientation</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.getskaggsInfo" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.getskaggsInfo">getskaggsInfo</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.hasFiles" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.hasFiles">hasFiles</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.klustakwik" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.klustakwik">klustakwik</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotClusterSpace" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotClusterSpace">plotClusterSpace</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotDirFilteredRmaps" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotDirFilteredRmaps">plotDirFilteredRmaps</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotEEGPower" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotEEGPower">plotEEGPower</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotEventEEGRange" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotEventEEGRange">plotEventEEGRange</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotFullSAC" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotFullSAC">plotFullSAC</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotMap" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotMap">plotMap</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotPath" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotPath">plotPath</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotPhaseInField" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotPhaseInField">plotPhaseInField</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotPhaseOfFiring" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotPhaseOfFiring">plotPhaseOfFiring</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotRaster" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotRaster">plotRaster</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotRateVSpeed" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotRateVSpeed">plotRateVSpeed</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotRollingCorrRateVSpeed" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotRollingCorrRateVSpeed">plotRollingCorrRateVSpeed</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotSAC" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotSAC">plotSAC</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotSpectrogram" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotSpectrogram">plotSpectrogram</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotSpikesOnPath" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotSpikesOnPath">plotSpikesOnPath</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotWaveforms" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotWaveforms">plotWaveforms</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plotXCorr" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plotXCorr">plotXCorr</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.plot_event_EEG" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.plot_event_EEG">plot_event_EEG</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.posFilter" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.posFilter">posFilter</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.print_stim_dict" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.print_stim_dict">print_stim_dict</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.setData" href="axonaIO.html#ephysiopy.dacq2py.axonaIO.IO.setData">setData</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.setHeader" href="axonaIO.html#ephysiopy.dacq2py.axonaIO.IO.setHeader">setHeader</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.setheader" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.setheader">setheader</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.show" href="../ephys_generic/gridcell.html#ephysiopy.ephys_generic.gridcell.SAC.show">show</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.t_win_SAC" href="../ephys_generic/gridcell.html#ephysiopy.ephys_generic.gridcell.SAC.t_win_SAC">t_win_SAC</a></code></li>
<li><code><a title="ephysiopy.dacq2py.dacq2py_util.Trial.tortuosity" href="dacq2py_util.html#ephysiopy.dacq2py.dacq2py_util.Trial.tortuosity">tortuosity</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ephysiopy.dacq2py" href="index.html">ephysiopy.dacq2py</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ephysiopy.dacq2py.OptoCluster.OptoClusterSummary" href="#ephysiopy.dacq2py.OptoCluster.OptoClusterSummary">OptoClusterSummary</a></code></h4>
<ul class="">
<li><code><a title="ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.getFiringRateDuringLaser" href="#ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.getFiringRateDuringLaser">getFiringRateDuringLaser</a></code></li>
<li><code><a title="ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.getStimFreq" href="#ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.getStimFreq">getStimFreq</a></code></li>
<li><code><a title="ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plot" href="#ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plot">plot</a></code></li>
<li><code><a title="ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotAllPhases" href="#ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotAllPhases">plotAllPhases</a></code></li>
<li><code><a title="ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotAllPhasesXCorr" href="#ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotAllPhasesXCorr">plotAllPhasesXCorr</a></code></li>
<li><code><a title="ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotAllSpeedVsRate" href="#ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotAllSpeedVsRate">plotAllSpeedVsRate</a></code></li>
<li><code><a title="ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotFiringRateChange" href="#ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotFiringRateChange">plotFiringRateChange</a></code></li>
<li><code><a title="ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotFreqVSpeed" href="#ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotFreqVSpeed">plotFreqVSpeed</a></code></li>
<li><code><a title="ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotLaserFilteredSpectrogram" href="#ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotLaserFilteredSpectrogram">plotLaserFilteredSpectrogram</a></code></li>
<li><code><a title="ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotLaserPhasesEEGPower" href="#ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotLaserPhasesEEGPower">plotLaserPhasesEEGPower</a></code></li>
<li><code><a title="ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotLaserPhasesFreqVSpeed" href="#ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotLaserPhasesFreqVSpeed">plotLaserPhasesFreqVSpeed</a></code></li>
<li><code><a title="ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotLaserPhasesRatemap" href="#ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotLaserPhasesRatemap">plotLaserPhasesRatemap</a></code></li>
<li><code><a title="ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotLaserPhasesSAC" href="#ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotLaserPhasesSAC">plotLaserPhasesSAC</a></code></li>
<li><code><a title="ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotLaserPhasesSpeedVsRate" href="#ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotLaserPhasesSpeedVsRate">plotLaserPhasesSpeedVsRate</a></code></li>
<li><code><a title="ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotLaserPhasesSpikesOnPath" href="#ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.plotLaserPhasesSpikesOnPath">plotLaserPhasesSpikesOnPath</a></code></li>
<li><code><a title="ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.read_yaml" href="#ephysiopy.dacq2py.OptoCluster.OptoClusterSummary.read_yaml">read_yaml</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>