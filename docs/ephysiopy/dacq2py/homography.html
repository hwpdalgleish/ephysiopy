<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>ephysiopy.dacq2py.homography API documentation</title>
<meta name="description" content="Created on Fri Oct 19 16:20:36 2012 â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ephysiopy.dacq2py.homography</code></h1>
</header>
<section id="section-intro">
<p>Created on Fri Oct 19 16:20:36 2012</p>
<p>@author: robin</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Fri Oct 19 16:20:36 2012

@author: robin
&#34;&#34;&#34;
import numpy as np
from scipy import ndimage

def normalize(points):
        &#34;&#34;&#34; Normalize a collection of points in
        homogeneous coordinates so that last row = 1. &#34;&#34;&#34;
        for row in points:
                row /= points[-1]
        return points

def make_homog(points):
        &#34;&#34;&#34; Convert a set of points (dim*n array) to
        homogeneous coordinates. &#34;&#34;&#34;
        return np.vstack((points,np.ones((1,points.shape[1]))))

def H_from_points(fp,tp):
        &#34;&#34;&#34; Find homography H, such that fp is mapped to tp
        using the linear DLT method. Points are conditioned
        automatically. &#34;&#34;&#34;
        if fp.shape != tp.shape:
                raise RuntimeError(&#34;number of points do not match&#34;)
        # condition points (important for numerical reasons)
        # --from points--
        m = np.mean(fp[:2], axis=1)
        maxstd = max(np.std(fp[:2], axis=1)) + 1e-9
        C1 = np.diag([1/maxstd, 1/maxstd, 1])
        C1[0][2] = -m[0]/maxstd
        C1[1][2] = -m[1]/maxstd
        fp = np.dot(C1,fp)
        # --to points--
        m = np.mean(tp[:2], axis=1)
        maxstd = max(np.std(tp[:2], axis=1)) + 1e-9
        C2 = np.diag([1/maxstd, 1/maxstd, 1])
        C2[0][2] = -m[0]/maxstd
        C2[1][2] = -m[1]/maxstd
        tp = np.dot(C2,tp)
        # create matrix for linear method, 2 rows for each correspondence pair
        nbr_correspondences = fp.shape[1]
        A = np.zeros((2*nbr_correspondences,9))
        for i in range(nbr_correspondences):
                A[2*i] = [-fp[0][i],-fp[1][i],-1,0,0,0,
                          tp[0][i]*fp[0][i],tp[0][i]*fp[1][i],tp[0][i]]
                A[2*i+1] = [0,0,0,-fp[0][i],-fp[1][i],-1,
                          tp[1][i]*fp[0][i],tp[1][i]*fp[1][i],tp[1][i]]
        U,S,V = np.linalg.svd(A)
        H = V[8].reshape((3,3))
        # decondition
        H = np.dot(np.linalg.inv(C2),np.dot(H,C1))
        # normalize and return
        return H / H[2,2]

def Haffine_from_points(pts8):
        &#34;&#34;&#34; find H, affine transformation, such that
                tp is affine transf of fp&#34;&#34;&#34;
        assert len(pts8) == 8

        tp = pts8[0:4];fp = pts8[4:8]

        #condition points
        #-from points-
        m = np.mean(fp[:2], axis=1)
        maxstd = max(np.std(fp[:2], axis=1))
        C1 = np.diag([1/maxstd, 1/maxstd, 1])
        C1[0][2] = -m[0]/maxstd
        C1[1][2] = -m[1]/maxstd
        fp_cond = np.dot(C1,fp)

        #-to points-
        m = np.mean(tp[:2], axis=1)
        C2 = C1.copy() #must use same scaling for both point sets
        C2[0][2] = -m[0]/maxstd
        C2[1][2] = -m[1]/maxstd
        tp_cond = np.dot(C2,tp)

        #conditioned points have mean zero, so translation is zero
        A = np.concatenate((fp_cond[:2],tp_cond[:2]), axis=0)
        U,S,V = np.linalg.svd(A.T)

        #create B and C matrices as Hartley-Zisserman (2:nd ed) p 130.
        tmp = V[:2].T
        B = tmp[:2]
        C = tmp[2:4]

        tmp2 = np.concatenate((np.dot(C,np.linalg.pinv(B)),np.zeros((2,1))), axis=1)
        H = np.vstack((tmp2,[0,0,1]))

        #decondition
        H = np.dot(np.linalg.inv(C2),np.dot(H,C1))

        return H / H[2][2]

def image_in_image(im1,im2,tp):
        &#34;&#34;&#34; put im1 in im2 with an affine transformation
                such that corners are as close to tp as possible.
                tp are homogeneous and counter-clockwise from top left.&#34;&#34;&#34;

        #points to warp from
        m,n = im1.shape[:2]
        fp = np.array([[0,m,m,0],[0,0,n,n],[1,1,1,1]])

        #compute affine transform and apply
        H = Haffine_from_points(tp,fp)
        im1_t = ndimage.affine_transform(im1,H[:2,:2],(H[0,2],H[1,2]),im2.shape[:2])
        alpha = (im1_t &gt; 0)

        return (1-alpha)*im2 + alpha*im1_t

def get_transform_data(pts8, backward=True ):
        &#39;&#39;&#39;This method returns a perspective transform 8-tuple (a,b,c,d,e,f,g,h).

        Use to transform an image:
        X = (a x + b y + c)/(g x + h y + 1)
        Y = (d x + e y + f)/(g x + h y + 1)

        Image.transform: Use 4 source coordinates, followed by 4 corresponding
                destination coordinates. Use backward=True (the default)

        To calculate the destination coordinate of a single pixel, either reverse
                the pts (4 dest, followed by 4 source, backward=True) or use the same
                pts but set backward to False.

        @arg pts8: four source and four corresponding destination coordinates
        @kwarg backward: True to return coefficients for calculating an originating
                position. False to return coefficients for calculating a destination
                coordinate. (Image.transform calculates originating position.)
        &#39;&#39;&#39;
        assert len(pts8) == 8, &#39;Requires a tuple of eight coordinate tuples (x,y)&#39;

        b0,b1,b2,b3,a0,a1,a2,a3 = pts8 if backward else pts8[::-1]

        # CALCULATE THE COEFFICIENTS
        A = np.array([[a0[0], a0[1], 1,     0,     0, 0, -a0[0]*b0[0], -a0[1]*b0[0]],
                           [    0,     0, 0, a0[0], a0[1], 1, -a0[0]*b0[1], -a0[1]*b0[1]],
                           [a1[0], a1[1], 1,     0,     0, 0, -a1[0]*b1[0], -a1[1]*b1[0]],
                           [    0,     0, 0, a1[0], a1[1], 1, -a1[0]*b1[1], -a1[1]*b1[1]],
                           [a2[0], a2[1], 1,     0,     0, 0, -a2[0]*b2[0], -a2[1]*b2[0]],
                           [    0,     0, 0, a2[0], a2[1], 1, -a2[0]*b2[1], -a2[1]*b2[1]],
                           [a3[0], a3[1], 1,     0,     0, 0, -a3[0]*b3[0], -a3[1]*b3[0]],
                           [    0,     0, 0, a3[0], a3[1], 1, -a3[0]*b3[1], -a3[1]*b3[1]]] )

        B = np.array([b0[0], b0[1], b1[0], b1[1], b2[0], b2[1], b3[0], b3[1]])

        C = np.linalg.solve(A, B)
        return C

def transform_pt(pt , coeffs ):
        T = coeffs
        x = (T[0]*pt[0] + T[1]*pt[1] + T[2])/(T[6]*pt[0] + T[7]*pt[1] + 1)
        y = (T[3]*pt[0] + T[4]*pt[1] + T[5])/(T[6]*pt[0] + T[7]*pt[1] + 1)
        return x,y</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ephysiopy.dacq2py.homography.H_from_points"><code class="name flex">
<span>def <span class="ident">H_from_points</span></span>(<span>fp, tp)</span>
</code></dt>
<dd>
<section class="desc"><p>Find homography H, such that fp is mapped to tp
using the linear DLT method. Points are conditioned
automatically.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def H_from_points(fp,tp):
        &#34;&#34;&#34; Find homography H, such that fp is mapped to tp
        using the linear DLT method. Points are conditioned
        automatically. &#34;&#34;&#34;
        if fp.shape != tp.shape:
                raise RuntimeError(&#34;number of points do not match&#34;)
        # condition points (important for numerical reasons)
        # --from points--
        m = np.mean(fp[:2], axis=1)
        maxstd = max(np.std(fp[:2], axis=1)) + 1e-9
        C1 = np.diag([1/maxstd, 1/maxstd, 1])
        C1[0][2] = -m[0]/maxstd
        C1[1][2] = -m[1]/maxstd
        fp = np.dot(C1,fp)
        # --to points--
        m = np.mean(tp[:2], axis=1)
        maxstd = max(np.std(tp[:2], axis=1)) + 1e-9
        C2 = np.diag([1/maxstd, 1/maxstd, 1])
        C2[0][2] = -m[0]/maxstd
        C2[1][2] = -m[1]/maxstd
        tp = np.dot(C2,tp)
        # create matrix for linear method, 2 rows for each correspondence pair
        nbr_correspondences = fp.shape[1]
        A = np.zeros((2*nbr_correspondences,9))
        for i in range(nbr_correspondences):
                A[2*i] = [-fp[0][i],-fp[1][i],-1,0,0,0,
                          tp[0][i]*fp[0][i],tp[0][i]*fp[1][i],tp[0][i]]
                A[2*i+1] = [0,0,0,-fp[0][i],-fp[1][i],-1,
                          tp[1][i]*fp[0][i],tp[1][i]*fp[1][i],tp[1][i]]
        U,S,V = np.linalg.svd(A)
        H = V[8].reshape((3,3))
        # decondition
        H = np.dot(np.linalg.inv(C2),np.dot(H,C1))
        # normalize and return
        return H / H[2,2]</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.homography.Haffine_from_points"><code class="name flex">
<span>def <span class="ident">Haffine_from_points</span></span>(<span>pts8)</span>
</code></dt>
<dd>
<section class="desc"><p>find H, affine transformation, such that
tp is affine transf of fp</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Haffine_from_points(pts8):
        &#34;&#34;&#34; find H, affine transformation, such that
                tp is affine transf of fp&#34;&#34;&#34;
        assert len(pts8) == 8

        tp = pts8[0:4];fp = pts8[4:8]

        #condition points
        #-from points-
        m = np.mean(fp[:2], axis=1)
        maxstd = max(np.std(fp[:2], axis=1))
        C1 = np.diag([1/maxstd, 1/maxstd, 1])
        C1[0][2] = -m[0]/maxstd
        C1[1][2] = -m[1]/maxstd
        fp_cond = np.dot(C1,fp)

        #-to points-
        m = np.mean(tp[:2], axis=1)
        C2 = C1.copy() #must use same scaling for both point sets
        C2[0][2] = -m[0]/maxstd
        C2[1][2] = -m[1]/maxstd
        tp_cond = np.dot(C2,tp)

        #conditioned points have mean zero, so translation is zero
        A = np.concatenate((fp_cond[:2],tp_cond[:2]), axis=0)
        U,S,V = np.linalg.svd(A.T)

        #create B and C matrices as Hartley-Zisserman (2:nd ed) p 130.
        tmp = V[:2].T
        B = tmp[:2]
        C = tmp[2:4]

        tmp2 = np.concatenate((np.dot(C,np.linalg.pinv(B)),np.zeros((2,1))), axis=1)
        H = np.vstack((tmp2,[0,0,1]))

        #decondition
        H = np.dot(np.linalg.inv(C2),np.dot(H,C1))

        return H / H[2][2]</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.homography.get_transform_data"><code class="name flex">
<span>def <span class="ident">get_transform_data</span></span>(<span>pts8, backward=True)</span>
</code></dt>
<dd>
<section class="desc"><p>This method returns a perspective transform 8-tuple (a,b,c,d,e,f,g,h).</p>
<p>Use to transform an image:
X = (a x + b y + c)/(g x + h y + 1)
Y = (d x + e y + f)/(g x + h y + 1)</p>
<p>Image.transform: Use 4 source coordinates, followed by 4 corresponding
destination coordinates. Use backward=True (the default)</p>
<p>To calculate the destination coordinate of a single pixel, either reverse
the pts (4 dest, followed by 4 source, backward=True) or use the same
pts but set backward to False.</p>
<p>@arg pts8: four source and four corresponding destination coordinates
@kwarg backward: True to return coefficients for calculating an originating
position. False to return coefficients for calculating a destination
coordinate. (Image.transform calculates originating position.)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_transform_data(pts8, backward=True ):
        &#39;&#39;&#39;This method returns a perspective transform 8-tuple (a,b,c,d,e,f,g,h).

        Use to transform an image:
        X = (a x + b y + c)/(g x + h y + 1)
        Y = (d x + e y + f)/(g x + h y + 1)

        Image.transform: Use 4 source coordinates, followed by 4 corresponding
                destination coordinates. Use backward=True (the default)

        To calculate the destination coordinate of a single pixel, either reverse
                the pts (4 dest, followed by 4 source, backward=True) or use the same
                pts but set backward to False.

        @arg pts8: four source and four corresponding destination coordinates
        @kwarg backward: True to return coefficients for calculating an originating
                position. False to return coefficients for calculating a destination
                coordinate. (Image.transform calculates originating position.)
        &#39;&#39;&#39;
        assert len(pts8) == 8, &#39;Requires a tuple of eight coordinate tuples (x,y)&#39;

        b0,b1,b2,b3,a0,a1,a2,a3 = pts8 if backward else pts8[::-1]

        # CALCULATE THE COEFFICIENTS
        A = np.array([[a0[0], a0[1], 1,     0,     0, 0, -a0[0]*b0[0], -a0[1]*b0[0]],
                           [    0,     0, 0, a0[0], a0[1], 1, -a0[0]*b0[1], -a0[1]*b0[1]],
                           [a1[0], a1[1], 1,     0,     0, 0, -a1[0]*b1[0], -a1[1]*b1[0]],
                           [    0,     0, 0, a1[0], a1[1], 1, -a1[0]*b1[1], -a1[1]*b1[1]],
                           [a2[0], a2[1], 1,     0,     0, 0, -a2[0]*b2[0], -a2[1]*b2[0]],
                           [    0,     0, 0, a2[0], a2[1], 1, -a2[0]*b2[1], -a2[1]*b2[1]],
                           [a3[0], a3[1], 1,     0,     0, 0, -a3[0]*b3[0], -a3[1]*b3[0]],
                           [    0,     0, 0, a3[0], a3[1], 1, -a3[0]*b3[1], -a3[1]*b3[1]]] )

        B = np.array([b0[0], b0[1], b1[0], b1[1], b2[0], b2[1], b3[0], b3[1]])

        C = np.linalg.solve(A, B)
        return C</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.homography.image_in_image"><code class="name flex">
<span>def <span class="ident">image_in_image</span></span>(<span>im1, im2, tp)</span>
</code></dt>
<dd>
<section class="desc"><p>put im1 in im2 with an affine transformation
such that corners are as close to tp as possible.
tp are homogeneous and counter-clockwise from top left.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def image_in_image(im1,im2,tp):
        &#34;&#34;&#34; put im1 in im2 with an affine transformation
                such that corners are as close to tp as possible.
                tp are homogeneous and counter-clockwise from top left.&#34;&#34;&#34;

        #points to warp from
        m,n = im1.shape[:2]
        fp = np.array([[0,m,m,0],[0,0,n,n],[1,1,1,1]])

        #compute affine transform and apply
        H = Haffine_from_points(tp,fp)
        im1_t = ndimage.affine_transform(im1,H[:2,:2],(H[0,2],H[1,2]),im2.shape[:2])
        alpha = (im1_t &gt; 0)

        return (1-alpha)*im2 + alpha*im1_t</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.homography.make_homog"><code class="name flex">
<span>def <span class="ident">make_homog</span></span>(<span>points)</span>
</code></dt>
<dd>
<section class="desc"><p>Convert a set of points (dim*n array) to
homogeneous coordinates.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_homog(points):
        &#34;&#34;&#34; Convert a set of points (dim*n array) to
        homogeneous coordinates. &#34;&#34;&#34;
        return np.vstack((points,np.ones((1,points.shape[1]))))</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.homography.normalize"><code class="name flex">
<span>def <span class="ident">normalize</span></span>(<span>points)</span>
</code></dt>
<dd>
<section class="desc"><p>Normalize a collection of points in
homogeneous coordinates so that last row = 1.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize(points):
        &#34;&#34;&#34; Normalize a collection of points in
        homogeneous coordinates so that last row = 1. &#34;&#34;&#34;
        for row in points:
                row /= points[-1]
        return points</code></pre>
</details>
</dd>
<dt id="ephysiopy.dacq2py.homography.transform_pt"><code class="name flex">
<span>def <span class="ident">transform_pt</span></span>(<span>pt, coeffs)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_pt(pt , coeffs ):
        T = coeffs
        x = (T[0]*pt[0] + T[1]*pt[1] + T[2])/(T[6]*pt[0] + T[7]*pt[1] + 1)
        y = (T[3]*pt[0] + T[4]*pt[1] + T[5])/(T[6]*pt[0] + T[7]*pt[1] + 1)
        return x,y</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ephysiopy.dacq2py" href="index.html">ephysiopy.dacq2py</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="ephysiopy.dacq2py.homography.H_from_points" href="#ephysiopy.dacq2py.homography.H_from_points">H_from_points</a></code></li>
<li><code><a title="ephysiopy.dacq2py.homography.Haffine_from_points" href="#ephysiopy.dacq2py.homography.Haffine_from_points">Haffine_from_points</a></code></li>
<li><code><a title="ephysiopy.dacq2py.homography.get_transform_data" href="#ephysiopy.dacq2py.homography.get_transform_data">get_transform_data</a></code></li>
<li><code><a title="ephysiopy.dacq2py.homography.image_in_image" href="#ephysiopy.dacq2py.homography.image_in_image">image_in_image</a></code></li>
<li><code><a title="ephysiopy.dacq2py.homography.make_homog" href="#ephysiopy.dacq2py.homography.make_homog">make_homog</a></code></li>
<li><code><a title="ephysiopy.dacq2py.homography.normalize" href="#ephysiopy.dacq2py.homography.normalize">normalize</a></code></li>
<li><code><a title="ephysiopy.dacq2py.homography.transform_pt" href="#ephysiopy.dacq2py.homography.transform_pt">transform_pt</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>